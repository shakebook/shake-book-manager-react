{"version":3,"sources":["webpack://Algorithm/webpack/bootstrap","webpack://Algorithm/webpack/runtime/define property getters","webpack://Algorithm/webpack/runtime/hasOwnProperty shorthand","webpack://Algorithm/webpack/runtime/make namespace object","webpack://Algorithm/./src/adjacent-matrix.ts","webpack://Algorithm/./src/structs/linked-list.ts","webpack://Algorithm/./src/structs/queue.ts","webpack://Algorithm/./src/util.ts","webpack://Algorithm/./src/bfs.ts","webpack://Algorithm/./src/connected-component.ts","webpack://Algorithm/./src/degree.ts","webpack://Algorithm/./src/dfs.ts","webpack://Algorithm/./src/detect-cycle.ts","webpack://Algorithm/./node_modules/_tslib@2.1.0@tslib/tslib.es6.js","webpack://Algorithm/../src/is-type.ts","webpack://Algorithm/../src/is-array.ts","webpack://Algorithm/../src/keys.ts","webpack://Algorithm/../src/pull.ts","webpack://Algorithm/../src/pull-at.ts","webpack://Algorithm/../src/group-by.ts","webpack://Algorithm/../src/is-integer.ts","webpack://Algorithm/../src/to-degree.ts","webpack://Algorithm/../src/to-integer.ts","webpack://Algorithm/../src/to-radian.ts","webpack://Algorithm/../src/values.ts","webpack://Algorithm/../src/is-prototype.ts","webpack://Algorithm/../src/clone.ts","webpack://Algorithm/../src/is-empty.ts","webpack://Algorithm/../src/pick.ts","webpack://Algorithm/../src/cache.ts","webpack://Algorithm/./src/dijkstra.ts","webpack://Algorithm/./src/find-path.ts","webpack://Algorithm/./src/floydWarshall.ts","webpack://Algorithm/./src/label-propagation.ts","webpack://Algorithm/./src/louvain.ts","webpack://Algorithm/./src/structs/union-find.ts","webpack://Algorithm/./src/structs/binary-heap.ts","webpack://Algorithm/./src/mts.ts","webpack://Algorithm/./src/pageRank.ts","webpack://Algorithm/./src/gSpan/struct.ts","webpack://Algorithm/./src/gSpan/gSpan.ts","webpack://Algorithm/./src/gaddi.ts","webpack://Algorithm/./src/workers/constant.ts","webpack://Algorithm/./src/workers/index.worker.ts"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","graphData","directed","nodes","edges","matrix","nodeMap","Error","forEach","node","i","id","push","edge","source","target","sIndex","tIndex","defaultComparator","a","b","next","this","toString","callback","comparator","head","tail","compare","prepend","newNode","LinkedListNode","append","delete","deleteNode","currentNode","find","undefined","deleteTail","deletedTail","deleteHead","deletedHead","fromArray","values","toArray","reverse","prevNode","nextNode","map","linkedList","isEmpty","peek","enqueue","dequeue","removeHead","nodeId","type","currentEdges","filter","getEdgesByNodeId","uniqueId","index","Math","random","split","substr","startNodeId","originalCallbacks","callbacks","seen","initiatedCallback","stubCallback","allowTraversalCallback","allowTraversal","enter","leave","initCallbacks","nodeQueue","previousNode","current","previous","nodeStack","inStack","indices","lowLink","allComponents","getComponent","neighbors","n","indexOf","targetNodeID","min","targetNode","length","component","tmpNode","pop","visited","neighbor","detectConnectedComponents","degree","degrees","inDegree","outDegree","getInDegree","getOutDegree","depthFirstSearchRecursive","depthFirstSearch","cycle","dfsParentMap","unvisitedSet","visitingSet","visitedSet","currentCycleNode","previousCycleNode","keys","__spreadArrays","s","il","arguments","r","Array","k","j","jl","create","rst","default_1","weightPropertyName","nodeIds","marks","D","prevs","Infinity","nodeNum","minNode","minDis","minVertex","minNodeId","getOutEdgesNodeId","edgeTarget","edgeSource","w","weight","allPaths","findAllPaths","path","foundPaths","paths","prevPaths","prePath","findShortestPath","start","end","allPath","findAllPath","isVisited","stack","children","child","shift","adjacentMatrix","dist","size","maxIteration","clusters","cid","clusterId","idx","adjMatrix","ks","row","iid","entry","jid","iter","changed","neighborClusters","neighborId","neighborWeight","neighborClusterId","maxWeight","bestClusterIds","selfClusterIdx","splice","selfCluster","nodeInSelfClusterIdx","randomIdx","floor","bestCluster","cluster","clusterEdges","clusterEdgeMap","sourceClusterId","targetClusterId","newEdgeId","count","newEdge","clustersArray","getModularity","m","param","modularity","clusteri","threshold","totalModularity","previousModularity","abs","sumTot","bestIncrease","commonParam","kiin","scNode","scNodeIdx","removeModurarity","nodeNeighborIds","neighborNodeId","neighborCluster","clusterNodes","neighborClusterKiin","cNode","cNodeIdx","increase","items","parent","item","union","rootA","rootB","connected","defaultCompare","compareFn","list","getLeft","getRight","getParent","top","delMin","bottom","moveDown","insert","moveUp","tmp","element","left","right","primMST","selectedEdges","currNode","Set","add","edgeQueue","currEdge","has","kruskalMST","weightEdges","sort","disjointSet","curEdge","algo","prim","kruskal","epsilon","linkProb","currentRank","distance","leakedRank","maxIterations","nodesCount","curRanks","prevRanks","nodeDegree","VACANT_NODE_LABEL","from","to","label","edgeMap","addEdge","edgeIdAutoIncrease","nodeLabelMap","edgeLabelMap","counter","getNodeNum","addNode","Node","Edge","rEdge","fromNode","toNode","fromNodeLabel","edgeLabel","toNodeLabel","nodeEdgeNodeLabel","nodeLabel1","nodeLabel2","equalTo","other","formNode","notEqualTo","rmpath","dfsEdgeList","aLength","pushBack","DFSedge","toGraph","graphId","graph","Graph","dfsEdge","fromNodeId","toNodeId","buildRmpath","oldFrom","fromNodeIdx","toNodeIdx","pdfs","his","nodesUsed","edgesUsed","e","preNode","hasNode","hasEdge","graphs","minSupport","minNodeNum","maxNodeNum","verbose","dfsCode","DFScode","support","frequentSize1Subgraphs","frequentSubgraphs","reportDF","findForwardRootEdges","result","findBackwardEdge","edge1","edge2","history","edge2ToEdges","edgeLength","findForwardPureEdges","rightmostEdge","minNodeLabel","rightmostEdgeToId","findForwardRmpathEdges","newToNodeLabel","getSupport","projected","graphMap","pro","findMinLabel","minLabel","isMin","console","log","dfsCodeMin","root","otherNode","projectIsMin","maxToC","backwardRoot","flag","newTo","p","History","backwardEdge","minBackwardEdgeLabel","forwardRoot","newFrom","forwardPureEdges","pathLength","forwardRmpathEdges","forwardMinEdgeNodeLabel","report","subGraphMining","generate1EdgeFrequentSubGraphs","nodeLabelCounter","nodeEdgeNodeCounter","nodeLableCounted","nodeEdgeNodeLabelCounted","nodeLabel","graphNodeKey","graphKey","graphNodeEdgeNodeKey","nodeEdgeNodeKey","g","run","DEFAULT_LABEL_NAME","findKNeighborUnits","spm","nodeLabelProp","units","findKNeighborUnit","unitNodeIdxs","labelCountMap","v","dists","nodeIdx","nodeIdxs","neighborNum","nodeLabelCountMap","getIntersectNeighborInducedGraph","nodePairMap","neighborUnits","cachedInducedGraphMap","pair","startUnitNodeIds","endUnitNodeIds","endSet","intersect","x","intersectIdMap","intersectLength","getMatchedCount","structure","edgeLabelProp","sourceLabel","targetLabel","strNodeLabel1","strNodeLabel2","strEdgeLabel","getNodeMaps","getEdgeMaps","sourceNode","getSpmMap","iId","jId","pattern","patternSpm","spmMap","patternSpmMap","patternNodeMap","patternNodeLabelMap","patternEdgeLabelMap","max","kNeighborUnits","patternKNeighborUnits","nodePairsMap","maxNodePairNum","nodePairNumEachNode","ceil","foundNodePairCount","unit","nodePairForICount","outerLoopCount","oidx","innerLoopCount","findNodePairsRandomly","intGMap","freStructures","params","formattedGraphs","fGraph","nodeIdxMap","sourceIdx","targetIdx","formatGraphs","calculator","GSpan","toGraphDatas","slice","structureNum","matchedCountMap","subStructureCount","structures","maxOffset","representClusterType","countMapI","sortedGraphKeys","totalCount","aveCount","aveIntraDist","aveCounts","graphsInCluster","aveIntraPerCluster","graphsNum","graphKey1","graph1Count","graphKey2","aveInterDist","aveCount1","aveCount2","offset","structureCountMap","findRepresentStructure","dsG","ndsDist","beginPNode","candidates","minPatternNodeLabelDegreeMap","patternIntGraphMap","patternNDSDist","patternNDSDistMap","patternSpDist","label2","maxDist","patternNodesWithLabel2","patternNodePairMap","nodeWithLabel2","currentPatternNDSDistArray","patternIntGraph","graphNeighborUnit","graphNeighborUnitCountMap","patternLabel2Num","prune2Invalid","cNodePairMap","neighborNode","currentNDSDistArray","intGraph","prune3Invalid","candidateGraphs","candidate","neighborNodes","unmatched","neighborLabel","distToCandidate","ndsToCandidate","node1","node2","spDist","cachedNDSMap","cachedInterInducedGraph","interInducedGraph","pairMap","getNDSDist","patternKey","minPatternNodeLabelDegree","patternNodeWithLabel","patternNodeDegree","concat","undirectedLengthsToBeginPNode","undirectedLengthsToBeginPNodeLabelMap","pLabel","candidateGraph","candidateNodeLabelCountMap","candidateNodeMap","q","cNodeLabel","candidateEdges","edgeLabelCountMap","pattenrEdgeLabelNum","prunedByEdgeLabel","candidateEdgeNum","candidateGraphInvalid","patternEdgesWithLabel","edgeMatched","patternEdge","patternSource","patternTarget","lengthsToCandidate","targetId","targetNodeLabel","nLabel","degreeChanged","loopCount","cgNode","y","cedge","currentLength","cg1","cg1EdgeMap","cg2","cg2EdgeMap","same","ctx","self","onmessage","event","data","postMessage"],"mappings":"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","file":"index.worker.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { GraphData, Matrix } from \"./types\";\n\nconst adjMatrix = (graphData: GraphData, directed?: boolean) => {\n  const { nodes, edges } = graphData;\n  const matrix: Matrix[] = [];\n  // map node with index in data.nodes\n  const nodeMap: {\n    [key: string]: number;\n  } = {};\n\n  if (!nodes) {\n    throw new Error(\"invalid nodes data!\");\n  }\n\n  if (nodes) {\n    nodes.forEach((node, i) => {\n      nodeMap[node.id] = i;\n      const row: number[] = [];\n      matrix.push(row);\n    });\n  }\n\n  if (edges) {\n    edges.forEach((edge) => {\n      const { source, target } = edge;\n      const sIndex = nodeMap[source as string];\n      const tIndex = nodeMap[target as string];\n      if ((!sIndex && sIndex !== 0) || (!tIndex && tIndex !== 0)) return;\n      matrix[sIndex][tIndex] = 1;\n      if (!directed) {\n        matrix[tIndex][sIndex] = 1;\n      }\n    });\n  }\n  return matrix;\n};\n\nexport default adjMatrix;\n","const defaultComparator = (a, b) => {\n  if (a === b) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * \n */\nexport class LinkedListNode {\n  public value;\n\n  public next: LinkedListNode;\n\n  constructor(value, next: LinkedListNode = null) {\n    this.value = value;\n    this.next = next;\n  }\n\n  toString(callback?: any) {\n    return callback ? callback(this.value) : `${this.value}`;\n  }\n}\n\nexport default class LinkedList {\n  public head: LinkedListNode;\n\n  public tail: LinkedListNode;\n\n  public compare: Function;\n\n  constructor(comparator = defaultComparator) {\n    this.head = null;\n    this.tail = null;\n    this.compare = comparator;\n  }\n\n  /**\n   * \n   * @param value\n   */\n  prepend(value) {\n    // \n    const newNode = new LinkedListNode(value, this.head);\n    this.head = newNode;\n\n    if (!this.tail) {\n      this.tail = newNode;\n    }\n\n    return this;\n  }\n\n  /**\n   * \n   * @param value\n   */\n  append(value) {\n    const newNode = new LinkedListNode(value);\n\n    // \n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n\n      return this;\n    }\n\n    // \n    this.tail.next = newNode;\n    this.tail = newNode;\n\n    return this;\n  }\n\n  /**\n   * \n   * @param value \n   */\n  delete(value): LinkedListNode {\n    if (!this.head) {\n      return null;\n    }\n\n    let deleteNode = null;\n\n    // next\n    while (this.head && this.compare(this.head.value, value)) {\n      deleteNode = this.head;\n      this.head = this.head.next;\n    }\n\n    let currentNode = this.head;\n\n    if (currentNode !== null) {\n      // next\n      while (currentNode.next) {\n        if (this.compare(currentNode.next.value, value)) {\n          deleteNode = currentNode.next;\n          currentNode.next = currentNode.next.next;\n        } else {\n          currentNode = currentNode.next;\n        }\n      }\n    }\n\n    // \n    if (this.compare(this.tail.value, value)) {\n      this.tail = currentNode;\n    }\n\n    return deleteNode;\n  }\n\n  /**\n   * \n   * @param param0\n   */\n  find({ value = undefined, callback = undefined }): LinkedListNode {\n    if (!this.head) {\n      return null;\n    }\n\n    let currentNode = this.head;\n\n    while (currentNode) {\n      //  callback callback \n      if (callback && callback(currentNode.value)) {\n        return currentNode;\n      }\n\n      //  value value \n      if (value !== undefined && this.compare(currentNode.value, value)) {\n        return currentNode;\n      }\n\n      currentNode = currentNode.next;\n    }\n\n    return null;\n  }\n\n  /**\n   * \n   */\n  deleteTail() {\n    const deletedTail = this.tail;\n\n    if (this.head === this.tail) {\n      // \n      this.head = null;\n      this.tail = null;\n      return deletedTail;\n    }\n\n    let currentNode = this.head;\n    while (currentNode.next) {\n      if (!currentNode.next.next) {\n        currentNode.next = null;\n      } else {\n        currentNode = currentNode.next;\n      }\n    }\n\n    this.tail = currentNode;\n\n    return deletedTail;\n  }\n\n  /**\n   * \n   */\n  deleteHead() {\n    if (!this.head) {\n      return null;\n    }\n\n    const deletedHead = this.head;\n\n    if (this.head.next) {\n      this.head = this.head.next;\n    } else {\n      this.head = null;\n      this.tail = null;\n    }\n\n    return deletedHead;\n  }\n\n  /**\n   * \n   * @param values \n   */\n  fromArray(values) {\n    values.forEach((value) => this.append(value));\n    return this;\n  }\n\n  /**\n   * \n   */\n  toArray() {\n    const nodes = [];\n\n    let currentNode = this.head;\n\n    while (currentNode) {\n      nodes.push(currentNode);\n      currentNode = currentNode.next;\n    }\n\n    return nodes;\n  }\n\n  /**\n   * \n   */\n  reverse() {\n    let currentNode = this.head;\n    let prevNode = null;\n    let nextNode = null;\n    while (currentNode) {\n      // \n      nextNode = currentNode.next;\n\n      // \n      currentNode.next = prevNode;\n\n      //  prevNode  currentNode \n      prevNode = currentNode;\n      currentNode = nextNode;\n    }\n\n    this.tail = this.head;\n    this.head = prevNode;\n  }\n\n  toString(callback = undefined) {\n    return this.toArray()\n      .map((node) => node.toString(callback))\n      .toString();\n  }\n}\n","import LinkedList from './linked-list';\n\nexport default class Queue {\n  public linkedList: LinkedList;\n\n  constructor() {\n    this.linkedList = new LinkedList();\n  }\n\n  /**\n   * \n   */\n  public isEmpty() {\n    return !this.linkedList.head;\n  }\n\n  /**\n   *  \n   */\n  public peek() {\n    if (!this.linkedList.head) {\n      return null;\n    }\n    return this.linkedList.head.value;\n  }\n\n  /**\n   * \n   * @param value\n   */\n  public enqueue(value) {\n    this.linkedList.append(value);\n  }\n\n  /**\n   *  null\n   */\n  public dequeue() {\n    const removeHead = this.linkedList.deleteHead();\n    return removeHead ? removeHead.value : null;\n  }\n\n  public toString(callback?: any) {\n    return this.linkedList.toString(callback);\n  }\n}\n","import { EdgeConfig, GraphData, Matrix } from './types'\n\n/**\n * \n * @param nodeId  ID\n * @param edges \n * @param type \n */\nexport const getNeighbors = (nodeId: string, edges: EdgeConfig[] = [], type?: 'target' | 'source' | undefined): string[] => {\n  const currentEdges = edges.filter(edge => edge.source === nodeId || edge.target === nodeId)\n  if (type === 'target') {\n    //  source\n    const neighhborsConverter = (edge: EdgeConfig) => {\n      return edge.source === nodeId;\n    };\n    return currentEdges.filter(neighhborsConverter).map((edge) => edge.target);\n  }\n  if (type === 'source') {\n    //  target\n    const neighhborsConverter = (edge: EdgeConfig) => {\n      return edge.target === nodeId;\n    };\n    return currentEdges.filter(neighhborsConverter).map((edge) => edge.source);\n  }\n\n  //  type \n  const neighhborsConverter = (edge: EdgeConfig) => {\n    return edge.source === nodeId ? edge.target : edge.source;\n  };\n  return currentEdges.map(neighhborsConverter);\n}\n\n/**\n * \n * @param nodeId  ID\n * @param edges \n */\nexport const getOutEdgesNodeId = (nodeId: string, edges: EdgeConfig[]) => {\n  return edges.filter(edge => edge.source === nodeId)\n}\n\n/**\n * \n * @param nodeId  ID\n * @param edges \n */\nexport const getEdgesByNodeId = (nodeId: string, edges: EdgeConfig[]) => {\n  return edges.filter(edge => edge.source === nodeId || edge.target === nodeId)\n}\n\n/**\n *  ID + \n * @param index \n */\nexport const uniqueId = (index: number = 0) => {\n  const random1 = `${Math.random()}`.split('.')[1].substr(0, 5);\n  const random2 = `${Math.random()}`.split('.')[1].substr(0, 5);\n  return `${index}-${random1}${random2}`\n};\n","import Queue from './structs/queue'\nimport { GraphData, IAlgorithmCallbacks } from './types';\nimport { getNeighbors } from './util';\n\n/**\n *\n * @param callbacks\n * allowTraversal:  BFS \n * enterNode:  BFS \n * leaveNode:  BFS \n */\nfunction initCallbacks(callbacks: IAlgorithmCallbacks = {} as IAlgorithmCallbacks) {\n  const initiatedCallback = callbacks;\n\n  const stubCallback = () => {};\n\n  const allowTraversalCallback = (() => {\n    const seen = {};\n    return ({ next }) => {\n      const id = next;\n      if (!seen[id]) {\n        seen[id] = true;\n        return true;\n      }\n      return false;\n    };\n  })();\n\n  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;\n  initiatedCallback.enter = callbacks.enter || stubCallback;\n  initiatedCallback.leave = callbacks.leave || stubCallback;\n\n  return initiatedCallback;\n}\n\n/**\n * \n * @param graph Graph \n * @param startNode \n * @param originalCallbacks \n */\nconst breadthFirstSearch = (\n  graphData: GraphData,\n  startNodeId: string,\n  originalCallbacks?: IAlgorithmCallbacks,\n) => {\n  const callbacks = initCallbacks(originalCallbacks);\n  const nodeQueue = new Queue();\n\n  const { edges = [] } = graphData\n\n  // \n  nodeQueue.enqueue(startNodeId);\n\n  let previousNode = '';\n\n  // \n  while (!nodeQueue.isEmpty()) {\n    const currentNode: string = nodeQueue.dequeue();\n    callbacks.enter({\n      current: currentNode,\n      previous: previousNode,\n    });\n\n    // \n    getNeighbors(currentNode, edges, 'target').forEach((nextNode) => {\n      if (\n        callbacks.allowTraversal({\n          previous: previousNode,\n          current: currentNode,\n          next: nextNode,\n        })\n      ) {\n        nodeQueue.enqueue(nextNode);\n      }\n    });\n\n    callbacks.leave({\n      current: currentNode,\n      previous: previousNode,\n    });\n\n    // \n    previousNode = currentNode;\n  }\n};\n\nexport default breadthFirstSearch;\n","import { GraphData, NodeConfig } from \"./types\";\nimport { getNeighbors } from \"./util\";\n\n/**\n * Generate all connected components for an undirected graph\n * @param graph\n */\nexport const detectConnectedComponents = (graphData: GraphData): NodeConfig[][] => {\n  const { nodes = [], edges = [] } = graphData\n  const allComponents: NodeConfig[][] = [];\n  const visited = {};\n  const nodeStack: NodeConfig[] = [];\n\n  const getComponent = (node: NodeConfig) => {\n    nodeStack.push(node);\n    visited[node.id] = true;\n    const neighbors = getNeighbors(node.id, edges);\n    for (let i = 0; i < neighbors.length; ++i) {\n      const neighbor = neighbors[i];\n      if (!visited[neighbor]) {\n        const targetNode = nodes.filter(node => node.id === neighbor)\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n      }\n    }\n  };\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!visited[node.id]) {\n      // dfs\n      getComponent(node);\n      const component = [];\n      while (nodeStack.length > 0) {\n        component.push(nodeStack.pop());\n      }\n      allComponents.push(component);\n    }\n  }\n  return allComponents;\n}\n\n/**\n * Tarjan's Algorithm   O(|V|+|E|)\n * For directed graph only\n * a directed graph is said to be strongly connected if \"every vertex is reachable from every other vertex\".\n * refer: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n * @param graph\n * @return a list of strongly connected components\n */\nexport const detectStrongConnectComponents = (graphData: GraphData): NodeConfig[][] => {\n  const { nodes = [], edges = [] } = graphData\n  const nodeStack: NodeConfig[] = [];\n  const inStack = {}; // stack\n  const indices = {};\n  const lowLink = {};\n  const allComponents: NodeConfig[][] = [];\n  let index = 0;\n\n  const getComponent = (node: NodeConfig) => {\n    // Set the depth index for v to the smallest unused index\n    indices[node.id] = index;\n    lowLink[node.id] = index;\n    index += 1;\n    nodeStack.push(node);\n    inStack[node.id] = true;\n\n    // \n    const neighbors = getNeighbors(node.id, edges, 'target').filter((n) => nodes.map(node => node.id).indexOf(n) > -1);\n    for (let i = 0; i < neighbors.length; i++) {\n      const targetNodeID = neighbors[i];\n      if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {\n        const targetNode = nodes.filter(node => node.id === targetNodeID)\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n        // tree edge\n        lowLink[node.id] = Math.min(lowLink[node.id], lowLink[targetNodeID]);\n      } else if (inStack[targetNodeID]) {\n        // back edge, target node is in the current SCC\n        lowLink[node.id] = Math.min(lowLink[node.id], indices[targetNodeID]);\n      }\n    }\n\n    // If node is a root node, generate an SCC\n    if (lowLink[node.id] === indices[node.id]) {\n      const component = [];\n      while (nodeStack.length > 0) {\n        const tmpNode = nodeStack.pop();\n        inStack[tmpNode.id] = false;\n        component.push(tmpNode);\n        if (tmpNode === node) break;\n      }\n      if (component.length > 0) {\n        allComponents.push(component);\n      }\n    }\n  };\n\n  for (const node of nodes) {\n    if (!indices[node.id] && indices[node.id] !== 0) {\n      getComponent(node);\n    }\n  }\n\n  return allComponents;\n}\n\nexport default function getConnectedComponents(graphData: GraphData, directed?: boolean): NodeConfig[][] {\n  if (directed) return detectStrongConnectComponents(graphData);\n  return detectConnectedComponents(graphData);\n}\n","import { GraphData, DegreeType } from \"./types\";\n\nconst degree = (graphData: GraphData): DegreeType => {\n  const degrees: DegreeType = {};\n  const { nodes = [], edges = [] } = graphData\n\n  nodes.forEach((node) => {\n    degrees[node.id] = {\n      degree: 0,\n      inDegree: 0,\n      outDegree: 0,\n    };\n  });\n\n  edges.forEach((edge) => {\n    degrees[edge.source].degree++;\n    degrees[edge.source].outDegree++;\n    degrees[edge.target].degree++;\n    degrees[edge.target].inDegree++;\n  });\n\n  return degrees;\n};\n\nexport default degree;\n\n/**\n * \n * @param graphData \n * @param nodeId ID\n */\nexport const getInDegree = (graphData: GraphData, nodeId: string) => {\n  const nodeDegree = degree(graphData)\n  if (nodeDegree[nodeId]) {\n    return degree(graphData)[nodeId].inDegree\n  }\n  return 0\n}\n\n/**\n * \n * @param graphData \n * @param nodeId ID\n */\nexport const getOutDegree = (graphData: GraphData, nodeId: string) => {\n  const nodeDegree = degree(graphData)\n  if (nodeDegree[nodeId]) {\n    return degree(graphData)[nodeId].outDegree\n  }\n  return 0\n}\n","import { IAlgorithmCallbacks, GraphData } from './types'\nimport { getNeighbors } from './util'\n\nfunction initCallbacks(callbacks: IAlgorithmCallbacks = {} as IAlgorithmCallbacks) {\n  const initiatedCallback = callbacks;\n\n  const stubCallback = () => {};\n\n  const allowTraversalCallback = (() => {\n    const seen = {};\n    return ({ next }) => {\n      if (!seen[next]) {\n        seen[next] = true;\n        return true;\n      }\n      return false;\n    };\n  })();\n\n  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;\n  initiatedCallback.enter = callbacks.enter || stubCallback;\n  initiatedCallback.leave = callbacks.leave || stubCallback;\n\n  return initiatedCallback;\n}\n\n/**\n * @param {Graph} graph\n * @param {GraphNode} currentNode\n * @param {GraphNode} previousNode\n * @param {Callbacks} callbacks\n */\nfunction depthFirstSearchRecursive(\n  graphData: GraphData,\n  currentNode: string,\n  previousNode: string,\n  callbacks: IAlgorithmCallbacks,\n) {\n  callbacks.enter({\n    current: currentNode,\n    previous: previousNode,\n  });\n\n  const { edges = [] } = graphData\n\n  getNeighbors(currentNode, edges, 'target').forEach((nextNode) => {\n    if (\n      callbacks.allowTraversal({\n        previous: previousNode,\n        current: currentNode,\n        next: nextNode,\n      })\n    ) {\n      depthFirstSearchRecursive(graphData, nextNode, currentNode, callbacks);\n    }\n  });\n\n  callbacks.leave({\n    current: currentNode,\n    previous: previousNode,\n  });\n}\n\n/**\n * \n * @param data GraphData \n * @param startNodeId  ID\n * @param originalCallbacks \n */\nexport default function depthFirstSearch(\n  graphData: GraphData,\n  startNodeId: string,\n  callbacks?: IAlgorithmCallbacks,\n) {\n  depthFirstSearchRecursive(graphData, startNodeId, '', initCallbacks(callbacks));\n}\n","import dfs from './dfs';\nimport getConnectedComponents, { detectStrongConnectComponents } from './connected-component';\nimport { GraphData, IAlgorithmCallbacks, NodeConfig } from './types';\nimport { getNeighbors } from './util';\n\nconst detectDirectedCycle = (graphData: GraphData) => {\n  let cycle: {\n    [key: string]: string;\n  } = null;\n\n  const { nodes = [] } = graphData\n\n  const dfsParentMap = {};\n\n  // \n  const unvisitedSet = {};\n\n  // \n  const visitingSet = {};\n\n  // \n  const visitedSet = {};\n\n  //  unvisitedSet\n  nodes.forEach((node) => {\n    unvisitedSet[node.id] = node;\n  });\n\n  const callbacks: IAlgorithmCallbacks = {\n    enter: ({ current: currentNode, previous: previousNode }) => {\n      if (visitingSet[currentNode]) {\n        // \n        cycle = {};\n\n        let currentCycleNode = currentNode;\n        let previousCycleNode = previousNode;\n\n        while (previousCycleNode !== currentNode) {\n          cycle[currentCycleNode] = previousCycleNode;\n          currentCycleNode = previousCycleNode;\n          previousCycleNode = dfsParentMap[previousCycleNode];\n        }\n\n        cycle[currentCycleNode] = previousCycleNode;\n      } else {\n        // \n        visitingSet[currentNode] = currentNode;\n        delete unvisitedSet[currentNode];\n\n        //  DSF parents \n        dfsParentMap[currentNode] = previousNode;\n      }\n    },\n    leave: ({ current: currentNode }) => {\n      // \n      // \n      visitedSet[currentNode] = currentNode;\n      delete visitingSet[currentNode];\n    },\n    allowTraversal: ({ next: nextNode }) => {\n      // \n      if (cycle) {\n        return false;\n      }\n\n      // visitedSet \n      return !visitedSet[nextNode];\n    },\n  };\n\n  // \n  while (Object.keys(unvisitedSet).length) {\n    //  DFS \n    const firsetUnVisitedKey = Object.keys(unvisitedSet)[0];\n\n    dfs(graphData, firsetUnVisitedKey, callbacks);\n  }\n\n  return cycle;\n};\n\n/**\n * Base cycles\n * refer: https://www.codeproject.com/Articles/1158232/Enumerating-All-Cycles-in-an-Undirected-Graph\n * @param graph\n * @param nodeIds  ID \n * @param include \n * @return [{[key: string]: INode}] base cycles\n */\nexport const detectAllUndirectedCycle = (graphData: GraphData, nodeIds?: string[], include = true) => {\n  const allCycles = [];\n  const components = getConnectedComponents(graphData, false);\n\n  // loop through all connected components\n  for (const component of components) {\n    if (!component.length) continue;\n    const root = component[0];\n    const rootId = root.id;\n\n    const stack = [root];\n    const parent = { [rootId]: root };\n    const used = { [rootId]: new Set() };\n\n    // walk a spanning tree to find cycles\n    while (stack.length > 0) {\n      const curNode = stack.pop();\n      const curNodeId = curNode.id;\n      const neighbors = getNeighbors(curNodeId, graphData.edges);\n      for (let i = 0; i < neighbors.length; i += 1) {\n        const neighborId = neighbors[i];\n        const neighbor = graphData.nodes.find(node => node.id === neighborId)\n        // const neighborId = neighbor.get('id');\n        if (neighborId === curNodeId) {\n          // \n          allCycles.push({ [neighborId]: curNode });\n        } else if (!(neighborId in used)) {\n          // visit a new node\n          parent[neighborId] = curNode;\n          stack.push(neighbor);\n          used[neighborId] = new Set([curNode]);\n        } else if (!used[curNodeId].has(neighbor)) {\n          // a cycle found\n          let cycleValid = true;\n          const cyclePath = [neighbor, curNode];\n          let p = parent[curNodeId];\n          while (used[neighborId].size && !used[neighborId].has(p)) {\n            cyclePath.push(p);\n            if (p === parent[p.id]) break;\n            else p = parent[p.id];\n          }\n          cyclePath.push(p);\n\n          if (nodeIds && include) {\n            // \n            cycleValid = false;\n            if (cyclePath.findIndex((node) => nodeIds.indexOf(node.id) > -1) > -1) {\n              cycleValid = true;\n            }\n          } else if (nodeIds && !include) {\n            // \n            if (cyclePath.findIndex((node) => nodeIds.indexOf(node.id) > -1) > -1) {\n              cycleValid = false;\n            }\n          }\n\n          //  node list  cycle \n          if (cycleValid) {\n            const cycle = {};\n            for (let index = 1; index < cyclePath.length; index += 1) {\n              cycle[cyclePath[index - 1].id] = cyclePath[index];\n            }\n            if (cyclePath.length) {\n              cycle[cyclePath[cyclePath.length - 1].id] = cyclePath[0];\n            }\n            allCycles.push(cycle);\n          }\n\n          used[neighborId].add(curNode);\n        }\n      }\n    }\n  }\n\n  return allCycles;\n};\n\n/**\n * Johnson's algorithm,  O((V + E)(C + 1))$ and space bounded by O(V + E)\n * refer: https://www.cs.tufts.edu/comp/150GA/homeworks/hw1/Johnson%2075.PDF\n * refer: https://networkx.github.io/documentation/stable/_modules/networkx/algorithms/cycles.html#simple_cycles\n * @param graph\n * @param nodeIds  ID \n * @param include \n * @return [{[key: string]: INode}]  simple cycles\n */\nexport const detectAllDirectedCycle = (graphData: GraphData, nodeIds?: string[], include = true) => {\n  const path = []; // stack of nodes in current path\n  const blocked = new Set();\n  const B = []; // remember portions of the graph that yield no elementary circuit\n  const allCycles = [];\n  const idx2Node: {\n    [key: string]: NodeConfig;\n  } = {};\n  const node2Idx = {};\n\n  //  unblock all blocked nodes\n  const unblock = (thisNode: NodeConfig) => {\n    const stack = [thisNode];\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (blocked.has(node)) {\n        blocked.delete(node);\n        B[node.id].forEach((n) => {\n          stack.push(n);\n        });\n        B[node.id].clear();\n      }\n    }\n  };\n\n  const circuit = (node: NodeConfig, start: NodeConfig, adjList) => {\n    let closed = false; // whether a path is closed\n    if (nodeIds && include === false && nodeIds.indexOf(node.id) > -1) return closed;\n    path.push(node);\n    blocked.add(node);\n\n    const neighbors = adjList[node.id];\n    for (let i = 0; i < neighbors.length; i += 1) {\n      const neighbor = idx2Node[neighbors[i]];\n      if (neighbor === start) {\n        const cycle = {};\n        for (let index = 1; index < path.length; index += 1) {\n          cycle[path[index - 1].id] = path[index];\n        }\n        if (path.length) {\n          cycle[path[path.length - 1].id] = path[0];\n        }\n        allCycles.push(cycle);\n        closed = true;\n      } else if (!blocked.has(neighbor)) {\n        if (circuit(neighbor, start, adjList)) {\n          closed = true;\n        }\n      }\n    }\n\n    if (closed) {\n      unblock(node);\n    } else {\n      for (let i = 0; i < neighbors.length; i += 1) {\n        const neighbor = idx2Node[neighbors[i]];\n        if (!B[neighbor.id].has(node)) {\n          B[neighbor.id].add(node);\n        }\n      }\n    }\n    path.pop();\n    return closed;\n  };\n\n  const { nodes = [] } = graphData;\n\n  // Johnson's algorithm \n  for (let i = 0; i < nodes.length; i += 1) {\n    const node = nodes[i];\n    const nodeId = node.id;\n    node2Idx[nodeId] = i;\n    idx2Node[i] = node;\n  }\n  // \n  if (nodeIds && include) {\n    for (let i = 0; i < nodeIds.length; i++) {\n      const nodeId = nodeIds[i];\n      node2Idx[nodes[i].id] = node2Idx[nodeId];\n      node2Idx[nodeId] = 0;\n      idx2Node[0] = nodes.find(node => node.id === nodeId);\n      idx2Node[node2Idx[nodes[i].id]] = nodes[i];\n    }\n  }\n\n  //   >= nodeOrder adjList\n  const getMinComponentAdj = (components: NodeConfig[][]) => {\n    let minCompIdx;\n    let minIdx = Infinity;\n\n    // Find least component and the lowest node\n    for (let i = 0; i < components.length; i += 1) {\n      const comp = components[i];\n      for (let j = 0; j < comp.length; j++) {\n        const nodeIdx = node2Idx[comp[j].id];\n        if (nodeIdx < minIdx) {\n          minIdx = nodeIdx;\n          minCompIdx = i;\n        }\n      }\n    }\n\n    const component = components[minCompIdx];\n    const adjList = [];\n    for (let i = 0; i < component.length; i += 1) {\n      const node = component[i];\n      adjList[node.id] = [];\n      for (const neighbor of getNeighbors(node.id, graphData.edges, 'target').filter((n) => component.map(c => c.id).indexOf(n) > -1)) {\n        //  () adjList\n        if (neighbor === node.id && !(include === false && nodeIds.indexOf(node.id) > -1)) {\n          allCycles.push({ [node.id]: node });\n        } else {\n          adjList[node.id].push(node2Idx[neighbor]);\n        }\n      }\n    }\n\n    return {\n      component,\n      adjList,\n      minIdx,\n    };\n  };\n\n  let nodeIdx = 0;\n  while (nodeIdx < nodes.length) {\n    const subgraphNodes = nodes.filter((n) => node2Idx[n.id] >= nodeIdx);\n    const sccs = detectStrongConnectComponents({ nodes: subgraphNodes, edges: graphData.edges }).filter(\n      (component) => component.length > 1,\n    );\n    if (sccs.length === 0) break;\n\n    const scc = getMinComponentAdj(sccs);\n    const { minIdx, adjList, component } = scc;\n    if (component.length > 1) {\n      component.forEach((node) => {\n        B[node.id] = new Set();\n      });\n      const startNode = idx2Node[minIdx];\n      // startNode \n      if (nodeIds && include && nodeIds.indexOf(startNode.id) === -1) return allCycles;\n      circuit(startNode, startNode, adjList);\n      nodeIdx = minIdx + 1;\n    } else {\n      break;\n    }\n  }\n  return allCycles;\n};\n\n/**\n * \n * @param graph\n * @param directed \n * @param nodeIds  ID \n * @param include \n * @return [{[key: string]: Node}] Objectkeyidvalue\n */\nexport const detectAllCycles = (\n  graphData: GraphData,\n  directed?: boolean,\n  nodeIds?: string[],\n  include = true,\n) => {\n  if (directed) return detectAllDirectedCycle(graphData, nodeIds, include);\n  return detectAllUndirectedCycle(graphData, nodeIds, include);\n};\n\nexport default detectDirectedCycle;\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","var toString = {}.toString;\nvar isType = function (value, type) { return toString.call(value) === '[object ' + type + ']'; };\nexport default isType;\n//# sourceMappingURL=is-type.js.map","import isType from './is-type';\nexport default (function (value) {\n    return Array.isArray ?\n        Array.isArray(value) :\n        isType(value, 'Array');\n});\n//# sourceMappingURL=is-array.js.map","import each from './each';\nimport isFunction from './is-function';\nvar keys = Object.keys ? function (obj) { return Object.keys(obj); } : function (obj) {\n    var result = [];\n    each(obj, function (value, key) {\n        if (!(isFunction(obj) && key === 'prototype')) {\n            result.push(key);\n        }\n    });\n    return result;\n};\nexport default keys;\n//# sourceMappingURL=keys.js.map","var arrPrototype = Array.prototype;\nvar splice = arrPrototype.splice;\nvar indexOf = arrPrototype.indexOf;\nvar pull = function (arr) {\n    var values = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        values[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < values.length; i++) {\n        var value = values[i];\n        var fromIndex = -1;\n        while ((fromIndex = indexOf.call(arr, value)) > -1) {\n            splice.call(arr, fromIndex, 1);\n        }\n    }\n    return arr;\n};\nexport default pull;\n//# sourceMappingURL=pull.js.map","import isArrayLike from './is-array-like';\nvar splice = Array.prototype.splice;\nvar pullAt = function pullAt(arr, indexes) {\n    if (!isArrayLike(arr)) {\n        return [];\n    }\n    var length = arr ? indexes.length : 0;\n    var last = length - 1;\n    while (length--) {\n        var previous = void 0;\n        var index = indexes[length];\n        if (length === last || index !== previous) {\n            previous = index;\n            splice.call(arr, index, 1);\n        }\n    }\n    return arr;\n};\nexport default pullAt;\n//# sourceMappingURL=pull-at.js.map","import isArray from './is-array';\nimport isFunction from './is-function';\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction groupBy(data, condition) {\n    if (!condition || !isArray(data)) {\n        return {};\n    }\n    var result = {};\n    //  \n    var predicate = isFunction(condition) ? condition : function (item) { return item[condition]; };\n    var key;\n    for (var i = 0; i < data.length; i++) {\n        var item = data[i];\n        key = predicate(item);\n        if (hasOwnProperty.call(result, key)) {\n            result[key].push(item);\n        }\n        else {\n            result[key] = [item];\n        }\n    }\n    return result;\n}\nexport default groupBy;\n//# sourceMappingURL=group-by.js.map","import isNumber from './is-number';\nvar isInteger = Number.isInteger ? Number.isInteger : function (num) {\n    return isNumber(num) && num % 1 === 0;\n};\nexport default isInteger;\n//# sourceMappingURL=is-integer.js.map","var DEGREE = 180 / Math.PI;\nvar toDegree = function (radian) {\n    return DEGREE * radian;\n};\nexport default toDegree;\n//# sourceMappingURL=to-degree.js.map","export default parseInt;\n//# sourceMappingURL=to-integer.js.map","var RADIAN = Math.PI / 180;\nvar toRadian = function (degree) {\n    return RADIAN * degree;\n};\nexport default toRadian;\n//# sourceMappingURL=to-radian.js.map","import each from './each';\nimport isFunction from './is-function';\n// @ts-ignore\nvar values = Object.values ? function (obj) { return Object.values(obj); } : function (obj) {\n    var result = [];\n    each(obj, function (value, key) {\n        if (!(isFunction(obj) && key === 'prototype')) {\n            result.push(value);\n        }\n    });\n    return result;\n};\nexport default values;\n//# sourceMappingURL=values.js.map","var objectProto = Object.prototype;\nvar isPrototype = function (value) {\n    var Ctor = value && value.constructor;\n    var proto = (typeof Ctor === 'function' && Ctor.prototype) || objectProto;\n    return value === proto;\n};\nexport default isPrototype;\n//# sourceMappingURL=is-prototype.js.map","import isArray from './is-array';\nvar clone = function (obj) {\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n    var rst;\n    if (isArray(obj)) {\n        rst = [];\n        for (var i = 0, l = obj.length; i < l; i++) {\n            if (typeof obj[i] === 'object' && obj[i] != null) {\n                rst[i] = clone(obj[i]);\n            }\n            else {\n                rst[i] = obj[i];\n            }\n        }\n    }\n    else {\n        rst = {};\n        for (var k in obj) {\n            if (typeof obj[k] === 'object' && obj[k] != null) {\n                rst[k] = clone(obj[k]);\n            }\n            else {\n                rst[k] = obj[k];\n            }\n        }\n    }\n    return rst;\n};\nexport default clone;\n//# sourceMappingURL=clone.js.map","import isNil from './is-nil';\nimport isArrayLike from './is-array-like';\nimport getType from './get-type';\nimport isPrototype from './is-prototype';\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction isEmpty(value) {\n    /**\n     * isEmpty(null) => true\n     * isEmpty() => true\n     * isEmpty(true) => true\n     * isEmpty(1) => true\n     * isEmpty([1, 2, 3]) => false\n     * isEmpty('abc') => false\n     * isEmpty({ a: 1 }) => false\n     */\n    if (isNil(value)) {\n        return true;\n    }\n    if (isArrayLike(value)) {\n        return !value.length;\n    }\n    var type = getType(value);\n    if (type === 'Map' || type === 'Set') {\n        return !value.size;\n    }\n    if (isPrototype(value)) {\n        return !Object.keys(value).length;\n    }\n    for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nexport default isEmpty;\n//# sourceMappingURL=is-empty.js.map","import each from './each';\nimport isPlainObject from './is-plain-object';\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport default (function (object, keys) {\n    if (object === null || !isPlainObject(object)) {\n        return {};\n    }\n    var result = {};\n    each(keys, function (key) {\n        if (hasOwnProperty.call(object, key)) {\n            result[key] = object[key];\n        }\n    });\n    return result;\n});\n//# sourceMappingURL=pick.js.map","/**\n * k-v \n */\nvar default_1 = /** @class */ (function () {\n    function default_1() {\n        this.map = {};\n    }\n    default_1.prototype.has = function (key) {\n        return this.map[key] !== undefined;\n    };\n    default_1.prototype.get = function (key, def) {\n        var v = this.map[key];\n        return v === undefined ? def : v;\n    };\n    default_1.prototype.set = function (key, value) {\n        this.map[key] = value;\n    };\n    default_1.prototype.clear = function () {\n        this.map = {};\n    };\n    default_1.prototype.delete = function (key) {\n        delete this.map[key];\n    };\n    default_1.prototype.size = function () {\n        return Object.keys(this.map).length;\n    };\n    return default_1;\n}());\nexport default default_1;\n//# sourceMappingURL=cache.js.map","import { isArray } from '@antv/util';\nimport { GraphData, NodeConfig, EdgeConfig } from './types';\nimport { getOutEdgesNodeId, getEdgesByNodeId } from './util';\n\nconst minVertex = (\n  D: { [key: string]: number },\n  nodes: NodeConfig[],\n  marks: { [key: string]: boolean },\n): NodeConfig => {\n  // \n  let minDis = Infinity;\n  let minNode;\n  for (let i = 0; i < nodes.length; i++) {\n    const nodeId = nodes[i].id;\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\n      minDis = D[nodeId];\n      minNode = nodes[i];\n    }\n  }\n  return minNode;\n};\n\nconst dijkstra = (\n  graphData: GraphData,\n  source: string,\n  directed?: boolean,\n  weightPropertyName?: string,\n) => {\n  const { nodes = [], edges = [] } = graphData;\n  const nodeIds = [];\n  const marks = {};\n  const D = {};\n  const prevs = {}; // key: , value: \n  nodes.forEach((node, i) => {\n    const id = node.id;\n    nodeIds.push(id);\n    D[id] = Infinity;\n    if (id === source) D[id] = 0;\n  });\n\n  const nodeNum = nodes.length;\n  for (let i = 0; i < nodeNum; i++) {\n    // Process the vertices\n    const minNode = minVertex(D, nodes, marks);\n    const minNodeId = minNode.id;\n    marks[minNodeId] = true;\n\n    if (D[minNodeId] === Infinity) continue; // Unreachable vertices cannot be the intermediate point\n\n    let relatedEdges: EdgeConfig[] = [];\n    if (directed) relatedEdges = getOutEdgesNodeId(minNodeId, edges);\n    else relatedEdges = getEdgesByNodeId(minNodeId, edges);\n\n    relatedEdges.forEach(edge => {\n      const edgeTarget = edge.target;\n      const edgeSource = edge.source;\n      const w = edgeTarget === minNodeId ? edgeSource : edgeTarget;\n      const weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;\n      if (D[w] > D[minNode.id] + weight) {\n        D[w] = D[minNode.id] + weight;\n        prevs[w] = [minNode.id];\n      } else if (D[w] === D[minNode.id] + weight) {\n        prevs[w].push(minNode.id);\n      }\n    });\n  }\n\n  prevs[source] = [source];\n  // \n  const allPaths = {};\n  for (const target in D) {\n    if (D[target] !== Infinity) {\n      findAllPaths(source, target, prevs, allPaths);\n    }\n  }\n\n  // \n  const path = {};\n  for (const target in allPaths) {\n    path[target] = allPaths[target][0];\n  }\n  return { length: D, path, allPaths };\n};\n\nexport default dijkstra;\n\nfunction findAllPaths(source, target, prevs, foundPaths) {\n  if (source === target) {\n    return [source];\n  }\n  if (foundPaths[target]) {\n    return foundPaths[target];\n  }\n  const paths = [];\n  for (let prev of prevs[target]) {\n    const prevPaths = findAllPaths(source, prev, prevs, foundPaths);\n    if (!prevPaths) return;\n    for (let prePath of prevPaths) {\n      if (isArray(prePath)) paths.push([...prePath, target]);\n      else paths.push([prePath, target]);\n    }\n  }\n  foundPaths[target] = paths;\n  return foundPaths[target];\n}\n","import dijkstra from './dijkstra';\nimport { GraphData } from './types';\nimport { getNeighbors } from './util';\n\nexport const findShortestPath = (\n  graphData: GraphData,\n  start: string,\n  end: string,\n  directed?: boolean,\n  weightPropertyName?: string\n) => {\n  const { length, path, allPaths } = dijkstra(\n    graphData,\n    start,\n    directed,\n    weightPropertyName\n  );\n  return { length: length[end], path: path[end], allPath: allPaths[end] };\n};\n\nexport const findAllPath = (\n  graphData: GraphData,\n  start: string,\n  end: string,\n  directed?: boolean\n) => {\n  if (start === end) return [[start]];\n\n  const { edges = [] } = graphData;\n\n  const visited = [start];\n  const isVisited = { [start]: true };\n  const stack: string[][] = []; // \n  const allPaths = [];\n  let neighbors = directed\n    ? getNeighbors(start, edges, 'target')\n    : getNeighbors(start, edges);\n  stack.push(neighbors);\n\n  while (visited.length > 0 && stack.length > 0) {\n    const children = stack[stack.length - 1];\n    if (children.length) {\n      const child = children.shift();\n      if (child) {\n        visited.push(child);\n        isVisited[child] = true;\n        neighbors = directed\n          ? getNeighbors(child, edges, 'target')\n          : getNeighbors(child, edges);\n        stack.push(neighbors.filter(neighbor => !isVisited[neighbor]));\n      }\n    } else {\n      const node = visited.pop();\n      isVisited[node] = false;\n      stack.pop();\n      continue;\n    }\n\n    if (visited[visited.length - 1] === end) {\n      const path = visited.map(node => node);\n      allPaths.push(path);\n\n      const node = visited.pop();\n      isVisited[node] = false;\n      stack.pop();\n    }\n  }\n\n  return allPaths;\n};\n","import getAdjMatrix from \"./adjacent-matrix\";\nimport { GraphData, Matrix } from \"./types\";\n\nconst floydWarshall = (graphData: GraphData, directed?: boolean) => {\n  const adjacentMatrix = getAdjMatrix(graphData, directed);\n\n  const dist: Matrix[] = [];\n  const size = adjacentMatrix.length;\n  for (let i = 0; i < size; i += 1) {\n    dist[i] = [];\n    for (let j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjacentMatrix[i][j] === 0 || !adjacentMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjacentMatrix[i][j];\n      }\n    }\n  }\n  // floyd\n  for (let k = 0; k < size; k += 1) {\n    for (let i = 0; i < size; i += 1) {\n      for (let j = 0; j < size; j += 1) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n  return dist;\n};\n\nexport default floydWarshall;\n","\nimport getAdjMatrix from './adjacent-matrix'\nimport { uniqueId } from './util';\nimport { GraphData, ClusterData } from './types';\n\n/**\n * \n * @param graphData \n * @param directed  false\n * @param weightPropertyName \n * @param maxIteration \n */\nconst labelPropagation = (\n  graphData: GraphData,\n  directed: boolean = false,\n  weightPropertyName: string = 'weight',\n  maxIteration: number = 1000\n): ClusterData => {\n  // the origin data\n  const { nodes = [], edges = [] } = graphData;\n\n  const clusters = {};\n  const nodeMap = {};\n  // init the clusters and nodeMap\n  nodes.forEach((node, i) => {\n    const cid: string = uniqueId();\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node,\n      idx: i\n    };\n  });\n\n  // the adjacent matrix of calNodes inside clusters\n  const adjMatrix = getAdjMatrix(graphData, directed);\n  // the sum of each row in adjacent matrix\n  const ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n  const neighbors = {};\n  adjMatrix.forEach((row, i) => {\n    let k = 0;\n    const iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach((entry, j) => {\n      if (!entry) return;\n      k += entry;\n      const jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n    });\n    ks.push(k);\n  });\n\n  let iter = 0;\n\n  while (iter < maxIteration) {\n    let changed = false;\n    nodes.forEach(node => {\n      const neighborClusters = {};\n      Object.keys(neighbors[node.id]).forEach(neighborId => {\n        const neighborWeight = neighbors[node.id][neighborId];\n        const neighborNode = nodeMap[neighborId].node;\n        const neighborClusterId = neighborNode.clusterId;\n        if (!neighborClusters[neighborClusterId]) neighborClusters[neighborClusterId] = 0;\n        neighborClusters[neighborClusterId] += neighborWeight;\n      });\n      // find the cluster with max weight\n      let maxWeight = -Infinity;\n      let bestClusterIds = [];\n      Object.keys(neighborClusters).forEach(clusterId => {\n        if (maxWeight < neighborClusters[clusterId]) {\n          maxWeight = neighborClusters[clusterId];\n          bestClusterIds = [clusterId];\n        } else if (maxWeight === neighborClusters[clusterId]) {\n          bestClusterIds.push(clusterId);\n        }\n      });\n      if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId) return;\n      const selfClusterIdx = bestClusterIds.indexOf(node.clusterId);\n      if (selfClusterIdx >= 0) bestClusterIds.splice(selfClusterIdx, 1);\n      if (bestClusterIds && bestClusterIds.length) {\n        changed = true;\n\n        // remove from origin cluster\n        const selfCluster = clusters[node.clusterId as string];\n        const nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);\n\n        // move the node to the best cluster\n        const randomIdx = Math.floor(Math.random() * bestClusterIds.length);\n        const bestCluster = clusters[bestClusterIds[randomIdx]];\n        bestCluster.nodes.push(node);\n        node.clusterId = bestCluster.id;\n      }\n    });\n    if (!changed) break;\n    iter++;\n  }\n\n  // delete the empty clusters\n  Object.keys(clusters).forEach(clusterId => {\n    const cluster = clusters[clusterId];\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n    }\n  });\n\n  // get the cluster edges\n  const clusterEdges = [];\n  const clusterEdgeMap = {};\n  edges.forEach(edge => {\n    const { source, target } = edge;\n    const weight = edge[weightPropertyName] || 1;\n    const sourceClusterId = nodeMap[source].node.clusterId;\n    const targetClusterId = nodeMap[target].node.clusterId;\n    const newEdgeId = `${sourceClusterId}---${targetClusterId}`;\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      const newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n\n  const clustersArray = [];\n  Object.keys(clusters).forEach(clusterId => {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges\n  }\n}\n\nexport default labelPropagation;\n","import getAdjMatrix from './adjacent-matrix'\nimport { uniqueId } from './util';\nimport { NodeConfig, ClusterData, GraphData } from './types';\n\nconst getModularity = (\n  nodes: NodeConfig[],\n  adjMatrix: number[][],\n  ks: number[],\n  m: number\n) => {\n  const length = adjMatrix.length;\n  const param = 2 * m;\n  let modularity = 0;\n  for (let i = 0; i < length; i++) {\n    const clusteri = nodes[i].clusterId;\n    for (let j = 0; j < length; j++) {\n      const clusterj = nodes[j].clusterId;\n      if (clusteri !== clusterj) continue;\n      const entry = adjMatrix[i][j] || 0;\n      const ki = ks[i] || 0;\n      const kj = ks[j] || 0;\n      modularity += (entry - ki * kj / param);\n    }\n  }\n  modularity *= (1 / param);\n  return modularity;\n}\n\n/**\n *  louvain \n * @param graphData \n * @param directed  false\n * @param weightPropertyName \n * @param threshold \n */\nconst louvain = (\n  graphData: GraphData,\n  directed: boolean = false,\n  weightPropertyName: string = 'weight',\n  threshold: number = 0.0001\n): ClusterData => {\n  // the origin data\n  const { nodes = [], edges = [] } = graphData;\n\n  const clusters = {};\n  const nodeMap = {};\n  // init the clusters and nodeMap\n  nodes.forEach((node, i) => {\n    const cid: string = uniqueId();\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node,\n      idx: i\n    };\n  });\n\n  // the adjacent matrix of calNodes inside clusters\n  const adjMatrix = getAdjMatrix(graphData, directed);\n  // the sum of each row in adjacent matrix\n  const ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n  const neighbors = {};\n  // the sum of the weights of all edges in the graph\n  let m = 0;\n  adjMatrix.forEach((row, i) => {\n    let k = 0;\n    const iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach((entry, j) => {\n      if (!entry) return;\n      k += entry;\n      const jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n      m += entry;\n    });\n    ks.push(k);\n  });\n\n  m /= 2;\n\n  let totalModularity = Infinity;\n  let previousModularity = Infinity;\n  let iter = 0;\n\n  while (true) {\n    // whether to terminate the iterations\n    totalModularity = getModularity(nodes, adjMatrix, ks, m);\n    if (Math.abs(totalModularity - previousModularity) < threshold || iter > 100) break;\n    previousModularity = totalModularity;\n    iter++;\n\n    // pre compute some values for current clusters\n    Object.keys(clusters).forEach(clusterId => {\n      // sum of weights of edges to nodes in cluster\n      let sumTot = 0;\n      edges.forEach(edge => {\n        const { source, target } = edge;\n        const sourceClusterId = nodeMap[source].node.clusterId;\n        const targetClusterId = nodeMap[target].node.clusterId;\n        if ((sourceClusterId === clusterId && targetClusterId !== clusterId)\n          || (targetClusterId === clusterId && sourceClusterId !== clusterId)) {\n          sumTot = sumTot + (edge[weightPropertyName] as number || 1);\n        }\n      });\n      clusters[clusterId].sumTot = sumTot;\n    });\n\n\n    // move the nodes to increase the delta modularity\n    nodes.forEach((node, i) => {\n      const selfCluster = clusters[node.clusterId as string];\n      let bestIncrease = 0;\n      let bestCluster;\n\n      const commonParam = ks[i] / (2 * m);\n\n      // sum of weights of edges from node to nodes in cluster\n      let kiin = 0;\n      const selfClusterNodes = selfCluster.nodes;\n      selfClusterNodes.forEach(scNode => {\n        const scNodeIdx = nodeMap[scNode.id].idx;\n        kiin += adjMatrix[i][scNodeIdx] || 0;\n      });\n      // the modurarity for **removing** the node i from the origin cluster of node i\n      const removeModurarity = kiin - selfCluster.sumTot * commonParam;\n\n      // the neightbors of the node\n      const nodeNeighborIds = neighbors[node.id];\n      Object.keys(nodeNeighborIds).forEach(neighborNodeId => {\n        const neighborNode = nodeMap[neighborNodeId].node\n        const neighborClusterId = neighborNode.clusterId;\n\n        // if the node and the neighbor of node are in the same cluster, reutrn\n        if (neighborClusterId === node.clusterId) return;\n        const neighborCluster = clusters[neighborClusterId];\n        const clusterNodes = neighborCluster.nodes;\n\n        // if the cluster is empty, remove the cluster and return\n        if (!clusterNodes || !clusterNodes.length) return;\n\n        // sum of weights of edges from node to nodes in cluster\n        let neighborClusterKiin = 0;\n        clusterNodes.forEach(cNode => {\n          const cNodeIdx = nodeMap[cNode.id].idx;\n          neighborClusterKiin += adjMatrix[i][cNodeIdx] || 0;\n        });\n\n        // modurarity for **adding** node i into this neighbor cluster\n        const addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam;\n\n        // the increase modurarity is the difference between addModurarity and removeModurarity\n        const increase = addModurarity - removeModurarity;\n\n        // find the best cluster to move node i into\n        if (increase > bestIncrease) {\n          bestIncrease = increase;\n          bestCluster = neighborCluster;\n        }\n      });\n\n      // if found a best cluster to move into\n      if (bestIncrease > 0) {\n        bestCluster.nodes.push(node);\n        const previousClusterId = node.clusterId;\n        node.clusterId = bestCluster.id;\n        // move the node to the best cluster\n        const nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        // remove from origin cluster\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);\n        // update sumTot for clusters\n        // sum of weights of edges to nodes in cluster\n        let neighborClusterSumTot = 0;\n        let selfClusterSumTot = 0;\n        edges.forEach(edge => {\n          const { source, target } = edge;\n          const sourceClusterId = nodeMap[source].node.clusterId;\n          const targetClusterId = nodeMap[target].node.clusterId;\n          if ((sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id)\n            || (targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id)) {\n            neighborClusterSumTot = neighborClusterSumTot + (edge[weightPropertyName] as number || 1);\n          }\n          if ((sourceClusterId === previousClusterId && targetClusterId !== previousClusterId)\n            || (targetClusterId === previousClusterId && sourceClusterId !== previousClusterId)) {\n            selfClusterSumTot = selfClusterSumTot + (edge[weightPropertyName] as number || 1);\n          }\n        });\n\n        // the nodes of the clusters to move into and remove are changed, update their sumTot\n        bestCluster.sumTot = neighborClusterSumTot;\n        selfCluster.sumTot = selfClusterSumTot;\n      }\n    });\n  }\n\n  // delete the empty clusters\n  Object.keys(clusters).forEach(clusterId => {\n    const cluster = clusters[clusterId];\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n    }\n  });\n\n  // get the cluster edges\n  const clusterEdges = [];\n  const clusterEdgeMap = {};\n  edges.forEach(edge => {\n    const { source, target } = edge;\n    const weight = edge[weightPropertyName] || 1;\n    const sourceClusterId = nodeMap[source].node.clusterId;\n    const targetClusterId = nodeMap[target].node.clusterId;\n    const newEdgeId = `${sourceClusterId}---${targetClusterId}`;\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      const newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n\n  const clustersArray = [];\n  Object.keys(clusters).forEach(clusterId => {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges\n  }\n}\n\nexport default louvain;\n","/**\n *  Disjoint set to support quick union\n */\nexport default class UnionFind {\n  count: number;\n\n  parent: {};\n\n  constructor(items: (number | string)[]) {\n    this.count = items.length;\n    this.parent = {};\n    for (const i of items) {\n      this.parent[i] = i;\n    }\n  }\n\n  // find the root of the item\n  find(item) {\n    while (this.parent[item] !== item) {\n      item = this.parent[item];\n    }\n    return item;\n  }\n\n  union(a, b) {\n    const rootA = this.find(a);\n    const rootB = this.find(b);\n\n    if (rootA === rootB) return;\n\n    // make the element with smaller root the parent\n    if (rootA < rootB) {\n      if (this.parent[b] !== b) this.union(this.parent[b], a);\n      this.parent[b] = this.parent[a];\n    } else {\n      if (this.parent[a] !== a) this.union(this.parent[a], b);\n      this.parent[a] = this.parent[b];\n    }\n  }\n\n  // whether a and b are connected, i.e. a and b have the same root\n  connected(a, b) {\n    return this.find(a) === this.find(b);\n  }\n}\n","const defaultCompare = (a, b) => {\n  return a - b;\n};\n\nexport default class MinBinaryHeap {\n  list: any[];\n\n  compareFn: (a: any, b: any) => number;\n\n  constructor(compareFn = defaultCompare) {\n    this.compareFn = compareFn;\n    this.list = [];\n  }\n\n  getLeft(index) {\n    return 2 * index + 1;\n  }\n\n  getRight(index) {\n    return 2 * index + 2;\n  }\n\n  getParent(index) {\n    if (index === 0) {\n      return null;\n    }\n    return Math.floor((index - 1) / 2);\n  }\n\n  isEmpty() {\n    return this.list.length <= 0;\n  }\n\n  top() {\n    return this.isEmpty() ? undefined : this.list[0];\n  }\n\n  delMin() {\n    const top = this.top();\n    const bottom = this.list.pop();\n    if (this.list.length > 0) {\n      this.list[0] = bottom;\n      this.moveDown(0);\n    }\n    return top;\n  }\n\n  insert(value) {\n    if (value !== null) {\n      this.list.push(value);\n      const index = this.list.length - 1;\n      this.moveUp(index);\n      return true;\n    }\n    return false;\n  }\n\n  moveUp(index) {\n    let parent = this.getParent(index);\n    while (index && index > 0 && this.compareFn(this.list[parent], this.list[index]) > 0) {\n      // swap\n      const tmp = this.list[parent];\n      this.list[parent] = this.list[index];\n      this.list[index] = tmp;\n      // [this.list[index], this.list[parent]] = [this.list[parent], this.list[index]]\n      index = parent;\n      parent = this.getParent(index);\n    }\n  }\n\n  moveDown(index) {\n    let element = index;\n    const left = this.getLeft(index);\n    const right = this.getRight(index);\n    const size = this.list.length;\n    if (left !== null && left < size && this.compareFn(this.list[element], this.list[left]) > 0) {\n      element = left;\n    } else if (\n      right !== null &&\n      right < size &&\n      this.compareFn(this.list[element], this.list[right]) > 0\n    ) {\n      element = right;\n    }\n    if (index !== element) {\n      [this.list[index], this.list[element]] = [this.list[element], this.list[index]];\n      this.moveDown(element);\n    }\n  }\n}\n","import UnionFind from './structs/union-find';\nimport MinBinaryHeap from './structs/binary-heap';\nimport { GraphData, EdgeConfig } from './types';\nimport { getEdgesByNodeId } from './util';\n\n/**\n * Prim algorithmuse priority queue O(E+V*logV), V: E: \n * refer: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n * @param graph\n * @param weight \n */\nconst primMST = (graphData: GraphData, weight?: string) => {\n  const selectedEdges = [];\n  const { nodes = [], edges = [] } = graphData;\n  if (nodes.length === 0) {\n    return selectedEdges;\n  }\n\n  // nodes[0]\n  const currNode = nodes[0];\n  const visited = new Set();\n  visited.add(currNode);\n\n  // \n  const compareWeight = (a: EdgeConfig, b: EdgeConfig) => {\n    if (weight) {\n      return a.weight - b.weight;\n    }\n    return 0;\n\n  };\n  const edgeQueue = new MinBinaryHeap(compareWeight);\n  getEdgesByNodeId(currNode.id, edges).forEach((edge) => {\n    edgeQueue.insert(edge);\n  });\n\n  while (!edgeQueue.isEmpty()) {\n    // \n    const currEdge: EdgeConfig = edgeQueue.delMin();\n    const source = currEdge.source;\n    const target = currEdge.target;\n    if (visited.has(source) && visited.has(target)) continue;\n    selectedEdges.push(currEdge);\n\n    if (!visited.has(source)) {\n      visited.add(source);\n      getEdgesByNodeId(source, edges).forEach((edge) => {\n        edgeQueue.insert(edge);\n      });\n    }\n    if (!visited.has(target)) {\n      visited.add(target);\n      getEdgesByNodeId(target, edges).forEach((edge) => {\n        edgeQueue.insert(edge);\n      });\n    }\n  }\n  return selectedEdges;\n};\n\n/**\n * Kruskal algorithm O(E*logE), E: \n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight \n * @return IEdge[] MST\n */\nconst kruskalMST = (graphData: GraphData, weight?: string): EdgeConfig[] => {\n  const selectedEdges = [];\n  const { nodes = [], edges = [] } = graphData\n  if (nodes.length === 0) {\n    return selectedEdges;\n  }\n\n  // weight\n  const weightEdges = edges.map((edge) => edge);\n  if (weight) {\n    weightEdges.sort((a, b) => {\n      return a.weight - b.weight;\n    });\n  }\n  const disjointSet = new UnionFind(nodes.map((n) => n.id));\n\n  // G\n  // \n  while (weightEdges.length > 0) {\n    const curEdge = weightEdges.shift();\n    const source = curEdge.source;\n    const target = curEdge.target;\n    if (!disjointSet.connected(source, target)) {\n      selectedEdges.push(curEdge);\n      disjointSet.union(source, target);\n    }\n  }\n  return selectedEdges;\n};\n\n/**\n * \n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight \n * @param algo 'prim' | 'kruskal' \n * @return EdgeConfig[] MST\n */\nconst minimumSpanningTree = (graphData: GraphData, weight?: string, algo?: string): EdgeConfig[] => {\n  const algos = {\n    prim: primMST,\n    kruskal: kruskalMST,\n  };\n  if (!algo) return kruskalMST(graphData, weight);\n\n  return algos[algo](graphData, weight);\n}\n\nexport default minimumSpanningTree\n","import { GraphData } from \"./types\";\nimport degree from './degree'\nimport { getNeighbors } from \"./util\";\n\n/**\n * PageRank https://en.wikipedia.org/wiki/PageRank\n * refer: https://github.com/anvaka/ngraph.pagerank\n * @param graph \n * @param epsilon  0.000001\n * @param linkProb dumping factor 0.85\n */\nconst pageRank = (graphData: GraphData, epsilon?: number, linkProb?: number): {\n  [key: string]: number;\n} => {\n  if (typeof epsilon !== 'number') epsilon = 0.000001;\n  if (typeof linkProb !== 'number') linkProb = 0.85;\n\n  let distance = 1;\n  let leakedRank = 0;\n  let maxIterations = 1000;\n\n  const { nodes = [], edges = [] } = graphData;\n  const nodesCount = nodes.length;\n  let currentRank;\n  const curRanks = {};\n  const prevRanks = {}\n\n  // Initialize pageranks \n  for (let j = 0; j < nodesCount; ++j) {\n    const node = nodes[j];\n    const nodeId = node.id;\n    curRanks[nodeId] = (1 / nodesCount)\n    prevRanks[nodeId] = (1 / nodesCount)\n  }\n\n  const nodeDegree = degree(graphData)\n  while (maxIterations > 0 && distance > epsilon) {\n    leakedRank = 0;\n    for (let j = 0; j < nodesCount; ++j) {\n      const node = nodes[j];\n      const nodeId = node.id;\n      currentRank = 0;\n      if (nodeDegree[node.id].inDegree === 0) {\n        curRanks[nodeId] = 0;\n      } else {\n        const neighbors = getNeighbors(nodeId, edges, 'source');\n        for (let i = 0; i < neighbors.length; ++i) {\n          const neighbor = neighbors[i];\n          const outDegree: number = nodeDegree[neighbor].outDegree;\n          if (outDegree > 0) currentRank += (prevRanks[neighbor] / outDegree);\n        }\n        curRanks[nodeId] = linkProb * currentRank;\n        leakedRank += curRanks[nodeId];\n      }\n    }\n\n    leakedRank = (1 - leakedRank) / nodesCount;\n    distance = 0;\n    for (let j = 0; j < nodesCount; ++j) {\n      const node = nodes[j];\n      const nodeId = node.id;\n      currentRank = curRanks[nodeId] + leakedRank;\n      distance += Math.abs(currentRank - prevRanks[nodeId]);\n      prevRanks[nodeId] = currentRank;\n    }\n    maxIterations -= 1\n  }\n\n  return prevRanks;\n}\n\nexport default pageRank\n","import { indexOf } from \"@antv/util\";\n\nexport const VACANT_EDGE_ID = -1;\nexport const VACANT_NODE_ID = -1;\nexport const VACANT_EDGE_LABEL = \"-1\";\nexport const VACANT_NODE_LABEL = \"-1\";\nexport const VACANT_GRAPH_ID = -1;\nexport const AUTO_EDGE_ID = \"-1\";\n\nexport class Edge {\n  public id: number;\n  public from: number;\n  public to: number;\n  public label: string;\n\n  constructor(\n    id = VACANT_EDGE_ID,\n    from = VACANT_NODE_ID,\n    to = VACANT_NODE_ID,\n    label = VACANT_EDGE_LABEL\n  ) {\n    this.id = id;\n    this.from = from;\n    this.to = to;\n    this.label = label;\n  }\n}\n\nexport class Node {\n  public id: number;\n  public from: number;\n  public to: number;\n  public label: string;\n  public edges: Edge[];\n  public edgeMap: {};\n\n  constructor(id = VACANT_NODE_ID, label = VACANT_NODE_LABEL) {\n    this.id = id;\n    this.label = label;\n    this.edges = [];\n    this.edgeMap = {};\n  }\n\n  addEdge(edge) {\n    this.edges.push(edge);\n    this.edgeMap[edge.id] = edge;\n  }\n}\n\nexport class Graph {\n  public id: number;\n  public from: number;\n  public to: number;\n  public label: string;\n  public edgeIdAutoIncrease: boolean;\n  public nodes: Node[];\n  public edges: Edge[];\n  public nodeMap: {};\n  public edgeMap: {};\n  public nodeLabelMap: {}; // key  labelvalue  id \n  public edgeLabelMap: {};\n  private counter: number; //  id\n  public directed: boolean;\n\n  constructor(\n    id = VACANT_NODE_ID,\n    edgeIdAutoIncrease = true,\n    directed = false\n  ) {\n    this.id = id;\n    this.edgeIdAutoIncrease = edgeIdAutoIncrease;\n    this.edges = [];\n    this.nodes = [];\n    this.nodeMap = {};\n    this.edgeMap = {};\n    this.nodeLabelMap = {};\n    this.edgeLabelMap = {};\n    this.counter = 0;\n    this.directed = directed;\n  }\n\n  getNodeNum() {\n    return this.nodes.length;\n  }\n\n  addNode(id: number, label: string) {\n    if (this.nodeMap[id]) return;\n    const node = new Node(id, label);\n    this.nodes.push(node);\n    this.nodeMap[id] = node;\n    if (!this.nodeLabelMap[label]) this.nodeLabelMap[label] = [];\n    this.nodeLabelMap[label].push(id);\n  }\n\n  addEdge(id: number, from: number, to: number, label: string) {\n    if (this.edgeIdAutoIncrease || id === undefined) id = this.counter++;\n    if (this.nodeMap[from] && this.nodeMap[to] && this.nodeMap[to].edgeMap[id])\n      return;\n    const edge = new Edge(id, from, to, label);\n    this.edges.push(edge);\n    this.edgeMap[id] = edge;\n\n    this.nodeMap[from].addEdge(edge);\n\n    if (!this.edgeLabelMap[label]) this.edgeLabelMap[label] = [];\n    this.edgeLabelMap[label].push(edge);\n\n    if (!this.directed) {\n      const rEdge = new Edge(id, to, from, label);\n      this.nodeMap[to].addEdge(rEdge);\n      this.edgeLabelMap[label].push(rEdge);\n    }\n  }\n}\n","import { GraphData } from \"../types\";\nimport { clone } from \"@antv/util\";\nimport {\n  Graph,\n  Edge,\n  VACANT_NODE_LABEL,\n  VACANT_GRAPH_ID,\n  Node,\n  VACANT_EDGE_LABEL,\n} from \"./struct\";\n\nexport interface EdgeMap {\n  [key: string]: {\n    // key  source-target\n    idx: number; //  graphData.edges \n    edge: any;\n  };\n}\n\nexport interface NodeMap {\n  [key: string]: {\n    // key  node.id\n    idx: number; // j graphData.nodes \n    node: any;\n    degree: number;\n  };\n}\n\ninterface PDFS {\n  graphId: number;\n  edge: any;\n  preNode: any;\n}\n\nclass DFSedge {\n  public fromNode: number;\n  public toNode: number;\n  public nodeEdgeNodeLabel: {\n    nodeLabel1: string;\n    edgeLabel: string;\n    nodeLabel2: string;\n  };\n\n  constructor(\n    fromNode: number,\n    toNode: number,\n    fromNodeLabel: string,\n    edgeLabel: string,\n    toNodeLabel: string\n  ) {\n    this.fromNode = fromNode;\n    this.toNode = toNode;\n    this.nodeEdgeNodeLabel = {\n      nodeLabel1: fromNodeLabel || VACANT_NODE_LABEL,\n      edgeLabel: edgeLabel || VACANT_EDGE_LABEL,\n      nodeLabel2: toNodeLabel || VACANT_NODE_LABEL,\n    };\n  }\n\n  equalTo(other) {\n    return (\n      this.fromNode === other.formNode &&\n      this.toNode === other.toNode &&\n      this.nodeEdgeNodeLabel === other.nodeEdgeNodeLabel\n    );\n  }\n\n  notEqualTo(other) {\n    return !this.equalTo(other);\n  }\n}\n\n// DFScode  DESedge \nclass DFScode {\n  public dfsEdgeList: DFSedge[];\n  public rmpath: any;\n\n  constructor() {\n    this.rmpath = [];\n    this.dfsEdgeList = [];\n  }\n\n  equalTo(other) {\n    const aLength = this.dfsEdgeList.length;\n    const bLength = other.length;\n    if (aLength !== bLength) return false;\n    for (let i = 0; i < aLength; i++) {\n      if (this.dfsEdgeList[i] !== other[i]) return false;\n    }\n    return true;\n  }\n\n  notEqualTo(other) {\n    return !this.equalTo(other);\n  }\n\n  /**  edge  DFScode */\n  pushBack(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {\n    this.dfsEdgeList.push(\n      new DFSedge(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel)\n    );\n    return this.dfsEdgeList;\n  }\n\n  /**  dfs  */\n  toGraph(graphId: number = VACANT_GRAPH_ID, directed = false) {\n    const graph = new Graph(graphId, true, directed);\n    this.dfsEdgeList.forEach((dfsEdge) => {\n      const fromNodeId = dfsEdge.fromNode;\n      const toNodeId = dfsEdge.toNode;\n      const { nodeLabel1, edgeLabel, nodeLabel2 } = dfsEdge.nodeEdgeNodeLabel;\n\n      if (nodeLabel1 !== VACANT_NODE_LABEL)\n        graph.addNode(fromNodeId, nodeLabel1);\n      if (nodeLabel2 !== VACANT_NODE_LABEL) graph.addNode(toNodeId, nodeLabel2);\n\n      graph.addEdge(undefined, fromNodeId, toNodeId, edgeLabel);\n    });\n    return graph;\n  }\n\n  //  rightmost path\n  buildRmpath() {\n    this.rmpath = [];\n    let oldFrom = undefined;\n    const selfLength = this.dfsEdgeList.length;\n    for (let i = selfLength - 1; i >= 0; i--) {\n      const dfsEdge = this.dfsEdgeList[i];\n      const fromNodeIdx = dfsEdge.fromNode;\n      const toNodeIdx = dfsEdge.toNode;\n      if (\n        fromNodeIdx < toNodeIdx &&\n        (oldFrom === undefined || toNodeIdx === oldFrom)\n      ) {\n        this.rmpath.push(i);\n        oldFrom = fromNodeIdx;\n      }\n    }\n    return this.rmpath;\n  }\n\n  getNodeNum() {\n    const nodeMap = {};\n    this.dfsEdgeList.forEach((dfsEdge) => {\n      if (!nodeMap[dfsEdge.fromNode]) nodeMap[dfsEdge.fromNode] = true;\n      if (!nodeMap[dfsEdge.toNode]) nodeMap[dfsEdge.toNode] = true;\n    });\n    return Object.keys(nodeMap).length;\n  }\n}\n\nclass History {\n  public his: object;\n  public edges: Edge[];\n  public nodesUsed: object;\n  public edgesUsed: object;\n\n  constructor(pdfs: PDFS) {\n    this.his = {};\n    this.nodesUsed = {};\n    this.edgesUsed = {};\n    this.edges = [];\n    if (!pdfs) return;\n    while (pdfs) {\n      const e = pdfs.edge;\n      this.edges.push(e);\n      this.nodesUsed[e.from] = 1;\n      this.nodesUsed[e.to] = 1;\n      this.edgesUsed[e.id] = 1;\n      pdfs = pdfs.preNode;\n    }\n    // \n    this.edges = this.edges.reverse();\n  }\n\n  hasNode(node: Node) {\n    return this.nodesUsed[node.id] === 1;\n  }\n\n  hasEdge(edge: Edge) {\n    return this.edgesUsed[edge.id] === 1;\n  }\n}\n\ninterface Root {\n  [key: string]: {\n    projected: PDFS[];\n    nodeLabel1?: string;\n    edgeLabel?: string;\n    nodeLabel2?: string;\n    fromNodeId?: number;\n    toNodeId?: number;\n  };\n}\n\ninterface GraphDataMap {\n  [key: string]: GraphData;\n}\ninterface GraphMap {\n  [key: number]: Graph;\n}\n\ninterface AlgorithmProps {\n  graphs: GraphMap; // \n  minSupport: number; //  graphs \n  directed?: boolean; //  false\n  minNodeNum?: number; //  1\n  maxNodeNum?: number; //  4\n  top?: number; //  top  10\n  verbose?: boolean;\n}\n\nclass GSpan {\n  public graphs: GraphMap;\n  public dfsCode: DFScode;\n  public support: number;\n  public frequentSize1Subgraphs: GraphData[];\n  public frequentSubgraphs: Graph[];\n  public reportDF: [];\n  public maxNodeNum: number;\n  public minNodeNum: number;\n  public minSupport: number;\n  public top: number;\n  public directed: boolean;\n  private counter: number; //  id\n  public verbose: boolean;\n\n  constructor({\n    graphs,\n    minSupport = 2,\n    minNodeNum = 1,\n    maxNodeNum = 4,\n    top = 10,\n    directed = false,\n    verbose = false,\n  }: AlgorithmProps) {\n    // -------- -------\n    this.graphs = graphs;\n    this.dfsCode = new DFScode();\n    this.support = 0;\n    this.frequentSize1Subgraphs = [];\n    this.frequentSubgraphs = [];\n    this.minSupport = minSupport;\n    this.top = top;\n    this.directed = directed;\n    this.counter = 0;\n    // TODO? timestamp = {}\n    this.maxNodeNum = maxNodeNum;\n    this.minNodeNum = minNodeNum;\n    this.verbose = verbose;\n    if (this.maxNodeNum < this.minNodeNum) this.maxNodeNum = this.minNodeNum;\n    this.reportDF = []; // matrix\n  }\n\n  // Line 352\n  findForwardRootEdges(graph: Graph, fromNode: Node): Edge[] {\n    const result = [];\n    const nodeMap = graph.nodeMap;\n    fromNode.edges.forEach((edge) => {\n      if (this.directed || fromNode.label <= nodeMap[edge.to].label)\n        result.push(edge);\n    });\n\n    return result;\n  }\n\n  findBackwardEdge(\n    graph: Graph,\n    edge1: Edge,\n    edge2: Edge,\n    history: History\n  ): Edge {\n    if (!this.directed && edge1 === edge2) return null;\n    const nodeMap = graph.nodeMap;\n    const edge2To = nodeMap[edge2.to];\n    const edge2ToEdges = edge2To.edges;\n    const edgeLength = edge2ToEdges.length;\n    for (let i = 0; i < edgeLength; i++) {\n      const edge = edge2ToEdges[i];\n      if (history.hasEdge(edge) || edge.to !== edge1.from) continue;\n      if (!this.directed) {\n        if (\n          edge1.label < edge.label ||\n          (edge1.label === edge.label &&\n            nodeMap[edge1.to].label <= nodeMap[edge2.to].label)\n        ) {\n          return edge;\n        }\n      } else {\n        if (\n          nodeMap[edge1.from].label < nodeMap[edge2.to].label ||\n          (nodeMap[edge1.from].label === nodeMap[edge2.to].label &&\n            edge1.label <= edge.label)\n        ) {\n          return edge;\n        }\n      }\n    }\n    return null;\n  }\n\n  findForwardPureEdges(\n    graph,\n    rightmostEdge,\n    minNodeLabel,\n    history: History\n  ): Edge[] {\n    const result = [];\n    const rightmostEdgeToId = rightmostEdge.to;\n    const edges = graph.nodeMap[rightmostEdgeToId].edges;\n    const edgeLength = edges.length;\n    for (let i = 0; i < edgeLength; i++) {\n      const edge = edges[i];\n      const toNode = graph.nodeMap[edge.to];\n      if (minNodeLabel <= toNode.label && !history.hasNode(toNode)) {\n        result.push(edge);\n      }\n    }\n    return result;\n  }\n\n  findForwardRmpathEdges(\n    graph: Graph,\n    rightmostEdge: Edge,\n    minNodeLabel: string,\n    history: History\n  ): Edge[] {\n    const result = [];\n    const nodeMap = graph.nodeMap;\n    const toNodeLabel = nodeMap[rightmostEdge.to].label;\n    const fromNode = nodeMap[rightmostEdge.from];\n    const edges = fromNode.edges;\n    const edgeLength = edges.length;\n    for (let i = 0; i < edgeLength; i++) {\n      const edge = edges[i];\n      const newToNodeLabel = nodeMap[edge.to].label;\n      if (\n        rightmostEdge.to === edge.to ||\n        minNodeLabel > newToNodeLabel ||\n        history.hasNode(nodeMap[edge.to])\n      ) {\n        continue;\n      }\n      if (\n        rightmostEdge.label < edge.label ||\n        (rightmostEdge.label === edge.label && toNodeLabel <= newToNodeLabel)\n      ) {\n        result.push(edge);\n      }\n    }\n    return result;\n  }\n\n  getSupport(projected: PDFS[]): number {\n    const graphMap = {};\n    projected.forEach((pro) => {\n      if (!graphMap[pro.graphId]) graphMap[pro.graphId] = true;\n    });\n    return Object.keys(graphMap).length;\n  }\n\n  findMinLabel(\n    obj: Root\n  ): {\n    nodeLabel1?: string;\n    edgeLabel: string;\n    nodeLabel2?: string;\n  } {\n    let minLabel = undefined;\n    Object.keys(obj).forEach((nodeEdgeNodeLabel) => {\n      const { nodeLabel1, edgeLabel, nodeLabel2 } = obj[nodeEdgeNodeLabel];\n      if (!minLabel) {\n        minLabel = {\n          nodeLabel1,\n          edgeLabel,\n          nodeLabel2,\n        };\n        return;\n      }\n      if (\n        nodeLabel1 < minLabel.nodeLabel1 ||\n        (nodeLabel1 === minLabel.nodeLabel1 &&\n          edgeLabel < minLabel.edgeLabel) ||\n        (nodeLabel1 === minLabel.nodeLabel1 &&\n          edgeLabel === minLabel.edgeLabel &&\n          nodeLabel2 < minLabel.nodeLabel2)\n      ) {\n        minLabel = {\n          nodeLabel1,\n          edgeLabel,\n          nodeLabel2,\n        };\n      }\n    });\n    return minLabel;\n  }\n\n  isMin() {\n    const dfsCode = this.dfsCode;\n    if (this.verbose) console.log(\"isMin checking\", dfsCode);\n    if (dfsCode.dfsEdgeList.length === 1) return true;\n    const directed = this.directed;\n    const graph = dfsCode.toGraph(VACANT_GRAPH_ID, directed);\n    const nodeMap = graph.nodeMap;\n    const dfsCodeMin = new DFScode();\n    const root: Root = {};\n    graph.nodes.forEach((node) => {\n      const forwardEdges = this.findForwardRootEdges(graph, node);\n      forwardEdges.forEach((edge) => {\n        let otherNode = nodeMap[edge.to];\n        const nodeEdgeNodeLabel = `${node.label}-${edge.label}-${otherNode.label}`;\n        if (!root[nodeEdgeNodeLabel])\n          root[nodeEdgeNodeLabel] = {\n            projected: [],\n            nodeLabel1: node.label,\n            edgeLabel: edge.label,\n            nodeLabel2: otherNode.label,\n          };\n        const pdfs: PDFS = {\n          graphId: graph.id,\n          edge,\n          preNode: null,\n        };\n        root[nodeEdgeNodeLabel].projected.push(pdfs);\n      });\n    });\n\n    //  root  nodeEdgeNodeLabel  nodeLabel1edgeLabenodeLabel2 \n    let minLabel = this.findMinLabel(root); // line 419\n    dfsCodeMin.dfsEdgeList.push(\n      new DFSedge(\n        0,\n        1,\n        minLabel.nodeLabel1,\n        minLabel.edgeLabel,\n        minLabel.nodeLabel2\n      )\n    );\n\n    // line 423\n    const projectIsMin = (projected: PDFS[]) => {\n      // right most path\n      const rmpath = dfsCodeMin.buildRmpath();\n      const minNodeLabel =\n        dfsCodeMin.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;\n      const maxToC = dfsCodeMin.dfsEdgeList[rmpath[0]].toNode; // node id\n\n      const backwardRoot: Root = {};\n      let flag = false,\n        newTo = 0;\n      let end = directed ? -1 : 0; //  1  0\n      for (let i = rmpath.length - 1; i > end; i--) {\n        if (flag) break;\n        // line 435\n        projected.forEach((p) => {\n          const history = new History(p);\n          const backwardEdge = this.findBackwardEdge(\n            graph,\n            history.edges[rmpath[i]],\n            history.edges[rmpath[0]],\n            history\n          );\n          if (backwardEdge) {\n            // Line 441\n            if (!backwardRoot[backwardEdge.label]) {\n              backwardRoot[backwardEdge.label] = {\n                projected: [],\n                edgeLabel: backwardEdge.label,\n              };\n            }\n            backwardRoot[backwardEdge.label].projected.push({\n              graphId: graph.id,\n              edge: backwardRoot,\n              preNode: p,\n            });\n            newTo = dfsCodeMin.dfsEdgeList[rmpath[i]].fromNode;\n            flag = true;\n          }\n        });\n      }\n\n      if (flag) {\n        const minBackwardEdgeLabel = this.findMinLabel(backwardRoot);\n        dfsCodeMin.dfsEdgeList.push(\n          new DFSedge(\n            maxToC,\n            newTo,\n            VACANT_NODE_LABEL,\n            minBackwardEdgeLabel.edgeLabel,\n            VACANT_NODE_LABEL\n          )\n        );\n        const idx = dfsCodeMin.dfsEdgeList.length - 1;\n        if (this.dfsCode.dfsEdgeList[idx] !== dfsCodeMin.dfsEdgeList[idx])\n          return false;\n        return projectIsMin(\n          backwardRoot[minBackwardEdgeLabel.edgeLabel].projected\n        );\n      }\n      const forwardRoot: Root = {};\n      flag = false;\n      let newFrom = 0;\n      projected.forEach((p) => {\n        const history = new History(p);\n        const forwardPureEdges = this.findForwardPureEdges(\n          graph,\n          history.edges[rmpath[0]],\n          minNodeLabel,\n          history\n        );\n        if (forwardPureEdges.length > 0) {\n          flag = true;\n          newFrom = maxToC;\n          forwardPureEdges.forEach((edge) => {\n            const key = `${edge.label}-${nodeMap[edge.to].label}`;\n            if (!forwardRoot[key])\n              forwardRoot[key] = {\n                projected: [],\n                edgeLabel: edge.label,\n                nodeLabel2: nodeMap[edge.to].label,\n              };\n            forwardRoot[key].projected.push({\n              graphId: graph.id,\n              edge,\n              preNode: p,\n            });\n          });\n        }\n      });\n\n      const pathLength = rmpath.length;\n      for (let i = 0; i < pathLength; i++) {\n        if (flag) break;\n        const value = rmpath[i];\n        projected.forEach((p) => {\n          const history = new History(p);\n          const forwardRmpathEdges = this.findForwardRmpathEdges(\n            graph,\n            history.edges[value],\n            minNodeLabel,\n            history\n          );\n          if (forwardRmpathEdges.length > 0) {\n            flag = true;\n            newFrom = dfsCodeMin.dfsEdgeList[value].fromNode;\n            forwardRmpathEdges.forEach((edge) => {\n              const key = `${edge.label}-${nodeMap[edge.to].label}`;\n              if (!forwardRoot[key])\n                forwardRoot[key] = {\n                  projected: [],\n                  edgeLabel: edge.label,\n                  nodeLabel2: nodeMap[edge.to].label,\n                };\n              forwardRoot[key].projected.push({\n                graphId: graph.id,\n                edge,\n                preNode: p,\n              });\n            });\n          }\n        });\n      }\n\n      if (!flag) return true;\n\n      const forwardMinEdgeNodeLabel = this.findMinLabel(forwardRoot);\n      dfsCodeMin.dfsEdgeList.push(\n        new DFSedge(\n          newFrom,\n          maxToC + 1,\n          VACANT_NODE_LABEL,\n          forwardMinEdgeNodeLabel.edgeLabel,\n          forwardMinEdgeNodeLabel.nodeLabel2\n        )\n      );\n      const idx = dfsCodeMin.dfsEdgeList.length - 1;\n      if (dfsCode.dfsEdgeList[idx] !== dfsCodeMin.dfsEdgeList[idx])\n        return false;\n      return projectIsMin(\n        forwardRoot[\n          `${forwardMinEdgeNodeLabel.edgeLabel}-${forwardMinEdgeNodeLabel.nodeLabel2}`\n        ].projected\n      );\n    };\n    const key = `${minLabel.nodeLabel1}-${minLabel.edgeLabel}-${minLabel.nodeLabel2}`;\n    return projectIsMin(root[key].projected);\n  }\n\n  report() {\n    if (this.dfsCode.getNodeNum() < this.minNodeNum) return;\n    this.counter++;\n    const graph = this.dfsCode.toGraph(this.counter, this.directed);\n    this.frequentSubgraphs.push(clone(graph));\n  }\n\n  subGraphMining(projected) {\n    const support = this.getSupport(projected);\n    if (support < this.minSupport) return;\n    if (!this.isMin()) return;\n    this.report();\n\n    const nodeNum = this.dfsCode.getNodeNum();\n    const rmpath = this.dfsCode.buildRmpath();\n    const maxToC = this.dfsCode.dfsEdgeList[rmpath[0]].toNode;\n    const minNodeLabel = this.dfsCode.dfsEdgeList[0].nodeEdgeNodeLabel\n      .nodeLabel1;\n\n    const forwardRoot: Root = {};\n    const backwardRoot: Root = {};\n\n    projected.forEach((p) => {\n      const graph = this.graphs[p.graphId];\n      const nodeMap = graph.nodeMap;\n      const history = new History(p);\n      // backward Line 526\n      for (let i = rmpath.length - 1; i >= 0; i--) {\n        const backwardEdge = this.findBackwardEdge(\n          graph,\n          history.edges[rmpath[i]],\n          history.edges[rmpath[0]],\n          history\n        );\n        if (backwardEdge) {\n          const key = `${this.dfsCode.dfsEdgeList[rmpath[i]].fromNode}-${\n            backwardEdge.label\n          }`;\n          if (!backwardRoot[key])\n            backwardRoot[key] = {\n              projected: [],\n              toNodeId: this.dfsCode.dfsEdgeList[rmpath[i]].fromNode,\n              edgeLabel: backwardEdge.label,\n            };\n          backwardRoot[key].projected.push({\n            graphId: p.graphId,\n            edge: backwardEdge,\n            preNode: p,\n          });\n        }\n      }\n\n      // pure forward\n      if (nodeNum >= this.maxNodeNum) return;\n      const forwardPureEdges = this.findForwardPureEdges(\n        graph,\n        history.edges[rmpath[0]],\n        minNodeLabel,\n        history\n      );\n      forwardPureEdges.forEach((edge) => {\n        const key = `${maxToC}-${edge.label}-${nodeMap[edge.to].label}`;\n        if (!forwardRoot[key])\n          forwardRoot[key] = {\n            projected: [],\n            fromNodeId: maxToC,\n            edgeLabel: edge.label,\n            nodeLabel2: nodeMap[edge.to].label,\n          };\n        forwardRoot[key].projected.push({\n          graphId: p.graphId,\n          edge,\n          preNode: p,\n        });\n      });\n\n      // rmpath forward\n      for (let i = 0; i < rmpath.length; i++) {\n        const forwardRmpathEdges = this.findForwardRmpathEdges(\n          graph,\n          history.edges[rmpath[i]],\n          minNodeLabel,\n          history\n        );\n        forwardRmpathEdges.forEach((edge) => {\n          const key = `${this.dfsCode.dfsEdgeList[rmpath[i]].fromNode}-${\n            edge.label\n          }-${nodeMap[edge.to].label}`;\n          if (!forwardRoot[key])\n            forwardRoot[key] = {\n              projected: [],\n              fromNodeId: this.dfsCode.dfsEdgeList[rmpath[i]].fromNode,\n              edgeLabel: edge.label,\n              nodeLabel2: nodeMap[edge.to].label,\n            };\n          forwardRoot[key].projected.push({\n            graphId: p.graphId,\n            edge,\n            preNode: p,\n          });\n        });\n      }\n    });\n\n    // backward\n    Object.keys(backwardRoot).forEach((key) => {\n      const { toNodeId, edgeLabel } = backwardRoot[key];\n      this.dfsCode.dfsEdgeList.push(\n        new DFSedge(maxToC, toNodeId, \"-1\", edgeLabel, \"-1\")\n      );\n      this.subGraphMining(backwardRoot[key].projected);\n      this.dfsCode.dfsEdgeList.pop();\n    });\n\n    // forward\n    Object.keys(forwardRoot).forEach((key) => {\n      const { fromNodeId, edgeLabel, nodeLabel2 } = forwardRoot[key];\n      this.dfsCode.dfsEdgeList.push(\n        new DFSedge(\n          fromNodeId,\n          maxToC + 1,\n          VACANT_NODE_LABEL,\n          edgeLabel,\n          nodeLabel2\n        )\n      );\n      this.subGraphMining(forwardRoot[key].projected);\n      this.dfsCode.dfsEdgeList.pop();\n    });\n  }\n\n  generate1EdgeFrequentSubGraphs() {\n    const graphs = this.graphs;\n    const directed = this.directed;\n    const minSupport = this.minSupport;\n    const frequentSize1Subgraphs = this.frequentSize1Subgraphs;\n    let nodeLabelCounter = {},\n      nodeEdgeNodeCounter = {};\n    //  mapkey  graphKey-node\n    const nodeLableCounted = {};\n    //  mapkey  graphKey-fromNode-edge-toNode\n    const nodeEdgeNodeLabelCounted = {};\n    Object.keys(graphs).forEach((key) => {\n      // Line 271\n      const graph = graphs[key];\n      const nodeMap = graph.nodeMap;\n      //    label  nodeLableCounted\n      graph.nodes.forEach((node, i) => {\n        // Line 272\n        const nodeLabel = node.label;\n        const graphNodeKey = `${key}-${nodeLabel}`;\n        if (!nodeLableCounted[graphNodeKey]) {\n          let counter = nodeLabelCounter[nodeLabel] || 0;\n          counter++;\n          nodeLabelCounter[nodeLabel] = counter;\n        }\n        nodeLableCounted[graphNodeKey] = {\n          graphKey: key,\n          label: nodeLabel,\n        };\n        //  nodeEdgeNodeLabelCounted. Line 276\n        node.edges.forEach((edge) => {\n          let nodeLabel1 = nodeLabel;\n          let nodeLabel2 = nodeMap[edge.to].label;\n          if (!directed && nodeLabel1 > nodeLabel2) {\n            const tmp = nodeLabel2;\n            nodeLabel2 = nodeLabel1;\n            nodeLabel1 = tmp;\n          }\n          const edgeLabel = edge.label;\n\n          const graphNodeEdgeNodeKey = `${key}-${nodeLabel1}-${edgeLabel}-${nodeLabel2}`;\n          const nodeEdgeNodeKey = `${nodeLabel1}-${edgeLabel}-${nodeLabel2}`;\n\n          if (!nodeEdgeNodeCounter[nodeEdgeNodeKey]) {\n            let counter = nodeEdgeNodeCounter[nodeEdgeNodeKey] || 0;\n            counter++;\n            nodeEdgeNodeCounter[nodeEdgeNodeKey] = counter; // Line281\n          }\n          nodeEdgeNodeLabelCounted[graphNodeEdgeNodeKey] = {\n            graphId: key,\n            nodeLabel1,\n            edgeLabel,\n            nodeLabel2,\n          };\n        });\n      });\n    });\n\n    // \n    Object.keys(nodeLabelCounter).forEach((label) => {\n      const count = nodeLabelCounter[label];\n      if (count < minSupport) return;\n      const g = { nodes: [], edges: [] };\n      g.nodes.push({\n        id: \"0\",\n        label,\n      });\n      frequentSize1Subgraphs.push(g);\n      // if (minNodeNum <= 1) reportSize1 TODO\n    });\n\n    return frequentSize1Subgraphs;\n  }\n\n  run() {\n    // -------- , _generate_1edge_frequent_subgraphs-------\n    this.frequentSize1Subgraphs = this.generate1EdgeFrequentSubGraphs();\n\n    if (this.maxNodeNum < 2) return;\n\n    const graphs = this.graphs;\n    const directed = this.directed;\n\n    // PDFS  map Line 304\n    const root: Root = {};\n    Object.keys(graphs).forEach((graphId: any) => {\n      const graph = graphs[graphId];\n      const nodeMap = graph.nodeMap;\n      // Line 306\n      graph.nodes.forEach((node) => {\n        const forwardRootEdges = this.findForwardRootEdges(graph, node);\n        // Line 308\n        forwardRootEdges.forEach((edge) => {\n          let toNode = nodeMap[edge.to];\n          const nodeEdgeNodeLabel = `${node.label}-${edge.label}-${toNode.label}`;\n          if (!root[nodeEdgeNodeLabel])\n            root[nodeEdgeNodeLabel] = {\n              projected: [],\n              nodeLabel1: node.label as string,\n              edgeLabel: edge.label as string,\n              nodeLabel2: toNode.label as string,\n            };\n          const pdfs: PDFS = {\n            graphId,\n            edge,\n            preNode: null,\n          };\n          root[nodeEdgeNodeLabel].projected.push(pdfs);\n        });\n      });\n    });\n\n    // Line 313\n    Object.keys(root).forEach((nodeEdgeNodeLabel) => {\n      const { projected, nodeLabel1, edgeLabel, nodeLabel2 } = root[\n        nodeEdgeNodeLabel\n      ];\n\n      this.dfsCode.dfsEdgeList.push(\n        new DFSedge(0, 1, nodeLabel1, edgeLabel, nodeLabel2)\n      );\n      this.subGraphMining(projected);\n      this.dfsCode.dfsEdgeList.pop();\n    });\n  }\n}\n\nconst formatGraphs = (\n  graphs: GraphDataMap,\n  directed: boolean,\n  nodeLabelProp: string,\n  edgeLabelProp: string\n): GraphMap => {\n  const result: { [key: number]: Graph } = {};\n  Object.keys(graphs).forEach((key, i) => {\n    const graph = graphs[key];\n    const fGraph = new Graph(i, true, directed);\n    const nodeIdxMap = {};\n    graph.nodes.forEach((node, j) => {\n      fGraph.addNode(j, node[nodeLabelProp]);\n      nodeIdxMap[node.id] = j;\n    });\n    graph.edges.forEach((edge, k) => {\n      const sourceIdx = nodeIdxMap[edge.source];\n      const targetIdx = nodeIdxMap[edge.target];\n      fGraph.addEdge(-1, sourceIdx, targetIdx, edge[edgeLabelProp]);\n    });\n    if (fGraph && fGraph.getNodeNum()) result[fGraph.id] = fGraph;\n  });\n  return result;\n};\n\nconst toGraphDatas = (\n  graphs: Graph[],\n  nodeLabelProp: string,\n  edgeLabelProp: string\n) => {\n  const result = [];\n  graphs.forEach((graph) => {\n    const graphData = { nodes: [], edges: [] };\n    graph.nodes.forEach((node) => {\n      graphData.nodes.push({\n        id: `${node.id}`,\n        [nodeLabelProp]: node.label,\n      });\n    });\n    graph.edges.forEach((edge) => {\n      graphData.edges.push({\n        source: `${edge.from}`,\n        target: `${edge.to}`,\n        [edgeLabelProp]: edge.label,\n      });\n    });\n    result.push(graphData);\n  });\n  return result;\n};\n\ninterface Props {\n  graphs: GraphDataMap; // \n  minSupport: number; //  graphs \n  directed?: boolean; //  false\n  nodeLabelProp?: string; // \n  edgeLabelProp?: string; // \n  minNodeNum?: number; //  1\n  maxNodeNum?: number; //  4\n  top?: number; //  top  10\n  verbose?: boolean;\n}\n\nconst DEFAULT_LABEL_NAME = \"cluster\";\n\n/**\n * gSpan frequent graph mining\n * @param params \n */\nconst gSpan = (params: Props): GraphData[] => {\n  // -------  GraphData  map  -------\n  const {\n    graphs,\n    directed = false,\n    nodeLabelProp = DEFAULT_LABEL_NAME,\n    edgeLabelProp = DEFAULT_LABEL_NAME,\n  } = params;\n  const formattedGraphs = formatGraphs(\n    graphs,\n    directed,\n    nodeLabelProp,\n    edgeLabelProp\n  );\n  const { minSupport, maxNodeNum, minNodeNum, verbose, top } = params;\n\n  // -------  -------\n  const algoParams = {\n    graphs: formattedGraphs,\n    minSupport,\n    maxNodeNum,\n    minNodeNum,\n    top,\n    verbose,\n    directed,\n  };\n  const calculator = new GSpan(algoParams);\n  calculator.run();\n\n  const result = toGraphDatas(\n    calculator.frequentSubgraphs,\n    nodeLabelProp,\n    edgeLabelProp\n  );\n  return result;\n};\n\nexport default gSpan;\n","import floydWarshall from './floydWarshall';\nimport { GraphData, Matrix } from './types';\nimport gSpan, { EdgeMap, NodeMap } from './gSpan/gSpan';\nimport dijkstra from './dijkstra';\nimport { uniqueId } from './util';\n\n/**  map */\ninterface NodePairMap {\n  [key: string]: {\n    // key  startNodeIdx-endNodeIdx\n    start: number; //  idx\n    end: number; //  idx\n    distance: number; // \n  };\n}\n\ninterface LabelMap {\n  [label: string]: any;\n}\n\n/**  */\ninterface NeighborUnit {\n  nodeId: string;\n  nodeIdx: number;\n  nodeIdxs: number[]; // the first one is nodeIdx\n  neighbors: any[]; //\n  neighborNum: number;\n  nodeLabelCountMap: {\n    [label: string]: {\n      count: number;\n      dists: number[]; // \n    };\n  };\n}\n\n/**  map */\ninterface InterGraphMap {\n  [key: string]: GraphData; // key  idx beginIdx-endIdx nodePairMap \n}\n\n/**\n *  graphData \n * @param graphData\n * @param spm\n * @param nodeLabelProp\n * @param k k-\n */\nconst findKNeighborUnits = (\n  graphData: GraphData,\n  spm: Matrix[],\n  nodeLabelProp: string = 'cluster',\n  k: number = 2,\n): NeighborUnit[] => {\n  const units: NeighborUnit[] = [];\n  const nodes = graphData.nodes;\n  spm.forEach((row: number[], i) => {\n    units.push(findKNeighborUnit(nodes, row, i, nodeLabelProp, k));\n  });\n  return units;\n};\n\nconst findKNeighborUnit = (nodes, row, i, nodeLabelProp, k) => {\n  const unitNodeIdxs = [i];\n  const neighbors = [];\n  const labelCountMap = {};\n  row.forEach((v, j) => {\n    if (v <= k && i !== j) {\n      unitNodeIdxs.push(j);\n      neighbors.push(nodes[j]);\n      const label = nodes[j][nodeLabelProp];\n      if (!labelCountMap[label]) labelCountMap[label] = { count: 1, dists: [v] };\n      else {\n        labelCountMap[label].count++;\n        labelCountMap[label].dists.push(v);\n      }\n    }\n  });\n  //  labelCountMap  dists \n  Object.keys(labelCountMap).forEach(label => {\n    labelCountMap[label].dists = labelCountMap[label].dists.sort((a, b) => a - b);\n  });\n  return {\n    nodeIdx: i,\n    nodeId: nodes[i].id,\n    nodeIdxs: unitNodeIdxs,\n    neighbors,\n    neighborNum: unitNodeIdxs.length - 1,\n    nodeLabelCountMap: labelCountMap,\n  };\n};\n\n/**\n *  k\n * @param k  k k-\n * @param nodeNum  length\n * @param maxNodePairNum  maxNodePairNum\n * @param spm \n */\nconst findNodePairsRandomly = (\n  k: number,\n  nodeNum: number,\n  maxNodePairNum: number,\n  kNeighborUnits: NeighborUnit[],\n  spm: Matrix[],\n): NodePairMap => {\n  // \n  let nodePairNumEachNode = Math.ceil(maxNodePairNum / nodeNum);\n  const nodePairMap = {};\n  let foundNodePairCount = 0;\n\n  //  nodePairNumEachNode  k maxNodePairNum \n  kNeighborUnits.forEach((unit, i) => {\n    //  nodePairNumEachNode(2 * nodeNum)\n    let nodePairForICount = 0;\n    let outerLoopCount = 0;\n    const neighbors = unit.nodeIdxs; // the first one is the center node\n    const neighborNum = unit.neighborNum - 1;\n    while (nodePairForICount < nodePairNumEachNode) {\n      //  index\n      let oidx = neighbors[1 + Math.floor(Math.random() * neighborNum)];\n      let innerLoopCount = 0;\n      //  idx  random k\n      while (nodePairMap[`${i}-${oidx}`] || nodePairMap[`${oidx}-${i}`]) {\n        oidx = Math.floor(Math.random() * nodeNum);\n        innerLoopCount++;\n        if (innerLoopCount > 2 * nodeNum) break; // (2 * nodeNum)\n      }\n      if (innerLoopCount < 2 * nodeNum) {\n        // \n        nodePairMap[`${i}-${oidx}`] = {\n          start: i,\n          end: oidx,\n          distance: spm[i][oidx],\n        };\n        nodePairForICount++;\n        foundNodePairCount++;\n        // \n        if (foundNodePairCount >= maxNodePairNum) return nodePairMap;\n      }\n      outerLoopCount++;\n      if (outerLoopCount > 2 * nodeNum) break; // (2 * nodeNum)\n    }\n    //  nodePairNumEachNode  nodePairNumEachNode\n    if (nodePairForICount < nodePairNumEachNode) {\n      const gap = nodePairNumEachNode - nodePairForICount;\n      nodePairNumEachNode = (nodePairNumEachNode + gap) / (nodeNum - i - 1);\n    }\n  });\n  return nodePairMap;\n};\n\n/**\n *  nodePairMap \n * @param nodePairMap  mapkey  node1.id-node2.idvalue  { startNodeIdx, endNodeIdx, distance }\n * @param neighborUnits \n * @param graphData \n * @param edgeMap  map\n * @param cachedInducedGraphMap  key \n */\nconst getIntersectNeighborInducedGraph = (\n  nodePairMap: NodePairMap,\n  neighborUnits: NeighborUnit[],\n  graphData: GraphData,\n  cachedInducedGraphMap?: InterGraphMap,\n): InterGraphMap => {\n  const nodes = graphData.nodes;\n  if (!cachedInducedGraphMap) cachedInducedGraphMap = {};\n  Object.keys(nodePairMap).forEach(key => {\n    if (cachedInducedGraphMap && cachedInducedGraphMap[key]) return;\n    cachedInducedGraphMap[key] = { nodes: [], edges: [] };\n    const pair = nodePairMap[key];\n    const startUnitNodeIds = neighborUnits[pair.start]?.nodeIdxs;\n    const endUnitNodeIds = neighborUnits[pair.end]?.nodeIdxs;\n    if (!startUnitNodeIds || !endUnitNodeIds) return; // \n    const endSet = new Set(endUnitNodeIds);\n    const intersect = startUnitNodeIds.filter(x => endSet.has(x)); //  1580 + 6 nodes full-connected \n    if (!intersect || !intersect.length) return; // \n    const intersectIdMap = {};\n    const intersectLength = intersect.length;\n    for (let i = 0; i < intersectLength; i++) {\n      const node = nodes[intersect[i]];\n      cachedInducedGraphMap[key].nodes.push(node); // \n      intersectIdMap[node.id] = true;\n    }\n    // \n    graphData.edges.forEach(edge => {\n      if (intersectIdMap[edge.source] && intersectIdMap[edge.target])\n        cachedInducedGraphMap[key].edges.push(edge);\n    });\n  });\n  return cachedInducedGraphMap;\n};\n\n/**\n *  strcutre  graph \n * @param graph \n * @param structure \n * @param nodeLabelProp \n * @param edgeLabelProp \n */\nconst getMatchedCount = (graph, structure, nodeLabelProp, edgeLabelProp) => {\n  const nodeMap = {};\n  graph.nodes.forEach(node => {\n    nodeMap[node.id] = node;\n  });\n  let count = 0;\n  graph.edges.forEach(e => {\n    const sourceLabel = nodeMap[e.source][nodeLabelProp];\n    const targetLabel = nodeMap[e.target][nodeLabelProp];\n    const strNodeLabel1 = structure.nodes[0][nodeLabelProp];\n    const strNodeLabel2 = structure.nodes[1][nodeLabelProp];\n    const strEdgeLabel = structure.edges[0][edgeLabelProp];\n\n    if (e[edgeLabelProp] !== strEdgeLabel) return;\n    if (\n      (sourceLabel === strNodeLabel1 && targetLabel === strNodeLabel2) ||\n      (sourceLabel === strNodeLabel2 && targetLabel === strNodeLabel1)\n    ) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/**\n * structures  matchedCountMap \n * @param matchedCountMap  structure  { [strcture.idx]: { [interInducedGraphKey]: count } }\n * @param structureNum strcuture  matchedCountMap.length \n * @param structures\n */\nconst findRepresentStructure = (matchedCountMap, structureNum, structures) => {\n  let maxOffset = Infinity,\n    representClusterType = 0;\n  for (let i = 0; i < structureNum; i++) {\n    //  mapkey  intGraph  keyvalue  structures[i] \n    const countMapI = matchedCountMap[i];\n    //  value  keys \n    const sortedGraphKeys = Object.keys(countMapI).sort((a, b) => {\n      return countMapI[a] - countMapI[b];\n    });\n\n    //  100  graphKeys graphKeys  groupNum \n    const groupNum = 10;\n    const clusters = []; //  groupNum \n    sortedGraphKeys.forEach((key, j) => {\n      if (!clusters[j % groupNum])\n        clusters[j % groupNum] = { graphs: [], totalCount: 0, aveCount: 0 };\n      clusters[j % groupNum].graphs.push(key);\n      clusters[j % groupNum].totalCount += countMapI[key];\n    });\n\n    //  cluster  cluster  innerDist cluster  intraDist\n    let aveIntraDist = 0; // \n    const aveCounts = []; // \n    clusters.forEach(graphsInCluster => {\n      // \n      const aveCount = graphsInCluster.totalCount / graphsInCluster.graphs.length;\n      graphsInCluster.aveCount = aveCount;\n      aveCounts.push(aveCount);\n\n      // \n      let aveIntraPerCluster = 0;\n      const graphsNum = graphsInCluster.length;\n      graphsInCluster.graphs.forEach((graphKey1, j) => {\n        const graph1Count = countMapI[graphKey1];\n        graphsInCluster.graphs.forEach((graphKey2, k) => {\n          if (j === k) return;\n          aveIntraPerCluster += Math.abs(graph1Count - countMapI[graphKey2]);\n        });\n      });\n      aveIntraPerCluster /= (graphsNum * (graphsNum - 1)) / 2;\n      aveIntraDist += aveIntraPerCluster;\n    });\n\n    aveIntraDist /= clusters.length;\n\n    // \n    let aveInterDist = 0; // \n    aveCounts.forEach((aveCount1, j) => {\n      aveCounts.forEach((aveCount2, k) => {\n        if (j === k) return;\n        aveInterDist += Math.abs(aveCount1 - aveCount2);\n      });\n      aveInterDist /= (aveCounts.length * (aveCounts.length - 1)) / 2;\n    });\n\n    //  (-)  structure  DS(G)\n    const offset = aveInterDist - aveIntraDist;\n    if (maxOffset < offset) {\n      maxOffset = offset;\n      representClusterType = i;\n    }\n  }\n  return {\n    structure: structures[representClusterType],\n    structureCountMap: matchedCountMap[representClusterType],\n  };\n};\n\nconst getNodeMaps = (nodes, nodeLabelProp): { nodeMap: NodeMap; nodeLabelMap: LabelMap } => {\n  const nodeMap: NodeMap = {},\n    nodeLabelMap: LabelMap = {};\n  nodes.forEach((node, i) => {\n    nodeMap[node.id] = { idx: i, node, degree: 0 };\n    const label = node[nodeLabelProp];\n    if (!nodeLabelMap[label]) nodeLabelMap[label] = [];\n    nodeLabelMap[label].push(node);\n  });\n  return { nodeMap, nodeLabelMap };\n};\n\nconst getEdgeMaps = (\n  edges,\n  edgeLabelProp,\n  nodeMap: NodeMap,\n): { edgeMap: EdgeMap; edgeLabelMap: LabelMap } => {\n  const edgeMap = {},\n    edgeLabelMap = {};\n  edges.forEach((edge, i) => {\n    edgeMap[`${uniqueId}`] = { idx: i, edge };\n    const label = edge[edgeLabelProp];\n    if (!edgeLabelMap[label]) edgeLabelMap[label] = [];\n    edgeLabelMap[label].push(edge);\n\n    const sourceNode = nodeMap[edge.source];\n    if (sourceNode) sourceNode.degree++;\n    const targetNode = nodeMap[edge.target];\n    if (targetNode) targetNode.degree++;\n  });\n  return { edgeMap, edgeLabelMap };\n};\n\n/**\n *  mapkey  sourceNode.id-targetNode.idvalue \n * @param nodes\n * @param spm\n * @param directed\n */\nconst getSpmMap = (nodes, spm, directed): { [key: string]: number } => {\n  const length = spm.length;\n  const map = {};\n  spm.forEach((row, i) => {\n    const start = directed ? 0 : i + 1;\n    const iId = nodes[i].id;\n    for (let j = start; j < length; j++) {\n      if (i === j) continue;\n      const jId = nodes[j].id;\n      const dist = row[j];\n      map[`${iId}-${jId}`] = dist;\n      if (!directed) map[`${jId}-${iId}`] = dist;\n    }\n  });\n  return map;\n};\n\n/**\n * node1node2 NDS \n * @param graph \n * @param node1\n * @param node2\n */\nconst getNDSDist = (\n  graph,\n  node1,\n  node2,\n  nodeMap,\n  spDist,\n  kNeighborUnits,\n  structure,\n  nodeLabelProp,\n  edgeLabelProp,\n  cachedNDSMap,\n  cachedInterInducedGraph,\n) => {\n  const key = `${node1.id}-${node2.id}`;\n  if (cachedNDSMap && cachedNDSMap[key]) return cachedNDSMap[key];\n  let interInducedGraph = cachedInterInducedGraph ? cachedInterInducedGraph[key] : undefined;\n  // \n  if (!interInducedGraph) {\n    const pairMap: NodePairMap = {\n      [key]: {\n        start: nodeMap[node1.id].idx,\n        end: nodeMap[node2.id].idx,\n        distance: spDist,\n      },\n    };\n\n    cachedInterInducedGraph = getIntersectNeighborInducedGraph(\n      pairMap,\n      kNeighborUnits,\n      graph,\n      cachedInterInducedGraph,\n    );\n    interInducedGraph = cachedInterInducedGraph[key];\n  }\n\n  return getMatchedCount(interInducedGraph, structure, nodeLabelProp, edgeLabelProp);\n};\n\n/**\n * GADDI \n * @param graphData \n * @param pattern \n * @param directed  false\n * @param k  k k-\n * @param length  length\n * @param nodeLabelProp  cluster\n * @param edgeLabelProp  cluster\n */\nconst GADDI = (\n  graphData: GraphData,\n  pattern: GraphData,\n  directed: boolean = false,\n  k: number,\n  length: number,\n  nodeLabelProp: string = 'cluster',\n  edgeLabelProp: string = 'cluster',\n): GraphData[] => {\n  if (!graphData || !graphData.nodes) return;\n  // \n  // 0. /\n  // 1.  graphData 1~5 \n  // 2. \n\n  // console.log(\"----- stage-pre: preprocessing -------\");\n\n  // -------- /-------\n  const nodeNum = graphData.nodes.length;\n  if (!nodeNum) return;\n  // console.log(\"----- stage-pre.1: calc shortest path matrix for graph -------\");\n  const spm = floydWarshall(graphData, directed);\n  // console.log(\n  //   \"----- stage-pre.2: calc shortest path matrix for pattern -------\"\n  // );\n  const patternSpm = floydWarshall(pattern, directed);\n  // console.log(\n  //   \"----- stage-pre.3: calc shortest path matrix map for graph -------\"\n  // );\n  const spmMap = getSpmMap(graphData.nodes, spm, directed);\n  // console.log(\n  //   \"----- stage-pre.4: calc shortest path matrix map for pattern -------\"\n  // );\n  const patternSpmMap = getSpmMap(pattern.nodes, patternSpm, directed);\n\n  // console.log(\"----- stage-pre.5: establish maps -------\");\n  //  map id  id \n  const { nodeMap, nodeLabelMap } = getNodeMaps(graphData.nodes, nodeLabelProp);\n  const { nodeMap: patternNodeMap, nodeLabelMap: patternNodeLabelMap } = getNodeMaps(\n    pattern.nodes,\n    nodeLabelProp,\n  );\n\n  // \n  getEdgeMaps(graphData.edges, edgeLabelProp, nodeMap);\n\n  const { edgeLabelMap: patternEdgeLabelMap } = getEdgeMaps(\n    pattern.edges,\n    edgeLabelProp,\n    patternNodeMap,\n  );\n\n  //  length pattern \n  if (!length) length = Math.max(...patternSpm[0], 2);\n  if (!k) k = length;\n\n  // console.log(\"params\", directed, length, k);\n\n  // console.log(\"----- stage-pre.6: calc k neighbor units -------\");\n  //  k \n  const kNeighborUnits = findKNeighborUnits(graphData, spm, nodeLabelProp, k);\n  const patternKNeighborUnits = findKNeighborUnits(pattern, patternSpm, nodeLabelProp, k);\n\n  // console.log(\n  //   \"----- stage0: going to processing graph and find intersect neighbor induced graphs -------\"\n  // );\n\n  // console.log(\"----- stage0.1: going to select random node pairs -------\");\n  // --------  graphData-------\n\n  // 1.1.  100  Length  k\n  //  graphData  20  100  n(n-1)/2 \n  const maxNodePairNum = Math.min(100, (nodeNum * (nodeNum - 1)) / 2);\n  const nodePairsMap = findNodePairsRandomly(\n    k,\n    nodeNum,\n    maxNodePairNum,\n    patternKNeighborUnits,\n    spm,\n  );\n\n  // console.log(\n  //   \"----- stage0.2: going to calculate intersect neighbor induced graphs -------\"\n  // );\n  // 1.2.  {'beginNodeIdx-endNodeIdx': {nodes: [], edges: []}}\n  let intGMap = getIntersectNeighborInducedGraph(nodePairsMap, kNeighborUnits, graphData);\n\n  // 1.3.  gSpan frequent graph mining ISIntG  10 3-4\n  const top = 10,\n    minSupport = 1,\n    minNodeNum = 1,\n    maxNodeNum = 4;\n  const params = {\n    graphs: intGMap,\n    nodeLabelProp,\n    edgeLabelProp,\n    minSupport,\n    minNodeNum,\n    maxNodeNum,\n    directed,\n  };\n\n  // console.log(\n  //   \"----- stage1: (gSpan) going to find frequent structure dsG -------\"\n  // );\n  // console.log(\"----- stage1.1: going to run gSpan -------\");\n  //  sub structure \n  const freStructures = gSpan(params).slice(0, top);\n  // structureNum  top\n  const structureNum = freStructures.length;\n\n  // 1.4.  10  intGMap \n  const matchedCountMap = [];\n  freStructures.forEach((structure, i) => {\n    matchedCountMap[i] = {};\n    Object.keys(intGMap).forEach(key => {\n      const graph = intGMap[key];\n      const subStructureCount = getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp);\n      matchedCountMap[i][key] = subStructureCount;\n    });\n  });\n\n  // console.log(\n  //   \"----- stage1.1: going to find the most represent strucutre -------\"\n  // );\n\n  // 1.5.  intGMap  structureNum \n  //  DS(G)\n  const { structure: dsG, structureCountMap: ndsDist } = findRepresentStructure(\n    matchedCountMap,\n    structureNum,\n    freStructures,\n  );\n\n  // -------- -------\n  // 2.1  Q  G \n  const beginPNode = pattern.nodes[0];\n  const label = beginPNode[nodeLabelProp];\n  // 2.1.1  G \n  let candidates = nodeLabelMap[label];\n\n  // console.log(\"----- stage2: going to find candidates -------\");\n\n  // \n  const minPatternNodeLabelDegreeMap = {}; // key  labelvalue  label \n  let patternIntGraphMap = {},\n    patternNDSDist = {}, // key  node.id-node.id\n    patternNDSDistMap = {}; // key  node.id-label2value nds node2\n  // 2.2.2  Q  k  node  NDS \n  const patternSpDist = {};\n  Object.keys(patternNodeLabelMap).forEach((label2, j) => {\n    patternSpDist[label2] = [];\n    let maxDist = -Infinity;\n    const patternNodesWithLabel2 = patternNodeLabelMap[label2];\n    const patternNodePairMap = {};\n    patternNodesWithLabel2.forEach(nodeWithLabel2 => {\n      const dist = patternSpmMap[`${beginPNode.id}-${nodeWithLabel2.id}`];\n      dist && patternSpDist[label2].push(dist);\n      if (maxDist < dist) maxDist = dist;\n      patternNodePairMap[`${beginPNode.id}-${nodeWithLabel2.id}`] = {\n        start: 0,\n        end: patternNodeMap[nodeWithLabel2.id].idx,\n        distance: dist,\n      };\n    });\n\n    // spDist[label2] \n    patternSpDist[label2] = patternSpDist[label2].sort((a, b) => a - b);\n\n    //  Q  label2  beginPNode  NDS \n    //  label2  beginPNode \n    // key: node1.id-node2.id\n    patternIntGraphMap = getIntersectNeighborInducedGraph(\n      patternNodePairMap,\n      patternKNeighborUnits,\n      pattern,\n      patternIntGraphMap,\n    );\n    // pattern  beginNode  label2   NDS \n    let currentPatternNDSDistArray = [];\n    Object.keys(patternNodePairMap).forEach(key => {\n      if (patternNDSDist[key]) {\n        currentPatternNDSDistArray.push(patternNDSDist[key]);\n        return; // \n      }\n      const patternIntGraph = patternIntGraphMap[key];\n      patternNDSDist[key] = getMatchedCount(patternIntGraph, dsG, nodeLabelProp, edgeLabelProp);\n      currentPatternNDSDistArray.push(patternNDSDist[key]);\n    });\n\n    //  currentPatternNDSDist \n    currentPatternNDSDistArray = currentPatternNDSDistArray.sort((a, b) => b - a);\n    patternNDSDistMap[`${beginPNode.id}-${label2}`] = currentPatternNDSDistArray;\n\n    if (label2 === label) return;\n\n    const candidatesNum = candidates.length;\n    for (let m = candidatesNum - 1; m >= 0; m--) {\n      const cNode = candidates[m];\n\n      // prune1 candidates  cNode  kNeighborUnits  label2  pattern  label2 \n      const graphNeighborUnit = kNeighborUnits[nodeMap[cNode.id].idx];\n      const graphNeighborUnitCountMap = graphNeighborUnit.nodeLabelCountMap[label2];\n      const patternLabel2Num = patternNodeLabelMap[label2].length;\n      if (!graphNeighborUnitCountMap || graphNeighborUnitCountMap.count < patternLabel2Num) {\n        candidates.splice(m, 1);\n        continue;\n      }\n\n      // prune2 candidates  cNode  kNeighborUnits  label2  patternSpDist[label2]\n      // (prune2 candidate  spDist[label2].length  patternSpDist[label2]  G > Q  candidate)\n      let prune2Invalid = false;\n      for (let n = 0; n < patternLabel2Num; n++) {\n        if (graphNeighborUnitCountMap.dists[n] > patternSpDist[label2][n]) {\n          prune2Invalid = true;\n          break;\n        }\n      }\n      if (prune2Invalid) {\n        candidates.splice(m, 1);\n        continue;\n      }\n\n      // prune3 candidates  cNode  kNeighborUnits  label2  NDS  patternNDSDist[beginNode.id-label2]\n      // TODOprune3currentPatternNDSDistArray  currentNDSDist \n\n      //  G  label2  cNode  NDS \n      //  label2  cNode \n      const cNodePairMap = {};\n      graphNeighborUnit.neighbors.forEach(neighborNode => {\n        const dist = spmMap[`${cNode.id}-${neighborNode.id}`];\n        cNodePairMap[`${cNode.id}-${neighborNode.id}`] = {\n          start: nodeMap[cNode.id].idx,\n          end: nodeMap[neighborNode.id].idx,\n          distance: dist,\n        };\n      });\n      //  intGMap\n      intGMap = getIntersectNeighborInducedGraph(cNodePairMap, kNeighborUnits, graphData, intGMap);\n      // candidate  label2  NDS , key  node.id-node.id\n      let currentNDSDistArray = [];\n      Object.keys(cNodePairMap).forEach(key => {\n        if (ndsDist[key]) {\n          currentNDSDistArray.push(ndsDist[key]);\n          return; // \n        }\n        const intGraph = intGMap[key];\n        ndsDist[key] = getMatchedCount(intGraph, dsG, nodeLabelProp, edgeLabelProp);\n        currentNDSDistArray.push(ndsDist[key]);\n      });\n\n      //  currentNDSDistArray \n      currentNDSDistArray = currentNDSDistArray.sort((a, b) => b - a);\n\n      let prune3Invalid = false;\n      for (let n = 0; n < patternLabel2Num; n++) {\n        if (currentNDSDistArray[n] < currentPatternNDSDistArray[n]) {\n          prune3Invalid = true;\n          break;\n        }\n      }\n      if (prune3Invalid) {\n        candidates.splice(m, 1);\n        continue;\n      }\n    }\n  });\n\n  const candidateGraphs = [];\n\n  // console.log(\n  //   \"----- stage3: going to splice neighbors for each candidate graph -------\"\n  // );\n\n  // candidates  candidate  Length-neighbor \n  //  Q  Q  label label  candidate  QNDS  Q\n  candidates.forEach(candidate => {\n    const nodeIdx = nodeMap[candidate.id].idx;\n    const lengthNeighborUnit = findKNeighborUnit(\n      graphData.nodes,\n      spm[nodeIdx],\n      nodeIdx,\n      nodeLabelProp,\n      length,\n    );\n\n    const neighborNodes = lengthNeighborUnit.neighbors;\n\n    // \n    const neighborNum = neighborNodes.length;\n    let unmatched = false;\n    for (let i = neighborNum - 1; i >= 0; i--) {\n      //  candidate \n      if (neighborNodes.length + 1 < pattern.nodes.length) {\n        unmatched = true;\n        return;\n      }\n      const neighborNode = neighborNodes[i];\n      const neighborLabel = neighborNode[nodeLabelProp];\n      // prune1:  label  pattern \n      if (!patternNodeLabelMap[neighborLabel] || !patternNodeLabelMap[neighborLabel].length) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n\n      const key = `${candidate.id}-${neighborNode.id}`;\n\n      // prune2:  candidate  label  beginPNode \n      // prune2.1:  beginPNode  pattern  beginPNode  label label \n      if (!patternSpDist[neighborLabel] || !patternSpDist[neighborLabel].length) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n      // prune2.2\n      const distToCandidate = spmMap[key];\n      const maxDistWithLabelInPattern =\n        patternSpDist[neighborLabel][patternSpDist[neighborLabel].length - 1]; // patternSpDist[neighborLabel] \n      if (distToCandidate > maxDistWithLabelInPattern) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n\n      // prune3:  candidate  NDS  label  beginPNode  NDS \n      const ndsToCandidate = ndsDist[key]\n        ? ndsDist[key]\n        : getNDSDist(\n            graphData,\n            candidate,\n            neighborNode,\n            nodeMap,\n            distToCandidate,\n            kNeighborUnits,\n            dsG,\n            nodeLabelProp,\n            edgeLabelProp,\n            ndsDist,\n            intGMap,\n          );\n      const patternKey = `${beginPNode.id}-${neighborLabel}`;\n      const minNdsWithLabelInPattern =\n        patternNDSDistMap[patternKey][patternNDSDistMap[patternKey].length - 1]; // patternNDSDist[key] \n      if (ndsToCandidate < minNdsWithLabelInPattern) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n\n      // prune4:  pattern  label \n      let minPatternNodeLabelDegree = minPatternNodeLabelDegreeMap[neighborLabel];\n      if (minPatternNodeLabelDegree === undefined) {\n        minPatternNodeLabelDegree = Infinity;\n        patternNodeLabelMap[neighborLabel].forEach(patternNodeWithLabel => {\n          const patternNodeDegree = patternNodeMap[patternNodeWithLabel.id].degree;\n          if (minPatternNodeLabelDegree > patternNodeDegree)\n            minPatternNodeLabelDegree = patternNodeDegree;\n        });\n        minPatternNodeLabelDegreeMap[neighborLabel] = minPatternNodeLabelDegree;\n      }\n      if (nodeMap[neighborNode.id].degree < minPatternNodeLabelDegree) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n    }\n\n    //  pattern \n    if (!unmatched) {\n      candidateGraphs.push({\n        nodes: [candidate].concat(neighborNodes),\n      });\n    }\n  });\n\n  // console.log(\n  //   \"----- stage4: going to splice edges and neighbors for each candidate graph -------\"\n  // );\n\n  const { length: undirectedLengthsToBeginPNode } = dijkstra(pattern, beginPNode.id, false);\n\n  let undirectedLengthsToBeginPNodeLabelMap = {};\n  if (directed) {\n    Object.keys(undirectedLengthsToBeginPNode).forEach(nodeId => {\n      const nodeLabel = patternNodeMap[nodeId].node[nodeLabelProp];\n      if (!undirectedLengthsToBeginPNodeLabelMap[nodeLabel])\n        undirectedLengthsToBeginPNodeLabelMap[nodeLabel] = [undirectedLengthsToBeginPNode[nodeId]];\n      else\n        undirectedLengthsToBeginPNodeLabelMap[nodeLabel].push(\n          undirectedLengthsToBeginPNode[nodeId],\n        );\n    });\n    Object.keys(undirectedLengthsToBeginPNodeLabelMap).forEach(pLabel => {\n      undirectedLengthsToBeginPNodeLabelMap[pLabel].sort((a, b) => a - b);\n    });\n  } else {\n    undirectedLengthsToBeginPNodeLabelMap = patternSpDist;\n  }\n\n  //  candidateGraphs \n  const candidateGraphNum = candidateGraphs.length;\n  for (let i = candidateGraphNum - 1; i >= 0; i--) {\n    const candidateGraph = candidateGraphs[i];\n    const candidate = candidateGraph.nodes[0];\n\n    const candidateNodeLabelCountMap = {};\n    const candidateNodeMap = {};\n    candidateGraph.nodes.forEach((node, q) => {\n      candidateNodeMap[node.id] = {\n        idx: q,\n        node,\n        degree: 0,\n      };\n      const cNodeLabel = node[nodeLabelProp];\n      if (!candidateNodeLabelCountMap[cNodeLabel]) candidateNodeLabelCountMap[cNodeLabel] = 1;\n      else candidateNodeLabelCountMap[cNodeLabel]++;\n    });\n\n    //  candidate  neighborNodes  G \n    //  graphData  candidateGraph.nodes  candidateEdges\n    const candidateEdges = [];\n    const edgeLabelCountMap = {};\n    graphData.edges.forEach(edge => {\n      if (candidateNodeMap[edge.source] && candidateNodeMap[edge.target]) {\n        candidateEdges.push(edge);\n        if (!edgeLabelCountMap[edge[edgeLabelProp]]) edgeLabelCountMap[edge[edgeLabelProp]] = 1;\n        else edgeLabelCountMap[edge[edgeLabelProp]]++;\n        candidateNodeMap[edge.source].degree++;\n        candidateNodeMap[edge.target].degree++;\n      }\n    });\n\n    // prune edgeLabel  candidateGraph  pattern\n    const pattenrEdgeLabelNum = Object.keys(patternEdgeLabelMap).length;\n    let prunedByEdgeLabel = false;\n    for (let e = 0; e < pattenrEdgeLabelNum; e++) {\n      const label = Object.keys(patternEdgeLabelMap)[e];\n      if (\n        !edgeLabelCountMap[label] ||\n        edgeLabelCountMap[label] < patternEdgeLabelMap[label].length\n      ) {\n        prunedByEdgeLabel = true;\n        break;\n      }\n    }\n    if (prunedByEdgeLabel) {\n      candidateGraphs.splice(i, 1);\n      continue;\n    }\n\n    //  candidateEdges\n    let candidateEdgeNum = candidateEdges.length;\n\n    // prune\n    if (candidateEdgeNum < pattern.edges.length) {\n      candidateGraphs.splice(i, 1);\n      break;\n    }\n    let candidateGraphInvalid = false;\n    for (let e = candidateEdgeNum - 1; e >= 0; e--) {\n      const edge = candidateEdges[e];\n      const edgeLabel = edge[edgeLabelProp];\n      const patternEdgesWithLabel = patternEdgeLabelMap[edgeLabel];\n\n      // prune 1:  label  pattern  label \n      if (!patternEdgesWithLabel || !patternEdgesWithLabel.length) {\n        edgeLabelCountMap[edgeLabel]--;\n        //  label  count  label \n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\n          candidateGraphInvalid = true;\n          break;\n        }\n        candidateEdges.splice(e, 1);\n        candidateNodeMap[edge.source].degree--;\n        candidateNodeMap[edge.target].degree--;\n        continue;\n      }\n\n      // prune 2:  label + label  pattern \n      const sourceLabel = candidateNodeMap[edge.source].node[nodeLabelProp];\n      const targetLabel = candidateNodeMap[edge.target].node[nodeLabelProp];\n\n      let edgeMatched = false;\n      patternEdgesWithLabel.forEach(patternEdge => {\n        const patternSource = patternNodeMap[patternEdge.source].node;\n        const patternTarget = patternNodeMap[patternEdge.target].node;\n        if (\n          patternSource[nodeLabelProp] === sourceLabel &&\n          patternTarget[nodeLabelProp] === targetLabel\n        )\n          edgeMatched = true;\n        if (\n          !directed &&\n          patternSource[nodeLabelProp] === targetLabel &&\n          patternTarget[nodeLabelProp] === sourceLabel\n        )\n          edgeMatched = true;\n      });\n      if (!edgeMatched) {\n        edgeLabelCountMap[edgeLabel]--;\n        //  label  count  label \n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\n          candidateGraphInvalid = true;\n          break;\n        }\n        candidateEdges.splice(e, 1);\n        candidateNodeMap[edge.source].degree--;\n        candidateNodeMap[edge.target].degree--;\n        continue;\n      }\n    }\n\n    // prune2: / label \n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      continue;\n    }\n\n    candidateGraph.edges = candidateEdges;\n\n    const { length: lengthsToCandidate } = dijkstra(\n      candidateGraph,\n      candidateGraph.nodes[0].id,\n      false, // \n    );\n    Object.keys(lengthsToCandidate)\n      .reverse()\n      .forEach(targetId => {\n        if (targetId === candidateGraph.nodes[0].id || candidateGraphInvalid) return;\n        // prune4:  candidate\n        if (lengthsToCandidate[targetId] === Infinity) {\n          const targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\n          candidateNodeLabelCountMap[targetNodeLabel]--;\n          if (\n            candidateNodeLabelCountMap[targetNodeLabel] <\n            patternNodeLabelMap[targetNodeLabel].length\n          ) {\n            candidateGraphInvalid = true;\n            return;\n          }\n          const idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\n          candidateGraph.nodes.splice(idx, 1);\n          candidateNodeMap[targetId] = undefined;\n          return;\n        }\n        // prune5:   pattern  label  beginNode \n        const nLabel = nodeMap[targetId].node[nodeLabelProp];\n        if (\n          !undirectedLengthsToBeginPNodeLabelMap[nLabel] ||\n          !undirectedLengthsToBeginPNodeLabelMap[nLabel].length ||\n          lengthsToCandidate[targetId] >\n            undirectedLengthsToBeginPNodeLabelMap[nLabel][\n              undirectedLengthsToBeginPNodeLabelMap[nLabel].length - 1\n            ]\n        ) {\n          const targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\n          candidateNodeLabelCountMap[targetNodeLabel]--;\n          if (\n            candidateNodeLabelCountMap[targetNodeLabel] <\n            patternNodeLabelMap[targetNodeLabel].length\n          ) {\n            candidateGraphInvalid = true;\n            return;\n          }\n          const idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\n          candidateGraph.nodes.splice(idx, 1);\n          candidateNodeMap[targetId] = undefined;\n        }\n      });\n\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      continue;\n    }\n\n    let degreeChanged = true;\n    let loopCount = 0;\n    while (degreeChanged && !candidateGraphInvalid) {\n      degreeChanged = false;\n\n      // candidate \n      if (candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree) {\n        candidateGraphInvalid = true;\n        break;\n      }\n      // candidate label \n      if (\n        candidateNodeLabelCountMap[candidate[nodeLabelProp]] <\n        patternNodeLabelMap[candidate[nodeLabelProp]].length\n      ) {\n        candidateGraphInvalid = true;\n        break;\n      }\n\n      // prune6\n      const currentCandidateNodeNum = candidateGraph.nodes.length;\n      for (let o = currentCandidateNodeNum - 1; o >= 0; o--) {\n        const cgNode = candidateGraph.nodes[o];\n        const nodeDegree = candidateNodeMap[cgNode.id].degree;\n        const cNodeLabel = cgNode[nodeLabelProp];\n        if (nodeDegree < minPatternNodeLabelDegreeMap[cNodeLabel]) {\n          candidateNodeLabelCountMap[cgNode[nodeLabelProp]]--;\n          //  label \n          if (\n            candidateNodeLabelCountMap[cgNode[nodeLabelProp]] <\n            patternNodeLabelMap[cgNode[nodeLabelProp]].length\n          ) {\n            candidateGraphInvalid = true;\n            break;\n          }\n          candidateGraph.nodes.splice(o, 1);\n          candidateNodeMap[cgNode.id] = undefined;\n          degreeChanged = true;\n        }\n      }\n      if (candidateGraphInvalid || (!degreeChanged && loopCount !== 0)) break;\n      //  prune5  candidateGraph \n      candidateEdgeNum = candidateEdges.length;\n      for (let y = candidateEdgeNum - 1; y >= 0; y--) {\n        const cedge = candidateEdges[y];\n        if (!candidateNodeMap[cedge.source] || !candidateNodeMap[cedge.target]) {\n          candidateEdges.splice(y, 1);\n          const edgeLabel = cedge[edgeLabelProp];\n          edgeLabelCountMap[edgeLabel]--;\n          candidateNodeMap[cedge.source] && candidateNodeMap[cedge.source].degree--;\n          candidateNodeMap[cedge.target] && candidateNodeMap[cedge.target].degree--;\n          //  label \n          if (\n            patternEdgeLabelMap[edgeLabel] &&\n            edgeLabelCountMap[edgeLabel] < patternEdgeLabelMap[edgeLabel].length\n          ) {\n            candidateGraphInvalid = true;\n            break;\n          }\n          degreeChanged = true;\n        }\n      }\n      loopCount++;\n    }\n\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      continue;\n    }\n\n    // prune: // label \n    if (\n      candidateGraphInvalid ||\n      candidateGraph.nodes.length < pattern.nodes.length ||\n      candidateEdges.length < pattern.edges.length\n    ) {\n      candidateGraphs.splice(i, 1);\n      continue;\n    }\n  }\n\n  //  candidateGraphs\n\n  // console.log(\n  //   \"----- stage5: going to splice dulplicated candidate graphs -------\"\n  // );\n\n  //  candidateGraphs  node-node-edgeLabel  key value\n  let currentLength = candidateGraphs.length;\n  for (let i = 0; i <= currentLength - 1; i++) {\n    const cg1 = candidateGraphs[i];\n    const cg1EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\n    cg1.edges.forEach(edge => {\n      const key = `${edge.source}-${edge.target}-${edge.label}`;\n      if (!cg1EdgeMap[key]) cg1EdgeMap[key] = 1;\n      else cg1EdgeMap[key]++;\n    });\n\n    for (let j = currentLength - 1; j > i; j--) {\n      const cg2 = candidateGraphs[j];\n      const cg2EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\n      cg2.edges.forEach(edge => {\n        const key = `${edge.source}-${edge.target}-${edge.label}`;\n        if (!cg2EdgeMap[key]) cg2EdgeMap[key] = 1;\n        else cg2EdgeMap[key]++;\n      });\n\n      let same = true;\n      if (Object.keys(cg2EdgeMap).length !== Object.keys(cg1EdgeMap).length) {\n        same = false;\n      } else {\n        Object.keys(cg1EdgeMap).forEach(key => {\n          if (cg2EdgeMap[key] !== cg1EdgeMap[key]) same = false;\n        });\n      }\n      if (same) {\n        candidateGraphs.splice(j, 1);\n      }\n    }\n    currentLength = candidateGraphs.length;\n  }\n\n  return candidateGraphs;\n};\n\nexport default GADDI;\n","export const ALGORITHM = {\n  pageRank: 'pageRank',\n  breadthFirstSearch: 'breadthFirstSearch',\n  connectedComponent: 'connectedComponent',\n  depthFirstSearch: 'depthFirstSearch',\n  detectCycle: 'detectCycle',\n  dijkstra: 'dijkstra',\n  findAllPath: 'findAllPath',\n  findShortestPath: 'findShortestPath',\n  floydWarshall: 'floydWarshall',\n  getAdjMatrix: 'getAdjMatrix',\n  getDegree: 'getDegree',\n  getInDegree: 'getInDegree',\n  getNeighbors: 'getNeighbors',\n  getOutDegree: 'getOutDegree',\n  labelPropagation: 'labelPropagation',\n  louvain: 'louvain',\n  GADDI: 'GADDI',\n  minimumSpanningTree: 'minimumSpanningTree',\n  SUCCESS: 'SUCCESS',\n  FAILURE: 'FAILURE',\n};\n\nexport const MESSAGE = {\n  SUCCESS: 'SUCCESS',\n  FAILURE: 'FAILURE',\n};\n","import * as algorithm from './algorithm';\nimport { MESSAGE } from './constant';\n\nconst ctx: Worker = self as any;\n\ninterface Event {\n  type: string;\n  data: any;\n}\n\nctx.onmessage = (event: Event) => {\n  const { type, data } = event.data;\n  if (typeof algorithm[type] === 'function') {\n    const result = algorithm[type](...data);\n    ctx.postMessage({ type: MESSAGE.SUCCESS, data: result });\n    return;\n  }\n\n  ctx.postMessage({ type: MESSAGE.FAILURE });\n};\n\n// https://stackoverflow.com/questions/50210416/webpack-worker-loader-fails-to-compile-typescript-worker\nexport default null as any;\n"],"sourceRoot":""}