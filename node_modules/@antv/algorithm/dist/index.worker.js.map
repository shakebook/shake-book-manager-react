{"version":3,"sources":["webpack://Algorithm/webpack/bootstrap","webpack://Algorithm/webpack/runtime/define property getters","webpack://Algorithm/webpack/runtime/hasOwnProperty shorthand","webpack://Algorithm/webpack/runtime/make namespace object","webpack://Algorithm/./src/adjacent-matrix.ts","webpack://Algorithm/./src/structs/linked-list.ts","webpack://Algorithm/./src/structs/queue.ts","webpack://Algorithm/./src/util.ts","webpack://Algorithm/./src/bfs.ts","webpack://Algorithm/./src/connected-component.ts","webpack://Algorithm/./src/degree.ts","webpack://Algorithm/./src/dfs.ts","webpack://Algorithm/./src/detect-cycle.ts","webpack://Algorithm/./node_modules/_tslib@2.1.0@tslib/tslib.es6.js","webpack://Algorithm/../src/is-type.ts","webpack://Algorithm/../src/is-array.ts","webpack://Algorithm/../src/keys.ts","webpack://Algorithm/../src/pull.ts","webpack://Algorithm/../src/pull-at.ts","webpack://Algorithm/../src/group-by.ts","webpack://Algorithm/../src/is-integer.ts","webpack://Algorithm/../src/to-degree.ts","webpack://Algorithm/../src/to-integer.ts","webpack://Algorithm/../src/to-radian.ts","webpack://Algorithm/../src/values.ts","webpack://Algorithm/../src/is-prototype.ts","webpack://Algorithm/../src/clone.ts","webpack://Algorithm/../src/is-empty.ts","webpack://Algorithm/../src/pick.ts","webpack://Algorithm/../src/cache.ts","webpack://Algorithm/./src/dijkstra.ts","webpack://Algorithm/./src/find-path.ts","webpack://Algorithm/./src/floydWarshall.ts","webpack://Algorithm/./src/label-propagation.ts","webpack://Algorithm/./src/louvain.ts","webpack://Algorithm/./src/structs/union-find.ts","webpack://Algorithm/./src/structs/binary-heap.ts","webpack://Algorithm/./src/mts.ts","webpack://Algorithm/./src/pageRank.ts","webpack://Algorithm/./src/gSpan/struct.ts","webpack://Algorithm/./src/gSpan/gSpan.ts","webpack://Algorithm/./src/gaddi.ts","webpack://Algorithm/./src/workers/constant.ts","webpack://Algorithm/./src/workers/index.worker.ts"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","graphData","directed","nodes","edges","matrix","nodeMap","Error","forEach","node","i","id","push","edge","source","target","sIndex","tIndex","defaultComparator","a","b","next","this","toString","callback","comparator","head","tail","compare","prepend","newNode","LinkedListNode","append","delete","deleteNode","currentNode","find","undefined","deleteTail","deletedTail","deleteHead","deletedHead","fromArray","values","toArray","reverse","prevNode","nextNode","map","linkedList","isEmpty","peek","enqueue","dequeue","removeHead","nodeId","type","currentEdges","filter","getEdgesByNodeId","uniqueId","index","Math","random","split","substr","startNodeId","originalCallbacks","callbacks","seen","initiatedCallback","stubCallback","allowTraversalCallback","allowTraversal","enter","leave","initCallbacks","nodeQueue","previousNode","current","previous","nodeStack","inStack","indices","lowLink","allComponents","getComponent","neighbors","n","indexOf","targetNodeID","min","targetNode","length","component","tmpNode","pop","visited","neighbor","detectConnectedComponents","degree","degrees","inDegree","outDegree","getInDegree","getOutDegree","depthFirstSearchRecursive","depthFirstSearch","cycle","dfsParentMap","unvisitedSet","visitingSet","visitedSet","currentCycleNode","previousCycleNode","keys","__spreadArrays","s","il","arguments","r","Array","k","j","jl","create","rst","default_1","weightPropertyName","nodeIds","marks","D","prevs","Infinity","nodeNum","minNode","minDis","minVertex","minNodeId","getOutEdgesNodeId","edgeTarget","edgeSource","w","weight","allPaths","findAllPaths","path","foundPaths","paths","prevPaths","prePath","findShortestPath","start","end","allPath","findAllPath","isVisited","stack","children","child","shift","adjacentMatrix","dist","size","maxIteration","clusters","cid","clusterId","idx","adjMatrix","ks","row","iid","entry","jid","iter","changed","neighborClusters","neighborId","neighborWeight","neighborClusterId","maxWeight","bestClusterIds","selfClusterIdx","splice","selfCluster","nodeInSelfClusterIdx","randomIdx","floor","bestCluster","cluster","clusterEdges","clusterEdgeMap","sourceClusterId","targetClusterId","newEdgeId","count","newEdge","clustersArray","getModularity","m","param","modularity","clusteri","threshold","totalModularity","previousModularity","abs","sumTot","bestIncrease","commonParam","kiin","scNode","scNodeIdx","removeModurarity","nodeNeighborIds","neighborNodeId","neighborCluster","clusterNodes","neighborClusterKiin","cNode","cNodeIdx","increase","items","parent","item","union","rootA","rootB","connected","defaultCompare","compareFn","list","getLeft","getRight","getParent","top","delMin","bottom","moveDown","insert","moveUp","tmp","element","left","right","primMST","selectedEdges","currNode","Set","add","edgeQueue","currEdge","has","kruskalMST","weightEdges","sort","disjointSet","curEdge","algo","prim","kruskal","epsilon","linkProb","currentRank","distance","leakedRank","maxIterations","nodesCount","curRanks","prevRanks","nodeDegree","VACANT_NODE_LABEL","from","to","label","edgeMap","addEdge","edgeIdAutoIncrease","nodeLabelMap","edgeLabelMap","counter","getNodeNum","addNode","Node","Edge","rEdge","fromNode","toNode","fromNodeLabel","edgeLabel","toNodeLabel","nodeEdgeNodeLabel","nodeLabel1","nodeLabel2","equalTo","other","formNode","notEqualTo","rmpath","dfsEdgeList","aLength","pushBack","DFSedge","toGraph","graphId","graph","Graph","dfsEdge","fromNodeId","toNodeId","buildRmpath","oldFrom","fromNodeIdx","toNodeIdx","pdfs","his","nodesUsed","edgesUsed","e","preNode","hasNode","hasEdge","graphs","minSupport","minNodeNum","maxNodeNum","verbose","dfsCode","DFScode","support","frequentSize1Subgraphs","frequentSubgraphs","reportDF","findForwardRootEdges","result","findBackwardEdge","edge1","edge2","history","edge2ToEdges","edgeLength","findForwardPureEdges","rightmostEdge","minNodeLabel","rightmostEdgeToId","findForwardRmpathEdges","newToNodeLabel","getSupport","projected","graphMap","pro","findMinLabel","minLabel","isMin","console","log","dfsCodeMin","root","otherNode","projectIsMin","maxToC","backwardRoot","flag","newTo","p","History","backwardEdge","minBackwardEdgeLabel","forwardRoot","newFrom","forwardPureEdges","pathLength","forwardRmpathEdges","forwardMinEdgeNodeLabel","report","subGraphMining","generate1EdgeFrequentSubGraphs","nodeLabelCounter","nodeEdgeNodeCounter","nodeLableCounted","nodeEdgeNodeLabelCounted","nodeLabel","graphNodeKey","graphKey","graphNodeEdgeNodeKey","nodeEdgeNodeKey","g","run","DEFAULT_LABEL_NAME","findKNeighborUnits","spm","nodeLabelProp","units","findKNeighborUnit","unitNodeIdxs","labelCountMap","v","dists","nodeIdx","nodeIdxs","neighborNum","nodeLabelCountMap","getIntersectNeighborInducedGraph","nodePairMap","neighborUnits","cachedInducedGraphMap","pair","startUnitNodeIds","endUnitNodeIds","endSet","intersect","x","intersectIdMap","intersectLength","getMatchedCount","structure","edgeLabelProp","sourceLabel","targetLabel","strNodeLabel1","strNodeLabel2","strEdgeLabel","getNodeMaps","getEdgeMaps","sourceNode","getSpmMap","iId","jId","pattern","patternSpm","spmMap","patternSpmMap","patternNodeMap","patternNodeLabelMap","patternEdgeLabelMap","max","kNeighborUnits","patternKNeighborUnits","nodePairsMap","maxNodePairNum","nodePairNumEachNode","ceil","foundNodePairCount","unit","nodePairForICount","outerLoopCount","oidx","innerLoopCount","findNodePairsRandomly","intGMap","freStructures","params","formattedGraphs","fGraph","nodeIdxMap","sourceIdx","targetIdx","formatGraphs","calculator","GSpan","toGraphDatas","slice","structureNum","matchedCountMap","subStructureCount","structures","maxOffset","representClusterType","countMapI","sortedGraphKeys","totalCount","aveCount","aveIntraDist","aveCounts","graphsInCluster","aveIntraPerCluster","graphsNum","graphKey1","graph1Count","graphKey2","aveInterDist","aveCount1","aveCount2","offset","structureCountMap","findRepresentStructure","dsG","ndsDist","beginPNode","candidates","minPatternNodeLabelDegreeMap","patternIntGraphMap","patternNDSDist","patternNDSDistMap","patternSpDist","label2","maxDist","patternNodesWithLabel2","patternNodePairMap","nodeWithLabel2","currentPatternNDSDistArray","patternIntGraph","graphNeighborUnit","graphNeighborUnitCountMap","patternLabel2Num","prune2Invalid","cNodePairMap","neighborNode","currentNDSDistArray","intGraph","prune3Invalid","candidateGraphs","candidate","neighborNodes","unmatched","neighborLabel","distToCandidate","ndsToCandidate","node1","node2","spDist","cachedNDSMap","cachedInterInducedGraph","interInducedGraph","pairMap","getNDSDist","patternKey","minPatternNodeLabelDegree","patternNodeWithLabel","patternNodeDegree","concat","undirectedLengthsToBeginPNode","undirectedLengthsToBeginPNodeLabelMap","pLabel","candidateGraph","candidateNodeLabelCountMap","candidateNodeMap","q","cNodeLabel","candidateEdges","edgeLabelCountMap","pattenrEdgeLabelNum","prunedByEdgeLabel","candidateEdgeNum","candidateGraphInvalid","patternEdgesWithLabel","edgeMatched","patternEdge","patternSource","patternTarget","lengthsToCandidate","targetId","targetNodeLabel","nLabel","degreeChanged","loopCount","cgNode","y","cedge","currentLength","cg1","cg1EdgeMap","cg2","cg2EdgeMap","same","ctx","self","onmessage","event","data","postMessage"],"mappings":"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","file":"index.worker.js","sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { GraphData, Matrix } from \"./types\";\n\nconst adjMatrix = (graphData: GraphData, directed?: boolean) => {\n  const { nodes, edges } = graphData;\n  const matrix: Matrix[] = [];\n  // map node with index in data.nodes\n  const nodeMap: {\n    [key: string]: number;\n  } = {};\n\n  if (!nodes) {\n    throw new Error(\"invalid nodes data!\");\n  }\n\n  if (nodes) {\n    nodes.forEach((node, i) => {\n      nodeMap[node.id] = i;\n      const row: number[] = [];\n      matrix.push(row);\n    });\n  }\n\n  if (edges) {\n    edges.forEach((edge) => {\n      const { source, target } = edge;\n      const sIndex = nodeMap[source as string];\n      const tIndex = nodeMap[target as string];\n      if ((!sIndex && sIndex !== 0) || (!tIndex && tIndex !== 0)) return;\n      matrix[sIndex][tIndex] = 1;\n      if (!directed) {\n        matrix[tIndex][sIndex] = 1;\n      }\n    });\n  }\n  return matrix;\n};\n\nexport default adjMatrix;\n","const defaultComparator = (a, b) => {\n  if (a === b) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * 链表中单个元素节点\n */\nexport class LinkedListNode {\n  public value;\n\n  public next: LinkedListNode;\n\n  constructor(value, next: LinkedListNode = null) {\n    this.value = value;\n    this.next = next;\n  }\n\n  toString(callback?: any) {\n    return callback ? callback(this.value) : `${this.value}`;\n  }\n}\n\nexport default class LinkedList {\n  public head: LinkedListNode;\n\n  public tail: LinkedListNode;\n\n  public compare: Function;\n\n  constructor(comparator = defaultComparator) {\n    this.head = null;\n    this.tail = null;\n    this.compare = comparator;\n  }\n\n  /**\n   * 将指定元素添加到链表头部\n   * @param value\n   */\n  prepend(value) {\n    // 在头部添加一个节点\n    const newNode = new LinkedListNode(value, this.head);\n    this.head = newNode;\n\n    if (!this.tail) {\n      this.tail = newNode;\n    }\n\n    return this;\n  }\n\n  /**\n   * 将指定元素添加到链表中\n   * @param value\n   */\n  append(value) {\n    const newNode = new LinkedListNode(value);\n\n    // 如果不存在头节点，则将创建的新节点作为头节点\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n\n      return this;\n    }\n\n    // 将新节点附加到链表末尾\n    this.tail.next = newNode;\n    this.tail = newNode;\n\n    return this;\n  }\n\n  /**\n   * 删除指定元素\n   * @param value 要删除的元素\n   */\n  delete(value): LinkedListNode {\n    if (!this.head) {\n      return null;\n    }\n\n    let deleteNode = null;\n\n    // 如果删除的是头部元素，则将next作为头元素\n    while (this.head && this.compare(this.head.value, value)) {\n      deleteNode = this.head;\n      this.head = this.head.next;\n    }\n\n    let currentNode = this.head;\n\n    if (currentNode !== null) {\n      // 如果删除了节点以后，将next节点前移\n      while (currentNode.next) {\n        if (this.compare(currentNode.next.value, value)) {\n          deleteNode = currentNode.next;\n          currentNode.next = currentNode.next.next;\n        } else {\n          currentNode = currentNode.next;\n        }\n      }\n    }\n\n    // 检查尾部节点是否被删除\n    if (this.compare(this.tail.value, value)) {\n      this.tail = currentNode;\n    }\n\n    return deleteNode;\n  }\n\n  /**\n   * 查找指定的元素\n   * @param param0\n   */\n  find({ value = undefined, callback = undefined }): LinkedListNode {\n    if (!this.head) {\n      return null;\n    }\n\n    let currentNode = this.head;\n\n    while (currentNode) {\n      // 如果指定了 callback，则按指定的 callback 查找\n      if (callback && callback(currentNode.value)) {\n        return currentNode;\n      }\n\n      // 如果指定了 value，则按 value 查找\n      if (value !== undefined && this.compare(currentNode.value, value)) {\n        return currentNode;\n      }\n\n      currentNode = currentNode.next;\n    }\n\n    return null;\n  }\n\n  /**\n   * 删除尾部节点\n   */\n  deleteTail() {\n    const deletedTail = this.tail;\n\n    if (this.head === this.tail) {\n      // 链表中只有一个元素\n      this.head = null;\n      this.tail = null;\n      return deletedTail;\n    }\n\n    let currentNode = this.head;\n    while (currentNode.next) {\n      if (!currentNode.next.next) {\n        currentNode.next = null;\n      } else {\n        currentNode = currentNode.next;\n      }\n    }\n\n    this.tail = currentNode;\n\n    return deletedTail;\n  }\n\n  /**\n   * 删除头部节点\n   */\n  deleteHead() {\n    if (!this.head) {\n      return null;\n    }\n\n    const deletedHead = this.head;\n\n    if (this.head.next) {\n      this.head = this.head.next;\n    } else {\n      this.head = null;\n      this.tail = null;\n    }\n\n    return deletedHead;\n  }\n\n  /**\n   * 将一组元素转成链表中的节点\n   * @param values 链表中的元素\n   */\n  fromArray(values) {\n    values.forEach((value) => this.append(value));\n    return this;\n  }\n\n  /**\n   * 将链表中的节点转成数组元素\n   */\n  toArray() {\n    const nodes = [];\n\n    let currentNode = this.head;\n\n    while (currentNode) {\n      nodes.push(currentNode);\n      currentNode = currentNode.next;\n    }\n\n    return nodes;\n  }\n\n  /**\n   * 反转链表中的元素节点\n   */\n  reverse() {\n    let currentNode = this.head;\n    let prevNode = null;\n    let nextNode = null;\n    while (currentNode) {\n      // 存储下一个元素节点\n      nextNode = currentNode.next;\n\n      // 更改当前节点的下一个节点，以便将它连接到上一个节点上\n      currentNode.next = prevNode;\n\n      // 将 prevNode 和 currentNode 向前移动一步\n      prevNode = currentNode;\n      currentNode = nextNode;\n    }\n\n    this.tail = this.head;\n    this.head = prevNode;\n  }\n\n  toString(callback = undefined) {\n    return this.toArray()\n      .map((node) => node.toString(callback))\n      .toString();\n  }\n}\n","import LinkedList from './linked-list';\n\nexport default class Queue {\n  public linkedList: LinkedList;\n\n  constructor() {\n    this.linkedList = new LinkedList();\n  }\n\n  /**\n   * 队列是否为空\n   */\n  public isEmpty() {\n    return !this.linkedList.head;\n  }\n\n  /**\n   * 读取队列头部的元素， 不删除队列中的元素\n   */\n  public peek() {\n    if (!this.linkedList.head) {\n      return null;\n    }\n    return this.linkedList.head.value;\n  }\n\n  /**\n   * 在队列的尾部新增一个元素\n   * @param value\n   */\n  public enqueue(value) {\n    this.linkedList.append(value);\n  }\n\n  /**\n   * 删除队列中的头部元素，如果队列为空，则返回 null\n   */\n  public dequeue() {\n    const removeHead = this.linkedList.deleteHead();\n    return removeHead ? removeHead.value : null;\n  }\n\n  public toString(callback?: any) {\n    return this.linkedList.toString(callback);\n  }\n}\n","import { EdgeConfig, GraphData, Matrix } from './types'\n\n/**\n * 获取指定节点的所有邻居\n * @param nodeId 节点 ID\n * @param edges 图中的所有边数据\n * @param type 邻居类型\n */\nexport const getNeighbors = (nodeId: string, edges: EdgeConfig[] = [], type?: 'target' | 'source' | undefined): string[] => {\n  const currentEdges = edges.filter(edge => edge.source === nodeId || edge.target === nodeId)\n  if (type === 'target') {\n    // 当前节点为 source，它所指向的目标节点\n    const neighhborsConverter = (edge: EdgeConfig) => {\n      return edge.source === nodeId;\n    };\n    return currentEdges.filter(neighhborsConverter).map((edge) => edge.target);\n  }\n  if (type === 'source') {\n    // 当前节点为 target，它所指向的源节点\n    const neighhborsConverter = (edge: EdgeConfig) => {\n      return edge.target === nodeId;\n    };\n    return currentEdges.filter(neighhborsConverter).map((edge) => edge.source);\n  }\n\n  // 若未指定 type ，则返回所有邻居\n  const neighhborsConverter = (edge: EdgeConfig) => {\n    return edge.source === nodeId ? edge.target : edge.source;\n  };\n  return currentEdges.map(neighhborsConverter);\n}\n\n/**\n * 获取指定节点的出边\n * @param nodeId 节点 ID\n * @param edges 图中的所有边数据\n */\nexport const getOutEdgesNodeId = (nodeId: string, edges: EdgeConfig[]) => {\n  return edges.filter(edge => edge.source === nodeId)\n}\n\n/**\n * 获取指定节点的边，包括出边和入边\n * @param nodeId 节点 ID\n * @param edges 图中的所有边数据\n */\nexport const getEdgesByNodeId = (nodeId: string, edges: EdgeConfig[]) => {\n  return edges.filter(edge => edge.source === nodeId || edge.target === nodeId)\n}\n\n/**\n * 生成唯一的 ID，规则是序号 + 时间戳\n * @param index 序号\n */\nexport const uniqueId = (index: number = 0) => {\n  const random1 = `${Math.random()}`.split('.')[1].substr(0, 5);\n  const random2 = `${Math.random()}`.split('.')[1].substr(0, 5);\n  return `${index}-${random1}${random2}`\n};\n","import Queue from './structs/queue'\nimport { GraphData, IAlgorithmCallbacks } from './types';\nimport { getNeighbors } from './util';\n\n/**\n *\n * @param callbacks\n * allowTraversal: 确定 BFS 是否从顶点沿着边遍历到其邻居，默认情况下，同一个节点只能遍历一次\n * enterNode: 当 BFS 访问某个节点时调用\n * leaveNode: 当 BFS 访问访问结束某个节点时调用\n */\nfunction initCallbacks(callbacks: IAlgorithmCallbacks = {} as IAlgorithmCallbacks) {\n  const initiatedCallback = callbacks;\n\n  const stubCallback = () => {};\n\n  const allowTraversalCallback = (() => {\n    const seen = {};\n    return ({ next }) => {\n      const id = next;\n      if (!seen[id]) {\n        seen[id] = true;\n        return true;\n      }\n      return false;\n    };\n  })();\n\n  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;\n  initiatedCallback.enter = callbacks.enter || stubCallback;\n  initiatedCallback.leave = callbacks.leave || stubCallback;\n\n  return initiatedCallback;\n}\n\n/**\n * 广度优先遍历图\n * @param graph Graph 图实例\n * @param startNode 开始遍历的节点\n * @param originalCallbacks 回调\n */\nconst breadthFirstSearch = (\n  graphData: GraphData,\n  startNodeId: string,\n  originalCallbacks?: IAlgorithmCallbacks,\n) => {\n  const callbacks = initCallbacks(originalCallbacks);\n  const nodeQueue = new Queue();\n\n  const { edges = [] } = graphData\n\n  // 初始化队列元素\n  nodeQueue.enqueue(startNodeId);\n\n  let previousNode = '';\n\n  // 遍历队列中的所有顶点\n  while (!nodeQueue.isEmpty()) {\n    const currentNode: string = nodeQueue.dequeue();\n    callbacks.enter({\n      current: currentNode,\n      previous: previousNode,\n    });\n\n    // 将所有邻居添加到队列中以便遍历\n    getNeighbors(currentNode, edges, 'target').forEach((nextNode) => {\n      if (\n        callbacks.allowTraversal({\n          previous: previousNode,\n          current: currentNode,\n          next: nextNode,\n        })\n      ) {\n        nodeQueue.enqueue(nextNode);\n      }\n    });\n\n    callbacks.leave({\n      current: currentNode,\n      previous: previousNode,\n    });\n\n    // 下一次循环之前存储当前顶点\n    previousNode = currentNode;\n  }\n};\n\nexport default breadthFirstSearch;\n","import { GraphData, NodeConfig } from \"./types\";\nimport { getNeighbors } from \"./util\";\n\n/**\n * Generate all connected components for an undirected graph\n * @param graph\n */\nexport const detectConnectedComponents = (graphData: GraphData): NodeConfig[][] => {\n  const { nodes = [], edges = [] } = graphData\n  const allComponents: NodeConfig[][] = [];\n  const visited = {};\n  const nodeStack: NodeConfig[] = [];\n\n  const getComponent = (node: NodeConfig) => {\n    nodeStack.push(node);\n    visited[node.id] = true;\n    const neighbors = getNeighbors(node.id, edges);\n    for (let i = 0; i < neighbors.length; ++i) {\n      const neighbor = neighbors[i];\n      if (!visited[neighbor]) {\n        const targetNode = nodes.filter(node => node.id === neighbor)\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n      }\n    }\n  };\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!visited[node.id]) {\n      // 对于无向图进行dfs遍历，每一次调用后都得到一个连通分量\n      getComponent(node);\n      const component = [];\n      while (nodeStack.length > 0) {\n        component.push(nodeStack.pop());\n      }\n      allComponents.push(component);\n    }\n  }\n  return allComponents;\n}\n\n/**\n * Tarjan's Algorithm 复杂度  O(|V|+|E|)\n * For directed graph only\n * a directed graph is said to be strongly connected if \"every vertex is reachable from every other vertex\".\n * refer: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n * @param graph\n * @return a list of strongly connected components\n */\nexport const detectStrongConnectComponents = (graphData: GraphData): NodeConfig[][] => {\n  const { nodes = [], edges = [] } = graphData\n  const nodeStack: NodeConfig[] = [];\n  const inStack = {}; // 辅助判断是否已经在stack中，减少查找开销\n  const indices = {};\n  const lowLink = {};\n  const allComponents: NodeConfig[][] = [];\n  let index = 0;\n\n  const getComponent = (node: NodeConfig) => {\n    // Set the depth index for v to the smallest unused index\n    indices[node.id] = index;\n    lowLink[node.id] = index;\n    index += 1;\n    nodeStack.push(node);\n    inStack[node.id] = true;\n\n    // 考虑每个邻接点\n    const neighbors = getNeighbors(node.id, edges, 'target').filter((n) => nodes.map(node => node.id).indexOf(n) > -1);\n    for (let i = 0; i < neighbors.length; i++) {\n      const targetNodeID = neighbors[i];\n      if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {\n        const targetNode = nodes.filter(node => node.id === targetNodeID)\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n        // tree edge\n        lowLink[node.id] = Math.min(lowLink[node.id], lowLink[targetNodeID]);\n      } else if (inStack[targetNodeID]) {\n        // back edge, target node is in the current SCC\n        lowLink[node.id] = Math.min(lowLink[node.id], indices[targetNodeID]);\n      }\n    }\n\n    // If node is a root node, generate an SCC\n    if (lowLink[node.id] === indices[node.id]) {\n      const component = [];\n      while (nodeStack.length > 0) {\n        const tmpNode = nodeStack.pop();\n        inStack[tmpNode.id] = false;\n        component.push(tmpNode);\n        if (tmpNode === node) break;\n      }\n      if (component.length > 0) {\n        allComponents.push(component);\n      }\n    }\n  };\n\n  for (const node of nodes) {\n    if (!indices[node.id] && indices[node.id] !== 0) {\n      getComponent(node);\n    }\n  }\n\n  return allComponents;\n}\n\nexport default function getConnectedComponents(graphData: GraphData, directed?: boolean): NodeConfig[][] {\n  if (directed) return detectStrongConnectComponents(graphData);\n  return detectConnectedComponents(graphData);\n}\n","import { GraphData, DegreeType } from \"./types\";\n\nconst degree = (graphData: GraphData): DegreeType => {\n  const degrees: DegreeType = {};\n  const { nodes = [], edges = [] } = graphData\n\n  nodes.forEach((node) => {\n    degrees[node.id] = {\n      degree: 0,\n      inDegree: 0,\n      outDegree: 0,\n    };\n  });\n\n  edges.forEach((edge) => {\n    degrees[edge.source].degree++;\n    degrees[edge.source].outDegree++;\n    degrees[edge.target].degree++;\n    degrees[edge.target].inDegree++;\n  });\n\n  return degrees;\n};\n\nexport default degree;\n\n/**\n * 获取指定节点的入度\n * @param graphData 图数据\n * @param nodeId 节点ID\n */\nexport const getInDegree = (graphData: GraphData, nodeId: string) => {\n  const nodeDegree = degree(graphData)\n  if (nodeDegree[nodeId]) {\n    return degree(graphData)[nodeId].inDegree\n  }\n  return 0\n}\n\n/**\n * 获取指定节点的出度\n * @param graphData 图数据\n * @param nodeId 节点ID\n */\nexport const getOutDegree = (graphData: GraphData, nodeId: string) => {\n  const nodeDegree = degree(graphData)\n  if (nodeDegree[nodeId]) {\n    return degree(graphData)[nodeId].outDegree\n  }\n  return 0\n}\n","import { IAlgorithmCallbacks, GraphData } from './types'\nimport { getNeighbors } from './util'\n\nfunction initCallbacks(callbacks: IAlgorithmCallbacks = {} as IAlgorithmCallbacks) {\n  const initiatedCallback = callbacks;\n\n  const stubCallback = () => {};\n\n  const allowTraversalCallback = (() => {\n    const seen = {};\n    return ({ next }) => {\n      if (!seen[next]) {\n        seen[next] = true;\n        return true;\n      }\n      return false;\n    };\n  })();\n\n  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;\n  initiatedCallback.enter = callbacks.enter || stubCallback;\n  initiatedCallback.leave = callbacks.leave || stubCallback;\n\n  return initiatedCallback;\n}\n\n/**\n * @param {Graph} graph\n * @param {GraphNode} currentNode\n * @param {GraphNode} previousNode\n * @param {Callbacks} callbacks\n */\nfunction depthFirstSearchRecursive(\n  graphData: GraphData,\n  currentNode: string,\n  previousNode: string,\n  callbacks: IAlgorithmCallbacks,\n) {\n  callbacks.enter({\n    current: currentNode,\n    previous: previousNode,\n  });\n\n  const { edges = [] } = graphData\n\n  getNeighbors(currentNode, edges, 'target').forEach((nextNode) => {\n    if (\n      callbacks.allowTraversal({\n        previous: previousNode,\n        current: currentNode,\n        next: nextNode,\n      })\n    ) {\n      depthFirstSearchRecursive(graphData, nextNode, currentNode, callbacks);\n    }\n  });\n\n  callbacks.leave({\n    current: currentNode,\n    previous: previousNode,\n  });\n}\n\n/**\n * 深度优先遍历图\n * @param data GraphData 图数据\n * @param startNodeId 开始遍历的节点的 ID\n * @param originalCallbacks 回调\n */\nexport default function depthFirstSearch(\n  graphData: GraphData,\n  startNodeId: string,\n  callbacks?: IAlgorithmCallbacks,\n) {\n  depthFirstSearchRecursive(graphData, startNodeId, '', initCallbacks(callbacks));\n}\n","import dfs from './dfs';\nimport getConnectedComponents, { detectStrongConnectComponents } from './connected-component';\nimport { GraphData, IAlgorithmCallbacks, NodeConfig } from './types';\nimport { getNeighbors } from './util';\n\nconst detectDirectedCycle = (graphData: GraphData) => {\n  let cycle: {\n    [key: string]: string;\n  } = null;\n\n  const { nodes = [] } = graphData\n\n  const dfsParentMap = {};\n\n  // 所有没有被访问的节点集合\n  const unvisitedSet = {};\n\n  // 正在被访问的节点集合\n  const visitingSet = {};\n\n  // 所有已经被访问过的节点集合\n  const visitedSet = {};\n\n  // 初始化 unvisitedSet\n  nodes.forEach((node) => {\n    unvisitedSet[node.id] = node;\n  });\n\n  const callbacks: IAlgorithmCallbacks = {\n    enter: ({ current: currentNode, previous: previousNode }) => {\n      if (visitingSet[currentNode]) {\n        // 如果当前节点正在访问中，则说明检测到环路了\n        cycle = {};\n\n        let currentCycleNode = currentNode;\n        let previousCycleNode = previousNode;\n\n        while (previousCycleNode !== currentNode) {\n          cycle[currentCycleNode] = previousCycleNode;\n          currentCycleNode = previousCycleNode;\n          previousCycleNode = dfsParentMap[previousCycleNode];\n        }\n\n        cycle[currentCycleNode] = previousCycleNode;\n      } else {\n        // 如果不存在正在访问集合中，则将其放入正在访问集合，并从未访问集合中删除\n        visitingSet[currentNode] = currentNode;\n        delete unvisitedSet[currentNode];\n\n        // 更新 DSF parents 列表\n        dfsParentMap[currentNode] = previousNode;\n      }\n    },\n    leave: ({ current: currentNode }) => {\n      // 如果所有的节点的子节点都已经访问过了，则从正在访问集合中删除掉，并将其移入到已访问集合中，\n      // 同时也意味着当前节点的所有邻居节点都被访问过了\n      visitedSet[currentNode] = currentNode;\n      delete visitingSet[currentNode];\n    },\n    allowTraversal: ({ next: nextNode }) => {\n      // 如果检测到环路则需要终止所有进一步的遍历，否则会导致无限循环遍历\n      if (cycle) {\n        return false;\n      }\n\n      // 仅允许遍历没有访问的节点，visitedSet 中的都已经访问过了\n      return !visitedSet[nextNode];\n    },\n  };\n\n  // 开始遍历节点\n  while (Object.keys(unvisitedSet).length) {\n    // 从第一个节点开始进行 DFS 遍历\n    const firsetUnVisitedKey = Object.keys(unvisitedSet)[0];\n\n    dfs(graphData, firsetUnVisitedKey, callbacks);\n  }\n\n  return cycle;\n};\n\n/**\n * 检测无向图中的所有Base cycles\n * refer: https://www.codeproject.com/Articles/1158232/Enumerating-All-Cycles-in-an-Undirected-Graph\n * @param graph\n * @param nodeIds 节点 ID 的数组\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: INode}] 返回一组base cycles\n */\nexport const detectAllUndirectedCycle = (graphData: GraphData, nodeIds?: string[], include = true) => {\n  const allCycles = [];\n  const components = getConnectedComponents(graphData, false);\n\n  // loop through all connected components\n  for (const component of components) {\n    if (!component.length) continue;\n    const root = component[0];\n    const rootId = root.id;\n\n    const stack = [root];\n    const parent = { [rootId]: root };\n    const used = { [rootId]: new Set() };\n\n    // walk a spanning tree to find cycles\n    while (stack.length > 0) {\n      const curNode = stack.pop();\n      const curNodeId = curNode.id;\n      const neighbors = getNeighbors(curNodeId, graphData.edges);\n      for (let i = 0; i < neighbors.length; i += 1) {\n        const neighborId = neighbors[i];\n        const neighbor = graphData.nodes.find(node => node.id === neighborId)\n        // const neighborId = neighbor.get('id');\n        if (neighborId === curNodeId) {\n          // 自环\n          allCycles.push({ [neighborId]: curNode });\n        } else if (!(neighborId in used)) {\n          // visit a new node\n          parent[neighborId] = curNode;\n          stack.push(neighbor);\n          used[neighborId] = new Set([curNode]);\n        } else if (!used[curNodeId].has(neighbor)) {\n          // a cycle found\n          let cycleValid = true;\n          const cyclePath = [neighbor, curNode];\n          let p = parent[curNodeId];\n          while (used[neighborId].size && !used[neighborId].has(p)) {\n            cyclePath.push(p);\n            if (p === parent[p.id]) break;\n            else p = parent[p.id];\n          }\n          cyclePath.push(p);\n\n          if (nodeIds && include) {\n            // 如果有指定包含的节点\n            cycleValid = false;\n            if (cyclePath.findIndex((node) => nodeIds.indexOf(node.id) > -1) > -1) {\n              cycleValid = true;\n            }\n          } else if (nodeIds && !include) {\n            // 如果有指定不包含的节点\n            if (cyclePath.findIndex((node) => nodeIds.indexOf(node.id) > -1) > -1) {\n              cycleValid = false;\n            }\n          }\n\n          // 把 node list 形式转换为 cycle 的格式\n          if (cycleValid) {\n            const cycle = {};\n            for (let index = 1; index < cyclePath.length; index += 1) {\n              cycle[cyclePath[index - 1].id] = cyclePath[index];\n            }\n            if (cyclePath.length) {\n              cycle[cyclePath[cyclePath.length - 1].id] = cyclePath[0];\n            }\n            allCycles.push(cycle);\n          }\n\n          used[neighborId].add(curNode);\n        }\n      }\n    }\n  }\n\n  return allCycles;\n};\n\n/**\n * Johnson's algorithm, 时间复杂度 O((V + E)(C + 1))$ and space bounded by O(V + E)\n * refer: https://www.cs.tufts.edu/comp/150GA/homeworks/hw1/Johnson%2075.PDF\n * refer: https://networkx.github.io/documentation/stable/_modules/networkx/algorithms/cycles.html#simple_cycles\n * @param graph\n * @param nodeIds 节点 ID 的数组\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: INode}] 返回所有的 simple cycles\n */\nexport const detectAllDirectedCycle = (graphData: GraphData, nodeIds?: string[], include = true) => {\n  const path = []; // stack of nodes in current path\n  const blocked = new Set();\n  const B = []; // remember portions of the graph that yield no elementary circuit\n  const allCycles = [];\n  const idx2Node: {\n    [key: string]: NodeConfig;\n  } = {};\n  const node2Idx = {};\n\n  // 辅助函数： unblock all blocked nodes\n  const unblock = (thisNode: NodeConfig) => {\n    const stack = [thisNode];\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (blocked.has(node)) {\n        blocked.delete(node);\n        B[node.id].forEach((n) => {\n          stack.push(n);\n        });\n        B[node.id].clear();\n      }\n    }\n  };\n\n  const circuit = (node: NodeConfig, start: NodeConfig, adjList) => {\n    let closed = false; // whether a path is closed\n    if (nodeIds && include === false && nodeIds.indexOf(node.id) > -1) return closed;\n    path.push(node);\n    blocked.add(node);\n\n    const neighbors = adjList[node.id];\n    for (let i = 0; i < neighbors.length; i += 1) {\n      const neighbor = idx2Node[neighbors[i]];\n      if (neighbor === start) {\n        const cycle = {};\n        for (let index = 1; index < path.length; index += 1) {\n          cycle[path[index - 1].id] = path[index];\n        }\n        if (path.length) {\n          cycle[path[path.length - 1].id] = path[0];\n        }\n        allCycles.push(cycle);\n        closed = true;\n      } else if (!blocked.has(neighbor)) {\n        if (circuit(neighbor, start, adjList)) {\n          closed = true;\n        }\n      }\n    }\n\n    if (closed) {\n      unblock(node);\n    } else {\n      for (let i = 0; i < neighbors.length; i += 1) {\n        const neighbor = idx2Node[neighbors[i]];\n        if (!B[neighbor.id].has(node)) {\n          B[neighbor.id].add(node);\n        }\n      }\n    }\n    path.pop();\n    return closed;\n  };\n\n  const { nodes = [] } = graphData;\n\n  // Johnson's algorithm 要求给节点赋顺序，先按节点在数组中的顺序\n  for (let i = 0; i < nodes.length; i += 1) {\n    const node = nodes[i];\n    const nodeId = node.id;\n    node2Idx[nodeId] = i;\n    idx2Node[i] = node;\n  }\n  // 如果有指定包含的节点，则把指定节点排序在前，以便提早结束搜索\n  if (nodeIds && include) {\n    for (let i = 0; i < nodeIds.length; i++) {\n      const nodeId = nodeIds[i];\n      node2Idx[nodes[i].id] = node2Idx[nodeId];\n      node2Idx[nodeId] = 0;\n      idx2Node[0] = nodes.find(node => node.id === nodeId);\n      idx2Node[node2Idx[nodes[i].id]] = nodes[i];\n    }\n  }\n\n  // 返回 节点顺序 >= nodeOrder 的强连通分量的adjList\n  const getMinComponentAdj = (components: NodeConfig[][]) => {\n    let minCompIdx;\n    let minIdx = Infinity;\n\n    // Find least component and the lowest node\n    for (let i = 0; i < components.length; i += 1) {\n      const comp = components[i];\n      for (let j = 0; j < comp.length; j++) {\n        const nodeIdx = node2Idx[comp[j].id];\n        if (nodeIdx < minIdx) {\n          minIdx = nodeIdx;\n          minCompIdx = i;\n        }\n      }\n    }\n\n    const component = components[minCompIdx];\n    const adjList = [];\n    for (let i = 0; i < component.length; i += 1) {\n      const node = component[i];\n      adjList[node.id] = [];\n      for (const neighbor of getNeighbors(node.id, graphData.edges, 'target').filter((n) => component.map(c => c.id).indexOf(n) > -1)) {\n        // 对自环情况 (点连向自身) 特殊处理：记录自环，但不加入adjList\n        if (neighbor === node.id && !(include === false && nodeIds.indexOf(node.id) > -1)) {\n          allCycles.push({ [node.id]: node });\n        } else {\n          adjList[node.id].push(node2Idx[neighbor]);\n        }\n      }\n    }\n\n    return {\n      component,\n      adjList,\n      minIdx,\n    };\n  };\n\n  let nodeIdx = 0;\n  while (nodeIdx < nodes.length) {\n    const subgraphNodes = nodes.filter((n) => node2Idx[n.id] >= nodeIdx);\n    const sccs = detectStrongConnectComponents({ nodes: subgraphNodes, edges: graphData.edges }).filter(\n      (component) => component.length > 1,\n    );\n    if (sccs.length === 0) break;\n\n    const scc = getMinComponentAdj(sccs);\n    const { minIdx, adjList, component } = scc;\n    if (component.length > 1) {\n      component.forEach((node) => {\n        B[node.id] = new Set();\n      });\n      const startNode = idx2Node[minIdx];\n      // startNode 不在指定要包含的节点中，提前结束搜索\n      if (nodeIds && include && nodeIds.indexOf(startNode.id) === -1) return allCycles;\n      circuit(startNode, startNode, adjList);\n      nodeIdx = minIdx + 1;\n    } else {\n      break;\n    }\n  }\n  return allCycles;\n};\n\n/**\n * 查找图中所有满足要求的圈\n * @param graph\n * @param directed 是否为有向图\n * @param nodeIds 节点 ID 的数组，若不指定，则返回图中所有的圈\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: Node}] 包含所有环的数组，每个环用一个Object表示，其中key为节点id，value为该节点在环中指向的下一个节点\n */\nexport const detectAllCycles = (\n  graphData: GraphData,\n  directed?: boolean,\n  nodeIds?: string[],\n  include = true,\n) => {\n  if (directed) return detectAllDirectedCycle(graphData, nodeIds, include);\n  return detectAllUndirectedCycle(graphData, nodeIds, include);\n};\n\nexport default detectDirectedCycle;\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","var toString = {}.toString;\nvar isType = function (value, type) { return toString.call(value) === '[object ' + type + ']'; };\nexport default isType;\n//# sourceMappingURL=is-type.js.map","import isType from './is-type';\nexport default (function (value) {\n    return Array.isArray ?\n        Array.isArray(value) :\n        isType(value, 'Array');\n});\n//# sourceMappingURL=is-array.js.map","import each from './each';\nimport isFunction from './is-function';\nvar keys = Object.keys ? function (obj) { return Object.keys(obj); } : function (obj) {\n    var result = [];\n    each(obj, function (value, key) {\n        if (!(isFunction(obj) && key === 'prototype')) {\n            result.push(key);\n        }\n    });\n    return result;\n};\nexport default keys;\n//# sourceMappingURL=keys.js.map","var arrPrototype = Array.prototype;\nvar splice = arrPrototype.splice;\nvar indexOf = arrPrototype.indexOf;\nvar pull = function (arr) {\n    var values = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        values[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < values.length; i++) {\n        var value = values[i];\n        var fromIndex = -1;\n        while ((fromIndex = indexOf.call(arr, value)) > -1) {\n            splice.call(arr, fromIndex, 1);\n        }\n    }\n    return arr;\n};\nexport default pull;\n//# sourceMappingURL=pull.js.map","import isArrayLike from './is-array-like';\nvar splice = Array.prototype.splice;\nvar pullAt = function pullAt(arr, indexes) {\n    if (!isArrayLike(arr)) {\n        return [];\n    }\n    var length = arr ? indexes.length : 0;\n    var last = length - 1;\n    while (length--) {\n        var previous = void 0;\n        var index = indexes[length];\n        if (length === last || index !== previous) {\n            previous = index;\n            splice.call(arr, index, 1);\n        }\n    }\n    return arr;\n};\nexport default pullAt;\n//# sourceMappingURL=pull-at.js.map","import isArray from './is-array';\nimport isFunction from './is-function';\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction groupBy(data, condition) {\n    if (!condition || !isArray(data)) {\n        return {};\n    }\n    var result = {};\n    // 兼容方法和 字符串的写法\n    var predicate = isFunction(condition) ? condition : function (item) { return item[condition]; };\n    var key;\n    for (var i = 0; i < data.length; i++) {\n        var item = data[i];\n        key = predicate(item);\n        if (hasOwnProperty.call(result, key)) {\n            result[key].push(item);\n        }\n        else {\n            result[key] = [item];\n        }\n    }\n    return result;\n}\nexport default groupBy;\n//# sourceMappingURL=group-by.js.map","import isNumber from './is-number';\nvar isInteger = Number.isInteger ? Number.isInteger : function (num) {\n    return isNumber(num) && num % 1 === 0;\n};\nexport default isInteger;\n//# sourceMappingURL=is-integer.js.map","var DEGREE = 180 / Math.PI;\nvar toDegree = function (radian) {\n    return DEGREE * radian;\n};\nexport default toDegree;\n//# sourceMappingURL=to-degree.js.map","export default parseInt;\n//# sourceMappingURL=to-integer.js.map","var RADIAN = Math.PI / 180;\nvar toRadian = function (degree) {\n    return RADIAN * degree;\n};\nexport default toRadian;\n//# sourceMappingURL=to-radian.js.map","import each from './each';\nimport isFunction from './is-function';\n// @ts-ignore\nvar values = Object.values ? function (obj) { return Object.values(obj); } : function (obj) {\n    var result = [];\n    each(obj, function (value, key) {\n        if (!(isFunction(obj) && key === 'prototype')) {\n            result.push(value);\n        }\n    });\n    return result;\n};\nexport default values;\n//# sourceMappingURL=values.js.map","var objectProto = Object.prototype;\nvar isPrototype = function (value) {\n    var Ctor = value && value.constructor;\n    var proto = (typeof Ctor === 'function' && Ctor.prototype) || objectProto;\n    return value === proto;\n};\nexport default isPrototype;\n//# sourceMappingURL=is-prototype.js.map","import isArray from './is-array';\nvar clone = function (obj) {\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n    var rst;\n    if (isArray(obj)) {\n        rst = [];\n        for (var i = 0, l = obj.length; i < l; i++) {\n            if (typeof obj[i] === 'object' && obj[i] != null) {\n                rst[i] = clone(obj[i]);\n            }\n            else {\n                rst[i] = obj[i];\n            }\n        }\n    }\n    else {\n        rst = {};\n        for (var k in obj) {\n            if (typeof obj[k] === 'object' && obj[k] != null) {\n                rst[k] = clone(obj[k]);\n            }\n            else {\n                rst[k] = obj[k];\n            }\n        }\n    }\n    return rst;\n};\nexport default clone;\n//# sourceMappingURL=clone.js.map","import isNil from './is-nil';\nimport isArrayLike from './is-array-like';\nimport getType from './get-type';\nimport isPrototype from './is-prototype';\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction isEmpty(value) {\n    /**\n     * isEmpty(null) => true\n     * isEmpty() => true\n     * isEmpty(true) => true\n     * isEmpty(1) => true\n     * isEmpty([1, 2, 3]) => false\n     * isEmpty('abc') => false\n     * isEmpty({ a: 1 }) => false\n     */\n    if (isNil(value)) {\n        return true;\n    }\n    if (isArrayLike(value)) {\n        return !value.length;\n    }\n    var type = getType(value);\n    if (type === 'Map' || type === 'Set') {\n        return !value.size;\n    }\n    if (isPrototype(value)) {\n        return !Object.keys(value).length;\n    }\n    for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nexport default isEmpty;\n//# sourceMappingURL=is-empty.js.map","import each from './each';\nimport isPlainObject from './is-plain-object';\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport default (function (object, keys) {\n    if (object === null || !isPlainObject(object)) {\n        return {};\n    }\n    var result = {};\n    each(keys, function (key) {\n        if (hasOwnProperty.call(object, key)) {\n            result[key] = object[key];\n        }\n    });\n    return result;\n});\n//# sourceMappingURL=pick.js.map","/**\n * k-v 存储\n */\nvar default_1 = /** @class */ (function () {\n    function default_1() {\n        this.map = {};\n    }\n    default_1.prototype.has = function (key) {\n        return this.map[key] !== undefined;\n    };\n    default_1.prototype.get = function (key, def) {\n        var v = this.map[key];\n        return v === undefined ? def : v;\n    };\n    default_1.prototype.set = function (key, value) {\n        this.map[key] = value;\n    };\n    default_1.prototype.clear = function () {\n        this.map = {};\n    };\n    default_1.prototype.delete = function (key) {\n        delete this.map[key];\n    };\n    default_1.prototype.size = function () {\n        return Object.keys(this.map).length;\n    };\n    return default_1;\n}());\nexport default default_1;\n//# sourceMappingURL=cache.js.map","import { isArray } from '@antv/util';\nimport { GraphData, NodeConfig, EdgeConfig } from './types';\nimport { getOutEdgesNodeId, getEdgesByNodeId } from './util';\n\nconst minVertex = (\n  D: { [key: string]: number },\n  nodes: NodeConfig[],\n  marks: { [key: string]: boolean },\n): NodeConfig => {\n  // 找出最小的点\n  let minDis = Infinity;\n  let minNode;\n  for (let i = 0; i < nodes.length; i++) {\n    const nodeId = nodes[i].id;\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\n      minDis = D[nodeId];\n      minNode = nodes[i];\n    }\n  }\n  return minNode;\n};\n\nconst dijkstra = (\n  graphData: GraphData,\n  source: string,\n  directed?: boolean,\n  weightPropertyName?: string,\n) => {\n  const { nodes = [], edges = [] } = graphData;\n  const nodeIds = [];\n  const marks = {};\n  const D = {};\n  const prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\n  nodes.forEach((node, i) => {\n    const id = node.id;\n    nodeIds.push(id);\n    D[id] = Infinity;\n    if (id === source) D[id] = 0;\n  });\n\n  const nodeNum = nodes.length;\n  for (let i = 0; i < nodeNum; i++) {\n    // Process the vertices\n    const minNode = minVertex(D, nodes, marks);\n    const minNodeId = minNode.id;\n    marks[minNodeId] = true;\n\n    if (D[minNodeId] === Infinity) continue; // Unreachable vertices cannot be the intermediate point\n\n    let relatedEdges: EdgeConfig[] = [];\n    if (directed) relatedEdges = getOutEdgesNodeId(minNodeId, edges);\n    else relatedEdges = getEdgesByNodeId(minNodeId, edges);\n\n    relatedEdges.forEach(edge => {\n      const edgeTarget = edge.target;\n      const edgeSource = edge.source;\n      const w = edgeTarget === minNodeId ? edgeSource : edgeTarget;\n      const weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;\n      if (D[w] > D[minNode.id] + weight) {\n        D[w] = D[minNode.id] + weight;\n        prevs[w] = [minNode.id];\n      } else if (D[w] === D[minNode.id] + weight) {\n        prevs[w].push(minNode.id);\n      }\n    });\n  }\n\n  prevs[source] = [source];\n  // 每个节点存可能存在多条最短路径\n  const allPaths = {};\n  for (const target in D) {\n    if (D[target] !== Infinity) {\n      findAllPaths(source, target, prevs, allPaths);\n    }\n  }\n\n  // 兼容之前单路径\n  const path = {};\n  for (const target in allPaths) {\n    path[target] = allPaths[target][0];\n  }\n  return { length: D, path, allPaths };\n};\n\nexport default dijkstra;\n\nfunction findAllPaths(source, target, prevs, foundPaths) {\n  if (source === target) {\n    return [source];\n  }\n  if (foundPaths[target]) {\n    return foundPaths[target];\n  }\n  const paths = [];\n  for (let prev of prevs[target]) {\n    const prevPaths = findAllPaths(source, prev, prevs, foundPaths);\n    if (!prevPaths) return;\n    for (let prePath of prevPaths) {\n      if (isArray(prePath)) paths.push([...prePath, target]);\n      else paths.push([prePath, target]);\n    }\n  }\n  foundPaths[target] = paths;\n  return foundPaths[target];\n}\n","import dijkstra from './dijkstra';\nimport { GraphData } from './types';\nimport { getNeighbors } from './util';\n\nexport const findShortestPath = (\n  graphData: GraphData,\n  start: string,\n  end: string,\n  directed?: boolean,\n  weightPropertyName?: string\n) => {\n  const { length, path, allPaths } = dijkstra(\n    graphData,\n    start,\n    directed,\n    weightPropertyName\n  );\n  return { length: length[end], path: path[end], allPath: allPaths[end] };\n};\n\nexport const findAllPath = (\n  graphData: GraphData,\n  start: string,\n  end: string,\n  directed?: boolean\n) => {\n  if (start === end) return [[start]];\n\n  const { edges = [] } = graphData;\n\n  const visited = [start];\n  const isVisited = { [start]: true };\n  const stack: string[][] = []; // 辅助栈，用于存储访问过的节点的邻居节点\n  const allPaths = [];\n  let neighbors = directed\n    ? getNeighbors(start, edges, 'target')\n    : getNeighbors(start, edges);\n  stack.push(neighbors);\n\n  while (visited.length > 0 && stack.length > 0) {\n    const children = stack[stack.length - 1];\n    if (children.length) {\n      const child = children.shift();\n      if (child) {\n        visited.push(child);\n        isVisited[child] = true;\n        neighbors = directed\n          ? getNeighbors(child, edges, 'target')\n          : getNeighbors(child, edges);\n        stack.push(neighbors.filter(neighbor => !isVisited[neighbor]));\n      }\n    } else {\n      const node = visited.pop();\n      isVisited[node] = false;\n      stack.pop();\n      continue;\n    }\n\n    if (visited[visited.length - 1] === end) {\n      const path = visited.map(node => node);\n      allPaths.push(path);\n\n      const node = visited.pop();\n      isVisited[node] = false;\n      stack.pop();\n    }\n  }\n\n  return allPaths;\n};\n","import getAdjMatrix from \"./adjacent-matrix\";\nimport { GraphData, Matrix } from \"./types\";\n\nconst floydWarshall = (graphData: GraphData, directed?: boolean) => {\n  const adjacentMatrix = getAdjMatrix(graphData, directed);\n\n  const dist: Matrix[] = [];\n  const size = adjacentMatrix.length;\n  for (let i = 0; i < size; i += 1) {\n    dist[i] = [];\n    for (let j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjacentMatrix[i][j] === 0 || !adjacentMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjacentMatrix[i][j];\n      }\n    }\n  }\n  // floyd\n  for (let k = 0; k < size; k += 1) {\n    for (let i = 0; i < size; i += 1) {\n      for (let j = 0; j < size; j += 1) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n  return dist;\n};\n\nexport default floydWarshall;\n","\nimport getAdjMatrix from './adjacent-matrix'\nimport { uniqueId } from './util';\nimport { GraphData, ClusterData } from './types';\n\n/**\n * 标签传播算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param maxIteration 最大迭代次数\n */\nconst labelPropagation = (\n  graphData: GraphData,\n  directed: boolean = false,\n  weightPropertyName: string = 'weight',\n  maxIteration: number = 1000\n): ClusterData => {\n  // the origin data\n  const { nodes = [], edges = [] } = graphData;\n\n  const clusters = {};\n  const nodeMap = {};\n  // init the clusters and nodeMap\n  nodes.forEach((node, i) => {\n    const cid: string = uniqueId();\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node,\n      idx: i\n    };\n  });\n\n  // the adjacent matrix of calNodes inside clusters\n  const adjMatrix = getAdjMatrix(graphData, directed);\n  // the sum of each row in adjacent matrix\n  const ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n  const neighbors = {};\n  adjMatrix.forEach((row, i) => {\n    let k = 0;\n    const iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach((entry, j) => {\n      if (!entry) return;\n      k += entry;\n      const jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n    });\n    ks.push(k);\n  });\n\n  let iter = 0;\n\n  while (iter < maxIteration) {\n    let changed = false;\n    nodes.forEach(node => {\n      const neighborClusters = {};\n      Object.keys(neighbors[node.id]).forEach(neighborId => {\n        const neighborWeight = neighbors[node.id][neighborId];\n        const neighborNode = nodeMap[neighborId].node;\n        const neighborClusterId = neighborNode.clusterId;\n        if (!neighborClusters[neighborClusterId]) neighborClusters[neighborClusterId] = 0;\n        neighborClusters[neighborClusterId] += neighborWeight;\n      });\n      // find the cluster with max weight\n      let maxWeight = -Infinity;\n      let bestClusterIds = [];\n      Object.keys(neighborClusters).forEach(clusterId => {\n        if (maxWeight < neighborClusters[clusterId]) {\n          maxWeight = neighborClusters[clusterId];\n          bestClusterIds = [clusterId];\n        } else if (maxWeight === neighborClusters[clusterId]) {\n          bestClusterIds.push(clusterId);\n        }\n      });\n      if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId) return;\n      const selfClusterIdx = bestClusterIds.indexOf(node.clusterId);\n      if (selfClusterIdx >= 0) bestClusterIds.splice(selfClusterIdx, 1);\n      if (bestClusterIds && bestClusterIds.length) {\n        changed = true;\n\n        // remove from origin cluster\n        const selfCluster = clusters[node.clusterId as string];\n        const nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);\n\n        // move the node to the best cluster\n        const randomIdx = Math.floor(Math.random() * bestClusterIds.length);\n        const bestCluster = clusters[bestClusterIds[randomIdx]];\n        bestCluster.nodes.push(node);\n        node.clusterId = bestCluster.id;\n      }\n    });\n    if (!changed) break;\n    iter++;\n  }\n\n  // delete the empty clusters\n  Object.keys(clusters).forEach(clusterId => {\n    const cluster = clusters[clusterId];\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n    }\n  });\n\n  // get the cluster edges\n  const clusterEdges = [];\n  const clusterEdgeMap = {};\n  edges.forEach(edge => {\n    const { source, target } = edge;\n    const weight = edge[weightPropertyName] || 1;\n    const sourceClusterId = nodeMap[source].node.clusterId;\n    const targetClusterId = nodeMap[target].node.clusterId;\n    const newEdgeId = `${sourceClusterId}---${targetClusterId}`;\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      const newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n\n  const clustersArray = [];\n  Object.keys(clusters).forEach(clusterId => {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges\n  }\n}\n\nexport default labelPropagation;\n","import getAdjMatrix from './adjacent-matrix'\nimport { uniqueId } from './util';\nimport { NodeConfig, ClusterData, GraphData } from './types';\n\nconst getModularity = (\n  nodes: NodeConfig[],\n  adjMatrix: number[][],\n  ks: number[],\n  m: number\n) => {\n  const length = adjMatrix.length;\n  const param = 2 * m;\n  let modularity = 0;\n  for (let i = 0; i < length; i++) {\n    const clusteri = nodes[i].clusterId;\n    for (let j = 0; j < length; j++) {\n      const clusterj = nodes[j].clusterId;\n      if (clusteri !== clusterj) continue;\n      const entry = adjMatrix[i][j] || 0;\n      const ki = ks[i] || 0;\n      const kj = ks[j] || 0;\n      modularity += (entry - ki * kj / param);\n    }\n  }\n  modularity *= (1 / param);\n  return modularity;\n}\n\n/**\n * 社区发现 louvain 算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param threshold \n */\nconst louvain = (\n  graphData: GraphData,\n  directed: boolean = false,\n  weightPropertyName: string = 'weight',\n  threshold: number = 0.0001\n): ClusterData => {\n  // the origin data\n  const { nodes = [], edges = [] } = graphData;\n\n  const clusters = {};\n  const nodeMap = {};\n  // init the clusters and nodeMap\n  nodes.forEach((node, i) => {\n    const cid: string = uniqueId();\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node,\n      idx: i\n    };\n  });\n\n  // the adjacent matrix of calNodes inside clusters\n  const adjMatrix = getAdjMatrix(graphData, directed);\n  // the sum of each row in adjacent matrix\n  const ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n  const neighbors = {};\n  // the sum of the weights of all edges in the graph\n  let m = 0;\n  adjMatrix.forEach((row, i) => {\n    let k = 0;\n    const iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach((entry, j) => {\n      if (!entry) return;\n      k += entry;\n      const jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n      m += entry;\n    });\n    ks.push(k);\n  });\n\n  m /= 2;\n\n  let totalModularity = Infinity;\n  let previousModularity = Infinity;\n  let iter = 0;\n\n  while (true) {\n    // whether to terminate the iterations\n    totalModularity = getModularity(nodes, adjMatrix, ks, m);\n    if (Math.abs(totalModularity - previousModularity) < threshold || iter > 100) break;\n    previousModularity = totalModularity;\n    iter++;\n\n    // pre compute some values for current clusters\n    Object.keys(clusters).forEach(clusterId => {\n      // sum of weights of edges to nodes in cluster\n      let sumTot = 0;\n      edges.forEach(edge => {\n        const { source, target } = edge;\n        const sourceClusterId = nodeMap[source].node.clusterId;\n        const targetClusterId = nodeMap[target].node.clusterId;\n        if ((sourceClusterId === clusterId && targetClusterId !== clusterId)\n          || (targetClusterId === clusterId && sourceClusterId !== clusterId)) {\n          sumTot = sumTot + (edge[weightPropertyName] as number || 1);\n        }\n      });\n      clusters[clusterId].sumTot = sumTot;\n    });\n\n\n    // move the nodes to increase the delta modularity\n    nodes.forEach((node, i) => {\n      const selfCluster = clusters[node.clusterId as string];\n      let bestIncrease = 0;\n      let bestCluster;\n\n      const commonParam = ks[i] / (2 * m);\n\n      // sum of weights of edges from node to nodes in cluster\n      let kiin = 0;\n      const selfClusterNodes = selfCluster.nodes;\n      selfClusterNodes.forEach(scNode => {\n        const scNodeIdx = nodeMap[scNode.id].idx;\n        kiin += adjMatrix[i][scNodeIdx] || 0;\n      });\n      // the modurarity for **removing** the node i from the origin cluster of node i\n      const removeModurarity = kiin - selfCluster.sumTot * commonParam;\n\n      // the neightbors of the node\n      const nodeNeighborIds = neighbors[node.id];\n      Object.keys(nodeNeighborIds).forEach(neighborNodeId => {\n        const neighborNode = nodeMap[neighborNodeId].node\n        const neighborClusterId = neighborNode.clusterId;\n\n        // if the node and the neighbor of node are in the same cluster, reutrn\n        if (neighborClusterId === node.clusterId) return;\n        const neighborCluster = clusters[neighborClusterId];\n        const clusterNodes = neighborCluster.nodes;\n\n        // if the cluster is empty, remove the cluster and return\n        if (!clusterNodes || !clusterNodes.length) return;\n\n        // sum of weights of edges from node to nodes in cluster\n        let neighborClusterKiin = 0;\n        clusterNodes.forEach(cNode => {\n          const cNodeIdx = nodeMap[cNode.id].idx;\n          neighborClusterKiin += adjMatrix[i][cNodeIdx] || 0;\n        });\n\n        // modurarity for **adding** node i into this neighbor cluster\n        const addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam;\n\n        // the increase modurarity is the difference between addModurarity and removeModurarity\n        const increase = addModurarity - removeModurarity;\n\n        // find the best cluster to move node i into\n        if (increase > bestIncrease) {\n          bestIncrease = increase;\n          bestCluster = neighborCluster;\n        }\n      });\n\n      // if found a best cluster to move into\n      if (bestIncrease > 0) {\n        bestCluster.nodes.push(node);\n        const previousClusterId = node.clusterId;\n        node.clusterId = bestCluster.id;\n        // move the node to the best cluster\n        const nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        // remove from origin cluster\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);\n        // update sumTot for clusters\n        // sum of weights of edges to nodes in cluster\n        let neighborClusterSumTot = 0;\n        let selfClusterSumTot = 0;\n        edges.forEach(edge => {\n          const { source, target } = edge;\n          const sourceClusterId = nodeMap[source].node.clusterId;\n          const targetClusterId = nodeMap[target].node.clusterId;\n          if ((sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id)\n            || (targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id)) {\n            neighborClusterSumTot = neighborClusterSumTot + (edge[weightPropertyName] as number || 1);\n          }\n          if ((sourceClusterId === previousClusterId && targetClusterId !== previousClusterId)\n            || (targetClusterId === previousClusterId && sourceClusterId !== previousClusterId)) {\n            selfClusterSumTot = selfClusterSumTot + (edge[weightPropertyName] as number || 1);\n          }\n        });\n\n        // the nodes of the clusters to move into and remove are changed, update their sumTot\n        bestCluster.sumTot = neighborClusterSumTot;\n        selfCluster.sumTot = selfClusterSumTot;\n      }\n    });\n  }\n\n  // delete the empty clusters\n  Object.keys(clusters).forEach(clusterId => {\n    const cluster = clusters[clusterId];\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n    }\n  });\n\n  // get the cluster edges\n  const clusterEdges = [];\n  const clusterEdgeMap = {};\n  edges.forEach(edge => {\n    const { source, target } = edge;\n    const weight = edge[weightPropertyName] || 1;\n    const sourceClusterId = nodeMap[source].node.clusterId;\n    const targetClusterId = nodeMap[target].node.clusterId;\n    const newEdgeId = `${sourceClusterId}---${targetClusterId}`;\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      const newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n\n  const clustersArray = [];\n  Object.keys(clusters).forEach(clusterId => {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges\n  }\n}\n\nexport default louvain;\n","/**\n * 并查集 Disjoint set to support quick union\n */\nexport default class UnionFind {\n  count: number;\n\n  parent: {};\n\n  constructor(items: (number | string)[]) {\n    this.count = items.length;\n    this.parent = {};\n    for (const i of items) {\n      this.parent[i] = i;\n    }\n  }\n\n  // find the root of the item\n  find(item) {\n    while (this.parent[item] !== item) {\n      item = this.parent[item];\n    }\n    return item;\n  }\n\n  union(a, b) {\n    const rootA = this.find(a);\n    const rootB = this.find(b);\n\n    if (rootA === rootB) return;\n\n    // make the element with smaller root the parent\n    if (rootA < rootB) {\n      if (this.parent[b] !== b) this.union(this.parent[b], a);\n      this.parent[b] = this.parent[a];\n    } else {\n      if (this.parent[a] !== a) this.union(this.parent[a], b);\n      this.parent[a] = this.parent[b];\n    }\n  }\n\n  // whether a and b are connected, i.e. a and b have the same root\n  connected(a, b) {\n    return this.find(a) === this.find(b);\n  }\n}\n","const defaultCompare = (a, b) => {\n  return a - b;\n};\n\nexport default class MinBinaryHeap {\n  list: any[];\n\n  compareFn: (a: any, b: any) => number;\n\n  constructor(compareFn = defaultCompare) {\n    this.compareFn = compareFn;\n    this.list = [];\n  }\n\n  getLeft(index) {\n    return 2 * index + 1;\n  }\n\n  getRight(index) {\n    return 2 * index + 2;\n  }\n\n  getParent(index) {\n    if (index === 0) {\n      return null;\n    }\n    return Math.floor((index - 1) / 2);\n  }\n\n  isEmpty() {\n    return this.list.length <= 0;\n  }\n\n  top() {\n    return this.isEmpty() ? undefined : this.list[0];\n  }\n\n  delMin() {\n    const top = this.top();\n    const bottom = this.list.pop();\n    if (this.list.length > 0) {\n      this.list[0] = bottom;\n      this.moveDown(0);\n    }\n    return top;\n  }\n\n  insert(value) {\n    if (value !== null) {\n      this.list.push(value);\n      const index = this.list.length - 1;\n      this.moveUp(index);\n      return true;\n    }\n    return false;\n  }\n\n  moveUp(index) {\n    let parent = this.getParent(index);\n    while (index && index > 0 && this.compareFn(this.list[parent], this.list[index]) > 0) {\n      // swap\n      const tmp = this.list[parent];\n      this.list[parent] = this.list[index];\n      this.list[index] = tmp;\n      // [this.list[index], this.list[parent]] = [this.list[parent], this.list[index]]\n      index = parent;\n      parent = this.getParent(index);\n    }\n  }\n\n  moveDown(index) {\n    let element = index;\n    const left = this.getLeft(index);\n    const right = this.getRight(index);\n    const size = this.list.length;\n    if (left !== null && left < size && this.compareFn(this.list[element], this.list[left]) > 0) {\n      element = left;\n    } else if (\n      right !== null &&\n      right < size &&\n      this.compareFn(this.list[element], this.list[right]) > 0\n    ) {\n      element = right;\n    }\n    if (index !== element) {\n      [this.list[index], this.list[element]] = [this.list[element], this.list[index]];\n      this.moveDown(element);\n    }\n  }\n}\n","import UnionFind from './structs/union-find';\nimport MinBinaryHeap from './structs/binary-heap';\nimport { GraphData, EdgeConfig } from './types';\nimport { getEdgesByNodeId } from './util';\n\n/**\n * Prim algorithm，use priority queue，复杂度 O(E+V*logV), V: 节点数量，E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n */\nconst primMST = (graphData: GraphData, weight?: string) => {\n  const selectedEdges = [];\n  const { nodes = [], edges = [] } = graphData;\n  if (nodes.length === 0) {\n    return selectedEdges;\n  }\n\n  // 从nodes[0]开始\n  const currNode = nodes[0];\n  const visited = new Set();\n  visited.add(currNode);\n\n  // 用二叉堆维护距已加入节点的其他节点的边的权值\n  const compareWeight = (a: EdgeConfig, b: EdgeConfig) => {\n    if (weight) {\n      return a.weight - b.weight;\n    }\n    return 0;\n\n  };\n  const edgeQueue = new MinBinaryHeap(compareWeight);\n  getEdgesByNodeId(currNode.id, edges).forEach((edge) => {\n    edgeQueue.insert(edge);\n  });\n\n  while (!edgeQueue.isEmpty()) {\n    // 选取与已加入的结点之间边权最小的结点\n    const currEdge: EdgeConfig = edgeQueue.delMin();\n    const source = currEdge.source;\n    const target = currEdge.target;\n    if (visited.has(source) && visited.has(target)) continue;\n    selectedEdges.push(currEdge);\n\n    if (!visited.has(source)) {\n      visited.add(source);\n      getEdgesByNodeId(source, edges).forEach((edge) => {\n        edgeQueue.insert(edge);\n      });\n    }\n    if (!visited.has(target)) {\n      visited.add(target);\n      getEdgesByNodeId(target, edges).forEach((edge) => {\n        edgeQueue.insert(edge);\n      });\n    }\n  }\n  return selectedEdges;\n};\n\n/**\n * Kruskal algorithm，复杂度 O(E*logE), E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @return IEdge[] 返回构成MST的边的数组\n */\nconst kruskalMST = (graphData: GraphData, weight?: string): EdgeConfig[] => {\n  const selectedEdges = [];\n  const { nodes = [], edges = [] } = graphData\n  if (nodes.length === 0) {\n    return selectedEdges;\n  }\n\n  // 若指定weight，则将所有的边按权值从小到大排序\n  const weightEdges = edges.map((edge) => edge);\n  if (weight) {\n    weightEdges.sort((a, b) => {\n      return a.weight - b.weight;\n    });\n  }\n  const disjointSet = new UnionFind(nodes.map((n) => n.id));\n\n  // 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边\n  // 直到遍历完所有点或边\n  while (weightEdges.length > 0) {\n    const curEdge = weightEdges.shift();\n    const source = curEdge.source;\n    const target = curEdge.target;\n    if (!disjointSet.connected(source, target)) {\n      selectedEdges.push(curEdge);\n      disjointSet.union(source, target);\n    }\n  }\n  return selectedEdges;\n};\n\n/**\n * 最小生成树\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @param algo 'prim' | 'kruskal' 算法类型\n * @return EdgeConfig[] 返回构成MST的边的数组\n */\nconst minimumSpanningTree = (graphData: GraphData, weight?: string, algo?: string): EdgeConfig[] => {\n  const algos = {\n    prim: primMST,\n    kruskal: kruskalMST,\n  };\n  if (!algo) return kruskalMST(graphData, weight);\n\n  return algos[algo](graphData, weight);\n}\n\nexport default minimumSpanningTree\n","import { GraphData } from \"./types\";\nimport degree from './degree'\nimport { getNeighbors } from \"./util\";\n\n/**\n * PageRank https://en.wikipedia.org/wiki/PageRank\n * refer: https://github.com/anvaka/ngraph.pagerank\n * @param graph \n * @param epsilon 判断是否收敛的精度值，默认 0.000001\n * @param linkProb 阻尼系数（dumping factor），指任意时刻，用户访问到某节点后继续访问该节点链接的下一个节点的概率，经验值 0.85\n */\nconst pageRank = (graphData: GraphData, epsilon?: number, linkProb?: number): {\n  [key: string]: number;\n} => {\n  if (typeof epsilon !== 'number') epsilon = 0.000001;\n  if (typeof linkProb !== 'number') linkProb = 0.85;\n\n  let distance = 1;\n  let leakedRank = 0;\n  let maxIterations = 1000;\n\n  const { nodes = [], edges = [] } = graphData;\n  const nodesCount = nodes.length;\n  let currentRank;\n  const curRanks = {};\n  const prevRanks = {}\n\n  // Initialize pageranks 初始化\n  for (let j = 0; j < nodesCount; ++j) {\n    const node = nodes[j];\n    const nodeId = node.id;\n    curRanks[nodeId] = (1 / nodesCount)\n    prevRanks[nodeId] = (1 / nodesCount)\n  }\n\n  const nodeDegree = degree(graphData)\n  while (maxIterations > 0 && distance > epsilon) {\n    leakedRank = 0;\n    for (let j = 0; j < nodesCount; ++j) {\n      const node = nodes[j];\n      const nodeId = node.id;\n      currentRank = 0;\n      if (nodeDegree[node.id].inDegree === 0) {\n        curRanks[nodeId] = 0;\n      } else {\n        const neighbors = getNeighbors(nodeId, edges, 'source');\n        for (let i = 0; i < neighbors.length; ++i) {\n          const neighbor = neighbors[i];\n          const outDegree: number = nodeDegree[neighbor].outDegree;\n          if (outDegree > 0) currentRank += (prevRanks[neighbor] / outDegree);\n        }\n        curRanks[nodeId] = linkProb * currentRank;\n        leakedRank += curRanks[nodeId];\n      }\n    }\n\n    leakedRank = (1 - leakedRank) / nodesCount;\n    distance = 0;\n    for (let j = 0; j < nodesCount; ++j) {\n      const node = nodes[j];\n      const nodeId = node.id;\n      currentRank = curRanks[nodeId] + leakedRank;\n      distance += Math.abs(currentRank - prevRanks[nodeId]);\n      prevRanks[nodeId] = currentRank;\n    }\n    maxIterations -= 1\n  }\n\n  return prevRanks;\n}\n\nexport default pageRank\n","import { indexOf } from \"@antv/util\";\n\nexport const VACANT_EDGE_ID = -1;\nexport const VACANT_NODE_ID = -1;\nexport const VACANT_EDGE_LABEL = \"-1\";\nexport const VACANT_NODE_LABEL = \"-1\";\nexport const VACANT_GRAPH_ID = -1;\nexport const AUTO_EDGE_ID = \"-1\";\n\nexport class Edge {\n  public id: number;\n  public from: number;\n  public to: number;\n  public label: string;\n\n  constructor(\n    id = VACANT_EDGE_ID,\n    from = VACANT_NODE_ID,\n    to = VACANT_NODE_ID,\n    label = VACANT_EDGE_LABEL\n  ) {\n    this.id = id;\n    this.from = from;\n    this.to = to;\n    this.label = label;\n  }\n}\n\nexport class Node {\n  public id: number;\n  public from: number;\n  public to: number;\n  public label: string;\n  public edges: Edge[];\n  public edgeMap: {};\n\n  constructor(id = VACANT_NODE_ID, label = VACANT_NODE_LABEL) {\n    this.id = id;\n    this.label = label;\n    this.edges = [];\n    this.edgeMap = {};\n  }\n\n  addEdge(edge) {\n    this.edges.push(edge);\n    this.edgeMap[edge.id] = edge;\n  }\n}\n\nexport class Graph {\n  public id: number;\n  public from: number;\n  public to: number;\n  public label: string;\n  public edgeIdAutoIncrease: boolean;\n  public nodes: Node[];\n  public edges: Edge[];\n  public nodeMap: {};\n  public edgeMap: {};\n  public nodeLabelMap: {}; // key 是 label，value 是节点 id 的数组\n  public edgeLabelMap: {};\n  private counter: number; // 自增用于自动生成边 id\n  public directed: boolean;\n\n  constructor(\n    id = VACANT_NODE_ID,\n    edgeIdAutoIncrease = true,\n    directed = false\n  ) {\n    this.id = id;\n    this.edgeIdAutoIncrease = edgeIdAutoIncrease;\n    this.edges = [];\n    this.nodes = [];\n    this.nodeMap = {};\n    this.edgeMap = {};\n    this.nodeLabelMap = {};\n    this.edgeLabelMap = {};\n    this.counter = 0;\n    this.directed = directed;\n  }\n\n  getNodeNum() {\n    return this.nodes.length;\n  }\n\n  addNode(id: number, label: string) {\n    if (this.nodeMap[id]) return;\n    const node = new Node(id, label);\n    this.nodes.push(node);\n    this.nodeMap[id] = node;\n    if (!this.nodeLabelMap[label]) this.nodeLabelMap[label] = [];\n    this.nodeLabelMap[label].push(id);\n  }\n\n  addEdge(id: number, from: number, to: number, label: string) {\n    if (this.edgeIdAutoIncrease || id === undefined) id = this.counter++;\n    if (this.nodeMap[from] && this.nodeMap[to] && this.nodeMap[to].edgeMap[id])\n      return;\n    const edge = new Edge(id, from, to, label);\n    this.edges.push(edge);\n    this.edgeMap[id] = edge;\n\n    this.nodeMap[from].addEdge(edge);\n\n    if (!this.edgeLabelMap[label]) this.edgeLabelMap[label] = [];\n    this.edgeLabelMap[label].push(edge);\n\n    if (!this.directed) {\n      const rEdge = new Edge(id, to, from, label);\n      this.nodeMap[to].addEdge(rEdge);\n      this.edgeLabelMap[label].push(rEdge);\n    }\n  }\n}\n","import { GraphData } from \"../types\";\nimport { clone } from \"@antv/util\";\nimport {\n  Graph,\n  Edge,\n  VACANT_NODE_LABEL,\n  VACANT_GRAPH_ID,\n  Node,\n  VACANT_EDGE_LABEL,\n} from \"./struct\";\n\nexport interface EdgeMap {\n  [key: string]: {\n    // key 的格式为 source-target\n    idx: number; // 该边在原图 graphData.edges 的序号\n    edge: any;\n  };\n}\n\nexport interface NodeMap {\n  [key: string]: {\n    // key 格式为 node.id\n    idx: number; // 该j客店在原图 graphData.nodes 的序号\n    node: any;\n    degree: number;\n  };\n}\n\ninterface PDFS {\n  graphId: number;\n  edge: any;\n  preNode: any;\n}\n\nclass DFSedge {\n  public fromNode: number;\n  public toNode: number;\n  public nodeEdgeNodeLabel: {\n    nodeLabel1: string;\n    edgeLabel: string;\n    nodeLabel2: string;\n  };\n\n  constructor(\n    fromNode: number,\n    toNode: number,\n    fromNodeLabel: string,\n    edgeLabel: string,\n    toNodeLabel: string\n  ) {\n    this.fromNode = fromNode;\n    this.toNode = toNode;\n    this.nodeEdgeNodeLabel = {\n      nodeLabel1: fromNodeLabel || VACANT_NODE_LABEL,\n      edgeLabel: edgeLabel || VACANT_EDGE_LABEL,\n      nodeLabel2: toNodeLabel || VACANT_NODE_LABEL,\n    };\n  }\n\n  equalTo(other) {\n    return (\n      this.fromNode === other.formNode &&\n      this.toNode === other.toNode &&\n      this.nodeEdgeNodeLabel === other.nodeEdgeNodeLabel\n    );\n  }\n\n  notEqualTo(other) {\n    return !this.equalTo(other);\n  }\n}\n\n// DFScode 是 DESedge 的数组\nclass DFScode {\n  public dfsEdgeList: DFSedge[];\n  public rmpath: any;\n\n  constructor() {\n    this.rmpath = [];\n    this.dfsEdgeList = [];\n  }\n\n  equalTo(other) {\n    const aLength = this.dfsEdgeList.length;\n    const bLength = other.length;\n    if (aLength !== bLength) return false;\n    for (let i = 0; i < aLength; i++) {\n      if (this.dfsEdgeList[i] !== other[i]) return false;\n    }\n    return true;\n  }\n\n  notEqualTo(other) {\n    return !this.equalTo(other);\n  }\n\n  /** 增加一条 edge 到 DFScode */\n  pushBack(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {\n    this.dfsEdgeList.push(\n      new DFSedge(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel)\n    );\n    return this.dfsEdgeList;\n  }\n\n  /** 根据 dfs 构建图 */\n  toGraph(graphId: number = VACANT_GRAPH_ID, directed = false) {\n    const graph = new Graph(graphId, true, directed);\n    this.dfsEdgeList.forEach((dfsEdge) => {\n      const fromNodeId = dfsEdge.fromNode;\n      const toNodeId = dfsEdge.toNode;\n      const { nodeLabel1, edgeLabel, nodeLabel2 } = dfsEdge.nodeEdgeNodeLabel;\n\n      if (nodeLabel1 !== VACANT_NODE_LABEL)\n        graph.addNode(fromNodeId, nodeLabel1);\n      if (nodeLabel2 !== VACANT_NODE_LABEL) graph.addNode(toNodeId, nodeLabel2);\n\n      graph.addEdge(undefined, fromNodeId, toNodeId, edgeLabel);\n    });\n    return graph;\n  }\n\n  // 建立 rightmost path\n  buildRmpath() {\n    this.rmpath = [];\n    let oldFrom = undefined;\n    const selfLength = this.dfsEdgeList.length;\n    for (let i = selfLength - 1; i >= 0; i--) {\n      const dfsEdge = this.dfsEdgeList[i];\n      const fromNodeIdx = dfsEdge.fromNode;\n      const toNodeIdx = dfsEdge.toNode;\n      if (\n        fromNodeIdx < toNodeIdx &&\n        (oldFrom === undefined || toNodeIdx === oldFrom)\n      ) {\n        this.rmpath.push(i);\n        oldFrom = fromNodeIdx;\n      }\n    }\n    return this.rmpath;\n  }\n\n  getNodeNum() {\n    const nodeMap = {};\n    this.dfsEdgeList.forEach((dfsEdge) => {\n      if (!nodeMap[dfsEdge.fromNode]) nodeMap[dfsEdge.fromNode] = true;\n      if (!nodeMap[dfsEdge.toNode]) nodeMap[dfsEdge.toNode] = true;\n    });\n    return Object.keys(nodeMap).length;\n  }\n}\n\nclass History {\n  public his: object;\n  public edges: Edge[];\n  public nodesUsed: object;\n  public edgesUsed: object;\n\n  constructor(pdfs: PDFS) {\n    this.his = {};\n    this.nodesUsed = {};\n    this.edgesUsed = {};\n    this.edges = [];\n    if (!pdfs) return;\n    while (pdfs) {\n      const e = pdfs.edge;\n      this.edges.push(e);\n      this.nodesUsed[e.from] = 1;\n      this.nodesUsed[e.to] = 1;\n      this.edgesUsed[e.id] = 1;\n      pdfs = pdfs.preNode;\n    }\n    // 倒序\n    this.edges = this.edges.reverse();\n  }\n\n  hasNode(node: Node) {\n    return this.nodesUsed[node.id] === 1;\n  }\n\n  hasEdge(edge: Edge) {\n    return this.edgesUsed[edge.id] === 1;\n  }\n}\n\ninterface Root {\n  [key: string]: {\n    projected: PDFS[];\n    nodeLabel1?: string;\n    edgeLabel?: string;\n    nodeLabel2?: string;\n    fromNodeId?: number;\n    toNodeId?: number;\n  };\n}\n\ninterface GraphDataMap {\n  [key: string]: GraphData;\n}\ninterface GraphMap {\n  [key: number]: Graph;\n}\n\ninterface AlgorithmProps {\n  graphs: GraphMap; // 图数据\n  minSupport: number; // 算法参数，最小支持数量，根据 graphs 内图的数量指定\n  directed?: boolean; // 是否有向图，默认为 false\n  minNodeNum?: number; // 每个子图中边的最少个数，默认为 1\n  maxNodeNum?: number; // 每个子图中边的最多个数，默认为 4\n  top?: number; // 返回前 top 个频繁子图，默认为 10\n  verbose?: boolean;\n}\n\nclass GSpan {\n  public graphs: GraphMap;\n  public dfsCode: DFScode;\n  public support: number;\n  public frequentSize1Subgraphs: GraphData[];\n  public frequentSubgraphs: Graph[];\n  public reportDF: [];\n  public maxNodeNum: number;\n  public minNodeNum: number;\n  public minSupport: number;\n  public top: number;\n  public directed: boolean;\n  private counter: number; // 用于生成图的 id，自增\n  public verbose: boolean;\n\n  constructor({\n    graphs,\n    minSupport = 2,\n    minNodeNum = 1,\n    maxNodeNum = 4,\n    top = 10,\n    directed = false,\n    verbose = false,\n  }: AlgorithmProps) {\n    // -------- 第零步，初始化-------\n    this.graphs = graphs;\n    this.dfsCode = new DFScode();\n    this.support = 0;\n    this.frequentSize1Subgraphs = [];\n    this.frequentSubgraphs = [];\n    this.minSupport = minSupport;\n    this.top = top;\n    this.directed = directed;\n    this.counter = 0;\n    // TODO? timestamp = {}\n    this.maxNodeNum = maxNodeNum;\n    this.minNodeNum = minNodeNum;\n    this.verbose = verbose;\n    if (this.maxNodeNum < this.minNodeNum) this.maxNodeNum = this.minNodeNum;\n    this.reportDF = []; // matrix\n  }\n\n  // Line 352\n  findForwardRootEdges(graph: Graph, fromNode: Node): Edge[] {\n    const result = [];\n    const nodeMap = graph.nodeMap;\n    fromNode.edges.forEach((edge) => {\n      if (this.directed || fromNode.label <= nodeMap[edge.to].label)\n        result.push(edge);\n    });\n\n    return result;\n  }\n\n  findBackwardEdge(\n    graph: Graph,\n    edge1: Edge,\n    edge2: Edge,\n    history: History\n  ): Edge {\n    if (!this.directed && edge1 === edge2) return null;\n    const nodeMap = graph.nodeMap;\n    const edge2To = nodeMap[edge2.to];\n    const edge2ToEdges = edge2To.edges;\n    const edgeLength = edge2ToEdges.length;\n    for (let i = 0; i < edgeLength; i++) {\n      const edge = edge2ToEdges[i];\n      if (history.hasEdge(edge) || edge.to !== edge1.from) continue;\n      if (!this.directed) {\n        if (\n          edge1.label < edge.label ||\n          (edge1.label === edge.label &&\n            nodeMap[edge1.to].label <= nodeMap[edge2.to].label)\n        ) {\n          return edge;\n        }\n      } else {\n        if (\n          nodeMap[edge1.from].label < nodeMap[edge2.to].label ||\n          (nodeMap[edge1.from].label === nodeMap[edge2.to].label &&\n            edge1.label <= edge.label)\n        ) {\n          return edge;\n        }\n      }\n    }\n    return null;\n  }\n\n  findForwardPureEdges(\n    graph,\n    rightmostEdge,\n    minNodeLabel,\n    history: History\n  ): Edge[] {\n    const result = [];\n    const rightmostEdgeToId = rightmostEdge.to;\n    const edges = graph.nodeMap[rightmostEdgeToId].edges;\n    const edgeLength = edges.length;\n    for (let i = 0; i < edgeLength; i++) {\n      const edge = edges[i];\n      const toNode = graph.nodeMap[edge.to];\n      if (minNodeLabel <= toNode.label && !history.hasNode(toNode)) {\n        result.push(edge);\n      }\n    }\n    return result;\n  }\n\n  findForwardRmpathEdges(\n    graph: Graph,\n    rightmostEdge: Edge,\n    minNodeLabel: string,\n    history: History\n  ): Edge[] {\n    const result = [];\n    const nodeMap = graph.nodeMap;\n    const toNodeLabel = nodeMap[rightmostEdge.to].label;\n    const fromNode = nodeMap[rightmostEdge.from];\n    const edges = fromNode.edges;\n    const edgeLength = edges.length;\n    for (let i = 0; i < edgeLength; i++) {\n      const edge = edges[i];\n      const newToNodeLabel = nodeMap[edge.to].label;\n      if (\n        rightmostEdge.to === edge.to ||\n        minNodeLabel > newToNodeLabel ||\n        history.hasNode(nodeMap[edge.to])\n      ) {\n        continue;\n      }\n      if (\n        rightmostEdge.label < edge.label ||\n        (rightmostEdge.label === edge.label && toNodeLabel <= newToNodeLabel)\n      ) {\n        result.push(edge);\n      }\n    }\n    return result;\n  }\n\n  getSupport(projected: PDFS[]): number {\n    const graphMap = {};\n    projected.forEach((pro) => {\n      if (!graphMap[pro.graphId]) graphMap[pro.graphId] = true;\n    });\n    return Object.keys(graphMap).length;\n  }\n\n  findMinLabel(\n    obj: Root\n  ): {\n    nodeLabel1?: string;\n    edgeLabel: string;\n    nodeLabel2?: string;\n  } {\n    let minLabel = undefined;\n    Object.keys(obj).forEach((nodeEdgeNodeLabel) => {\n      const { nodeLabel1, edgeLabel, nodeLabel2 } = obj[nodeEdgeNodeLabel];\n      if (!minLabel) {\n        minLabel = {\n          nodeLabel1,\n          edgeLabel,\n          nodeLabel2,\n        };\n        return;\n      }\n      if (\n        nodeLabel1 < minLabel.nodeLabel1 ||\n        (nodeLabel1 === minLabel.nodeLabel1 &&\n          edgeLabel < minLabel.edgeLabel) ||\n        (nodeLabel1 === minLabel.nodeLabel1 &&\n          edgeLabel === minLabel.edgeLabel &&\n          nodeLabel2 < minLabel.nodeLabel2)\n      ) {\n        minLabel = {\n          nodeLabel1,\n          edgeLabel,\n          nodeLabel2,\n        };\n      }\n    });\n    return minLabel;\n  }\n\n  isMin() {\n    const dfsCode = this.dfsCode;\n    if (this.verbose) console.log(\"isMin checking\", dfsCode);\n    if (dfsCode.dfsEdgeList.length === 1) return true;\n    const directed = this.directed;\n    const graph = dfsCode.toGraph(VACANT_GRAPH_ID, directed);\n    const nodeMap = graph.nodeMap;\n    const dfsCodeMin = new DFScode();\n    const root: Root = {};\n    graph.nodes.forEach((node) => {\n      const forwardEdges = this.findForwardRootEdges(graph, node);\n      forwardEdges.forEach((edge) => {\n        let otherNode = nodeMap[edge.to];\n        const nodeEdgeNodeLabel = `${node.label}-${edge.label}-${otherNode.label}`;\n        if (!root[nodeEdgeNodeLabel])\n          root[nodeEdgeNodeLabel] = {\n            projected: [],\n            nodeLabel1: node.label,\n            edgeLabel: edge.label,\n            nodeLabel2: otherNode.label,\n          };\n        const pdfs: PDFS = {\n          graphId: graph.id,\n          edge,\n          preNode: null,\n        };\n        root[nodeEdgeNodeLabel].projected.push(pdfs);\n      });\n    });\n\n    // 比较 root 中每一项的 nodeEdgeNodeLabel 大小，按照 nodeLabel1、edgeLabe、nodeLabel2 的顺序比较\n    let minLabel = this.findMinLabel(root); // line 419\n    dfsCodeMin.dfsEdgeList.push(\n      new DFSedge(\n        0,\n        1,\n        minLabel.nodeLabel1,\n        minLabel.edgeLabel,\n        minLabel.nodeLabel2\n      )\n    );\n\n    // line 423\n    const projectIsMin = (projected: PDFS[]) => {\n      // right most path\n      const rmpath = dfsCodeMin.buildRmpath();\n      const minNodeLabel =\n        dfsCodeMin.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;\n      const maxToC = dfsCodeMin.dfsEdgeList[rmpath[0]].toNode; // node id\n\n      const backwardRoot: Root = {};\n      let flag = false,\n        newTo = 0;\n      let end = directed ? -1 : 0; // 遍历到 1 还是到 0\n      for (let i = rmpath.length - 1; i > end; i--) {\n        if (flag) break;\n        // line 435\n        projected.forEach((p) => {\n          const history = new History(p);\n          const backwardEdge = this.findBackwardEdge(\n            graph,\n            history.edges[rmpath[i]],\n            history.edges[rmpath[0]],\n            history\n          );\n          if (backwardEdge) {\n            // Line 441\n            if (!backwardRoot[backwardEdge.label]) {\n              backwardRoot[backwardEdge.label] = {\n                projected: [],\n                edgeLabel: backwardEdge.label,\n              };\n            }\n            backwardRoot[backwardEdge.label].projected.push({\n              graphId: graph.id,\n              edge: backwardRoot,\n              preNode: p,\n            });\n            newTo = dfsCodeMin.dfsEdgeList[rmpath[i]].fromNode;\n            flag = true;\n          }\n        });\n      }\n\n      if (flag) {\n        const minBackwardEdgeLabel = this.findMinLabel(backwardRoot);\n        dfsCodeMin.dfsEdgeList.push(\n          new DFSedge(\n            maxToC,\n            newTo,\n            VACANT_NODE_LABEL,\n            minBackwardEdgeLabel.edgeLabel,\n            VACANT_NODE_LABEL\n          )\n        );\n        const idx = dfsCodeMin.dfsEdgeList.length - 1;\n        if (this.dfsCode.dfsEdgeList[idx] !== dfsCodeMin.dfsEdgeList[idx])\n          return false;\n        return projectIsMin(\n          backwardRoot[minBackwardEdgeLabel.edgeLabel].projected\n        );\n      }\n      const forwardRoot: Root = {};\n      flag = false;\n      let newFrom = 0;\n      projected.forEach((p) => {\n        const history = new History(p);\n        const forwardPureEdges = this.findForwardPureEdges(\n          graph,\n          history.edges[rmpath[0]],\n          minNodeLabel,\n          history\n        );\n        if (forwardPureEdges.length > 0) {\n          flag = true;\n          newFrom = maxToC;\n          forwardPureEdges.forEach((edge) => {\n            const key = `${edge.label}-${nodeMap[edge.to].label}`;\n            if (!forwardRoot[key])\n              forwardRoot[key] = {\n                projected: [],\n                edgeLabel: edge.label,\n                nodeLabel2: nodeMap[edge.to].label,\n              };\n            forwardRoot[key].projected.push({\n              graphId: graph.id,\n              edge,\n              preNode: p,\n            });\n          });\n        }\n      });\n\n      const pathLength = rmpath.length;\n      for (let i = 0; i < pathLength; i++) {\n        if (flag) break;\n        const value = rmpath[i];\n        projected.forEach((p) => {\n          const history = new History(p);\n          const forwardRmpathEdges = this.findForwardRmpathEdges(\n            graph,\n            history.edges[value],\n            minNodeLabel,\n            history\n          );\n          if (forwardRmpathEdges.length > 0) {\n            flag = true;\n            newFrom = dfsCodeMin.dfsEdgeList[value].fromNode;\n            forwardRmpathEdges.forEach((edge) => {\n              const key = `${edge.label}-${nodeMap[edge.to].label}`;\n              if (!forwardRoot[key])\n                forwardRoot[key] = {\n                  projected: [],\n                  edgeLabel: edge.label,\n                  nodeLabel2: nodeMap[edge.to].label,\n                };\n              forwardRoot[key].projected.push({\n                graphId: graph.id,\n                edge,\n                preNode: p,\n              });\n            });\n          }\n        });\n      }\n\n      if (!flag) return true;\n\n      const forwardMinEdgeNodeLabel = this.findMinLabel(forwardRoot);\n      dfsCodeMin.dfsEdgeList.push(\n        new DFSedge(\n          newFrom,\n          maxToC + 1,\n          VACANT_NODE_LABEL,\n          forwardMinEdgeNodeLabel.edgeLabel,\n          forwardMinEdgeNodeLabel.nodeLabel2\n        )\n      );\n      const idx = dfsCodeMin.dfsEdgeList.length - 1;\n      if (dfsCode.dfsEdgeList[idx] !== dfsCodeMin.dfsEdgeList[idx])\n        return false;\n      return projectIsMin(\n        forwardRoot[\n          `${forwardMinEdgeNodeLabel.edgeLabel}-${forwardMinEdgeNodeLabel.nodeLabel2}`\n        ].projected\n      );\n    };\n    const key = `${minLabel.nodeLabel1}-${minLabel.edgeLabel}-${minLabel.nodeLabel2}`;\n    return projectIsMin(root[key].projected);\n  }\n\n  report() {\n    if (this.dfsCode.getNodeNum() < this.minNodeNum) return;\n    this.counter++;\n    const graph = this.dfsCode.toGraph(this.counter, this.directed);\n    this.frequentSubgraphs.push(clone(graph));\n  }\n\n  subGraphMining(projected) {\n    const support = this.getSupport(projected);\n    if (support < this.minSupport) return;\n    if (!this.isMin()) return;\n    this.report();\n\n    const nodeNum = this.dfsCode.getNodeNum();\n    const rmpath = this.dfsCode.buildRmpath();\n    const maxToC = this.dfsCode.dfsEdgeList[rmpath[0]].toNode;\n    const minNodeLabel = this.dfsCode.dfsEdgeList[0].nodeEdgeNodeLabel\n      .nodeLabel1;\n\n    const forwardRoot: Root = {};\n    const backwardRoot: Root = {};\n\n    projected.forEach((p) => {\n      const graph = this.graphs[p.graphId];\n      const nodeMap = graph.nodeMap;\n      const history = new History(p);\n      // backward Line 526\n      for (let i = rmpath.length - 1; i >= 0; i--) {\n        const backwardEdge = this.findBackwardEdge(\n          graph,\n          history.edges[rmpath[i]],\n          history.edges[rmpath[0]],\n          history\n        );\n        if (backwardEdge) {\n          const key = `${this.dfsCode.dfsEdgeList[rmpath[i]].fromNode}-${\n            backwardEdge.label\n          }`;\n          if (!backwardRoot[key])\n            backwardRoot[key] = {\n              projected: [],\n              toNodeId: this.dfsCode.dfsEdgeList[rmpath[i]].fromNode,\n              edgeLabel: backwardEdge.label,\n            };\n          backwardRoot[key].projected.push({\n            graphId: p.graphId,\n            edge: backwardEdge,\n            preNode: p,\n          });\n        }\n      }\n\n      // pure forward\n      if (nodeNum >= this.maxNodeNum) return;\n      const forwardPureEdges = this.findForwardPureEdges(\n        graph,\n        history.edges[rmpath[0]],\n        minNodeLabel,\n        history\n      );\n      forwardPureEdges.forEach((edge) => {\n        const key = `${maxToC}-${edge.label}-${nodeMap[edge.to].label}`;\n        if (!forwardRoot[key])\n          forwardRoot[key] = {\n            projected: [],\n            fromNodeId: maxToC,\n            edgeLabel: edge.label,\n            nodeLabel2: nodeMap[edge.to].label,\n          };\n        forwardRoot[key].projected.push({\n          graphId: p.graphId,\n          edge,\n          preNode: p,\n        });\n      });\n\n      // rmpath forward\n      for (let i = 0; i < rmpath.length; i++) {\n        const forwardRmpathEdges = this.findForwardRmpathEdges(\n          graph,\n          history.edges[rmpath[i]],\n          minNodeLabel,\n          history\n        );\n        forwardRmpathEdges.forEach((edge) => {\n          const key = `${this.dfsCode.dfsEdgeList[rmpath[i]].fromNode}-${\n            edge.label\n          }-${nodeMap[edge.to].label}`;\n          if (!forwardRoot[key])\n            forwardRoot[key] = {\n              projected: [],\n              fromNodeId: this.dfsCode.dfsEdgeList[rmpath[i]].fromNode,\n              edgeLabel: edge.label,\n              nodeLabel2: nodeMap[edge.to].label,\n            };\n          forwardRoot[key].projected.push({\n            graphId: p.graphId,\n            edge,\n            preNode: p,\n          });\n        });\n      }\n    });\n\n    // backward\n    Object.keys(backwardRoot).forEach((key) => {\n      const { toNodeId, edgeLabel } = backwardRoot[key];\n      this.dfsCode.dfsEdgeList.push(\n        new DFSedge(maxToC, toNodeId, \"-1\", edgeLabel, \"-1\")\n      );\n      this.subGraphMining(backwardRoot[key].projected);\n      this.dfsCode.dfsEdgeList.pop();\n    });\n\n    // forward\n    Object.keys(forwardRoot).forEach((key) => {\n      const { fromNodeId, edgeLabel, nodeLabel2 } = forwardRoot[key];\n      this.dfsCode.dfsEdgeList.push(\n        new DFSedge(\n          fromNodeId,\n          maxToC + 1,\n          VACANT_NODE_LABEL,\n          edgeLabel,\n          nodeLabel2\n        )\n      );\n      this.subGraphMining(forwardRoot[key].projected);\n      this.dfsCode.dfsEdgeList.pop();\n    });\n  }\n\n  generate1EdgeFrequentSubGraphs() {\n    const graphs = this.graphs;\n    const directed = this.directed;\n    const minSupport = this.minSupport;\n    const frequentSize1Subgraphs = this.frequentSize1Subgraphs;\n    let nodeLabelCounter = {},\n      nodeEdgeNodeCounter = {};\n    // 保存各个图和各自节点的关系 map，key 格式为 graphKey-node类型\n    const nodeLableCounted = {};\n    // 保存各个图和各自边的关系 map，key 格式为 graphKey-fromNode类型-edge类型-toNode类型\n    const nodeEdgeNodeLabelCounted = {};\n    Object.keys(graphs).forEach((key) => {\n      // Line 271\n      const graph = graphs[key];\n      const nodeMap = graph.nodeMap;\n      // 遍历节点，记录对应图 与 每个节点的 label 到 nodeLableCounted\n      graph.nodes.forEach((node, i) => {\n        // Line 272\n        const nodeLabel = node.label;\n        const graphNodeKey = `${key}-${nodeLabel}`;\n        if (!nodeLableCounted[graphNodeKey]) {\n          let counter = nodeLabelCounter[nodeLabel] || 0;\n          counter++;\n          nodeLabelCounter[nodeLabel] = counter;\n        }\n        nodeLableCounted[graphNodeKey] = {\n          graphKey: key,\n          label: nodeLabel,\n        };\n        // 遍历该节点的所有边，记录各个图和各自边的关系到 nodeEdgeNodeLabelCounted. Line 276\n        node.edges.forEach((edge) => {\n          let nodeLabel1 = nodeLabel;\n          let nodeLabel2 = nodeMap[edge.to].label;\n          if (!directed && nodeLabel1 > nodeLabel2) {\n            const tmp = nodeLabel2;\n            nodeLabel2 = nodeLabel1;\n            nodeLabel1 = tmp;\n          }\n          const edgeLabel = edge.label;\n\n          const graphNodeEdgeNodeKey = `${key}-${nodeLabel1}-${edgeLabel}-${nodeLabel2}`;\n          const nodeEdgeNodeKey = `${nodeLabel1}-${edgeLabel}-${nodeLabel2}`;\n\n          if (!nodeEdgeNodeCounter[nodeEdgeNodeKey]) {\n            let counter = nodeEdgeNodeCounter[nodeEdgeNodeKey] || 0;\n            counter++;\n            nodeEdgeNodeCounter[nodeEdgeNodeKey] = counter; // Line281\n          }\n          nodeEdgeNodeLabelCounted[graphNodeEdgeNodeKey] = {\n            graphId: key,\n            nodeLabel1,\n            edgeLabel,\n            nodeLabel2,\n          };\n        });\n      });\n    });\n\n    // 计算频繁的节点\n    Object.keys(nodeLabelCounter).forEach((label) => {\n      const count = nodeLabelCounter[label];\n      if (count < minSupport) return;\n      const g = { nodes: [], edges: [] };\n      g.nodes.push({\n        id: \"0\",\n        label,\n      });\n      frequentSize1Subgraphs.push(g);\n      // if (minNodeNum <= 1) reportSize1 TODO\n    });\n\n    return frequentSize1Subgraphs;\n  }\n\n  run() {\n    // -------- 第一步, _generate_1edge_frequent_subgraphs：频繁的单个节点-------\n    this.frequentSize1Subgraphs = this.generate1EdgeFrequentSubGraphs();\n\n    if (this.maxNodeNum < 2) return;\n\n    const graphs = this.graphs;\n    const directed = this.directed;\n\n    // PDFS 数组的 map Line 304\n    const root: Root = {};\n    Object.keys(graphs).forEach((graphId: any) => {\n      const graph = graphs[graphId];\n      const nodeMap = graph.nodeMap;\n      // Line 306\n      graph.nodes.forEach((node) => {\n        const forwardRootEdges = this.findForwardRootEdges(graph, node);\n        // Line 308\n        forwardRootEdges.forEach((edge) => {\n          let toNode = nodeMap[edge.to];\n          const nodeEdgeNodeLabel = `${node.label}-${edge.label}-${toNode.label}`;\n          if (!root[nodeEdgeNodeLabel])\n            root[nodeEdgeNodeLabel] = {\n              projected: [],\n              nodeLabel1: node.label as string,\n              edgeLabel: edge.label as string,\n              nodeLabel2: toNode.label as string,\n            };\n          const pdfs: PDFS = {\n            graphId,\n            edge,\n            preNode: null,\n          };\n          root[nodeEdgeNodeLabel].projected.push(pdfs);\n        });\n      });\n    });\n\n    // Line 313\n    Object.keys(root).forEach((nodeEdgeNodeLabel) => {\n      const { projected, nodeLabel1, edgeLabel, nodeLabel2 } = root[\n        nodeEdgeNodeLabel\n      ];\n\n      this.dfsCode.dfsEdgeList.push(\n        new DFSedge(0, 1, nodeLabel1, edgeLabel, nodeLabel2)\n      );\n      this.subGraphMining(projected);\n      this.dfsCode.dfsEdgeList.pop();\n    });\n  }\n}\n\nconst formatGraphs = (\n  graphs: GraphDataMap,\n  directed: boolean,\n  nodeLabelProp: string,\n  edgeLabelProp: string\n): GraphMap => {\n  const result: { [key: number]: Graph } = {};\n  Object.keys(graphs).forEach((key, i) => {\n    const graph = graphs[key];\n    const fGraph = new Graph(i, true, directed);\n    const nodeIdxMap = {};\n    graph.nodes.forEach((node, j) => {\n      fGraph.addNode(j, node[nodeLabelProp]);\n      nodeIdxMap[node.id] = j;\n    });\n    graph.edges.forEach((edge, k) => {\n      const sourceIdx = nodeIdxMap[edge.source];\n      const targetIdx = nodeIdxMap[edge.target];\n      fGraph.addEdge(-1, sourceIdx, targetIdx, edge[edgeLabelProp]);\n    });\n    if (fGraph && fGraph.getNodeNum()) result[fGraph.id] = fGraph;\n  });\n  return result;\n};\n\nconst toGraphDatas = (\n  graphs: Graph[],\n  nodeLabelProp: string,\n  edgeLabelProp: string\n) => {\n  const result = [];\n  graphs.forEach((graph) => {\n    const graphData = { nodes: [], edges: [] };\n    graph.nodes.forEach((node) => {\n      graphData.nodes.push({\n        id: `${node.id}`,\n        [nodeLabelProp]: node.label,\n      });\n    });\n    graph.edges.forEach((edge) => {\n      graphData.edges.push({\n        source: `${edge.from}`,\n        target: `${edge.to}`,\n        [edgeLabelProp]: edge.label,\n      });\n    });\n    result.push(graphData);\n  });\n  return result;\n};\n\ninterface Props {\n  graphs: GraphDataMap; // 图数据\n  minSupport: number; // 算法参数，最小支持数量，根据 graphs 内图的数量指定\n  directed?: boolean; // 是否有向图，默认为 false\n  nodeLabelProp?: string; // 节点类型的属性名\n  edgeLabelProp?: string; // 边类型的属性名\n  minNodeNum?: number; // 每个子图中节点的最少个数，默认为 1\n  maxNodeNum?: number; // 每个子图中节点的最多个数，默认为 4\n  top?: number; // 返回前 top 个频繁子图，默认为 10\n  verbose?: boolean;\n}\n\nconst DEFAULT_LABEL_NAME = \"cluster\";\n\n/**\n * gSpan 频繁子图计算算法（frequent graph mining）\n * @param params 参数\n */\nconst gSpan = (params: Props): GraphData[] => {\n  // ------- 将图数据 GraphData 的 map 转换为格式 -------\n  const {\n    graphs,\n    directed = false,\n    nodeLabelProp = DEFAULT_LABEL_NAME,\n    edgeLabelProp = DEFAULT_LABEL_NAME,\n  } = params;\n  const formattedGraphs = formatGraphs(\n    graphs,\n    directed,\n    nodeLabelProp,\n    edgeLabelProp\n  );\n  const { minSupport, maxNodeNum, minNodeNum, verbose, top } = params;\n\n  // ------- 初始化与执行算法 -------\n  const algoParams = {\n    graphs: formattedGraphs,\n    minSupport,\n    maxNodeNum,\n    minNodeNum,\n    top,\n    verbose,\n    directed,\n  };\n  const calculator = new GSpan(algoParams);\n  calculator.run();\n\n  const result = toGraphDatas(\n    calculator.frequentSubgraphs,\n    nodeLabelProp,\n    edgeLabelProp\n  );\n  return result;\n};\n\nexport default gSpan;\n","import floydWarshall from './floydWarshall';\nimport { GraphData, Matrix } from './types';\nimport gSpan, { EdgeMap, NodeMap } from './gSpan/gSpan';\nimport dijkstra from './dijkstra';\nimport { uniqueId } from './util';\n\n/** 节点对 map */\ninterface NodePairMap {\n  [key: string]: {\n    // key 的格式为 startNodeIdx-endNodeIdx\n    start: number; // 第一个节点的 idx\n    end: number; // 第二个节点的 idx\n    distance: number; // 两节点最短路径长度\n  };\n}\n\ninterface LabelMap {\n  [label: string]: any;\n}\n\n/** 邻居单元类型 */\ninterface NeighborUnit {\n  nodeId: string;\n  nodeIdx: number;\n  nodeIdxs: number[]; // the first one is nodeIdx\n  neighbors: any[]; //\n  neighborNum: number;\n  nodeLabelCountMap: {\n    [label: string]: {\n      count: number;\n      dists: number[]; // 按照从小到大排序的距离数组\n    };\n  };\n}\n\n/** 节点对的邻居交集的诱导子图 map */\ninterface InterGraphMap {\n  [key: string]: GraphData; // key 格式由节点对的 idx 组成：beginIdx-endIdx，和 nodePairMap 对应\n}\n\n/**\n * 为 graphData 中每个节点生成邻居单元数组\n * @param graphData\n * @param spm\n * @param nodeLabelProp\n * @param k k-近邻\n */\nconst findKNeighborUnits = (\n  graphData: GraphData,\n  spm: Matrix[],\n  nodeLabelProp: string = 'cluster',\n  k: number = 2,\n): NeighborUnit[] => {\n  const units: NeighborUnit[] = [];\n  const nodes = graphData.nodes;\n  spm.forEach((row: number[], i) => {\n    units.push(findKNeighborUnit(nodes, row, i, nodeLabelProp, k));\n  });\n  return units;\n};\n\nconst findKNeighborUnit = (nodes, row, i, nodeLabelProp, k) => {\n  const unitNodeIdxs = [i];\n  const neighbors = [];\n  const labelCountMap = {};\n  row.forEach((v, j) => {\n    if (v <= k && i !== j) {\n      unitNodeIdxs.push(j);\n      neighbors.push(nodes[j]);\n      const label = nodes[j][nodeLabelProp];\n      if (!labelCountMap[label]) labelCountMap[label] = { count: 1, dists: [v] };\n      else {\n        labelCountMap[label].count++;\n        labelCountMap[label].dists.push(v);\n      }\n    }\n  });\n  // 将 labelCountMap 中的 dists 按照从小到大排序，方便后面使用\n  Object.keys(labelCountMap).forEach(label => {\n    labelCountMap[label].dists = labelCountMap[label].dists.sort((a, b) => a - b);\n  });\n  return {\n    nodeIdx: i,\n    nodeId: nodes[i].id,\n    nodeIdxs: unitNodeIdxs,\n    neighbors,\n    neighborNum: unitNodeIdxs.length - 1,\n    nodeLabelCountMap: labelCountMap,\n  };\n};\n\n/**\n * 随机寻找点对，满足距离小于 k\n * @param k 参数 k，表示 k-近邻\n * @param nodeNum 参数 length\n * @param maxNodePairNum 寻找点对的数量不超过 maxNodePairNum\n * @param spm 最短路径矩阵\n */\nconst findNodePairsRandomly = (\n  k: number,\n  nodeNum: number,\n  maxNodePairNum: number,\n  kNeighborUnits: NeighborUnit[],\n  spm: Matrix[],\n): NodePairMap => {\n  // 每个节点需要随机找出的点对数\n  let nodePairNumEachNode = Math.ceil(maxNodePairNum / nodeNum);\n  const nodePairMap = {};\n  let foundNodePairCount = 0;\n\n  // 遍历节点，为每个节点随机找出 nodePairNumEachNode 个点对，满足距离小于 k。找到的点对数量超过 maxNodePairNum 或所有节点遍历结束时终止\n  kNeighborUnits.forEach((unit, i) => {\n    // 若未达到 nodePairNumEachNode，或循环次数小于最大循环次数(2 * nodeNum)，继续循环\n    let nodePairForICount = 0;\n    let outerLoopCount = 0;\n    const neighbors = unit.nodeIdxs; // the first one is the center node\n    const neighborNum = unit.neighborNum - 1;\n    while (nodePairForICount < nodePairNumEachNode) {\n      // 另一端节点在节点数组中的的 index\n      let oidx = neighbors[1 + Math.floor(Math.random() * neighborNum)];\n      let innerLoopCount = 0;\n      // 若随机得到的另一端 idx 不符合条件，则继续 random。条件是不是同一个节点、这个点对没有被记录过、距离小于 k\n      while (nodePairMap[`${i}-${oidx}`] || nodePairMap[`${oidx}-${i}`]) {\n        oidx = Math.floor(Math.random() * nodeNum);\n        innerLoopCount++;\n        if (innerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\n      }\n      if (innerLoopCount < 2 * nodeNum) {\n        // 未达到最大循环次数，说明找到了合适的另一端\n        nodePairMap[`${i}-${oidx}`] = {\n          start: i,\n          end: oidx,\n          distance: spm[i][oidx],\n        };\n        nodePairForICount++;\n        foundNodePairCount++;\n        // 如果当前找到的点对数量达到了上限，返回结果\n        if (foundNodePairCount >= maxNodePairNum) return nodePairMap;\n      }\n      outerLoopCount++;\n      if (outerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\n    }\n    // 这个节点没有找到足够 nodePairNumEachNode 的点对。更新 nodePairNumEachNode，让后续节点找更多的点对\n    if (nodePairForICount < nodePairNumEachNode) {\n      const gap = nodePairNumEachNode - nodePairForICount;\n      nodePairNumEachNode = (nodePairNumEachNode + gap) / (nodeNum - i - 1);\n    }\n  });\n  return nodePairMap;\n};\n\n/**\n * 计算所有 nodePairMap 中节点对的相交邻居诱导子图\n * @param nodePairMap 节点对 map，key 为 node1.id-node2.id，value 为 { startNodeIdx, endNodeIdx, distance }\n * @param neighborUnits 每个节点的邻居元数组\n * @param graphData 原图数据\n * @param edgeMap 边的 map，方便检索\n * @param cachedInducedGraphMap 缓存的结果，下次进入该函数将继续更新该缓存，若 key 在缓存中存在则不需要重复计算\n */\nconst getIntersectNeighborInducedGraph = (\n  nodePairMap: NodePairMap,\n  neighborUnits: NeighborUnit[],\n  graphData: GraphData,\n  cachedInducedGraphMap?: InterGraphMap,\n): InterGraphMap => {\n  const nodes = graphData.nodes;\n  if (!cachedInducedGraphMap) cachedInducedGraphMap = {};\n  Object.keys(nodePairMap).forEach(key => {\n    if (cachedInducedGraphMap && cachedInducedGraphMap[key]) return;\n    cachedInducedGraphMap[key] = { nodes: [], edges: [] };\n    const pair = nodePairMap[key];\n    const startUnitNodeIds = neighborUnits[pair.start]?.nodeIdxs;\n    const endUnitNodeIds = neighborUnits[pair.end]?.nodeIdxs;\n    if (!startUnitNodeIds || !endUnitNodeIds) return; // 不存在邻元，返回空图\n    const endSet = new Set(endUnitNodeIds);\n    const intersect = startUnitNodeIds.filter(x => endSet.has(x)); // 可能会爆栈（在 1580 + 6 nodes full-connected 时出现）\n    if (!intersect || !intersect.length) return; // 没有交集，返回空图\n    const intersectIdMap = {};\n    const intersectLength = intersect.length;\n    for (let i = 0; i < intersectLength; i++) {\n      const node = nodes[intersect[i]];\n      cachedInducedGraphMap[key].nodes.push(node); // 将交集中的点加入诱导子图\n      intersectIdMap[node.id] = true;\n    }\n    // 遍历所有边数据，如果边的两端都在交集中，将该边加入诱导子图\n    graphData.edges.forEach(edge => {\n      if (intersectIdMap[edge.source] && intersectIdMap[edge.target])\n        cachedInducedGraphMap[key].edges.push(edge);\n    });\n  });\n  return cachedInducedGraphMap;\n};\n\n/**\n * 计算 strcutre 在 graph 上的匹配数量\n * @param graph 图数据\n * @param structure 目前支持只有两个节点一条边的最简单结构\n * @param nodeLabelProp 节点类型字段名\n * @param edgeLabelProp 边类型字段名\n */\nconst getMatchedCount = (graph, structure, nodeLabelProp, edgeLabelProp) => {\n  const nodeMap = {};\n  graph.nodes.forEach(node => {\n    nodeMap[node.id] = node;\n  });\n  let count = 0;\n  graph.edges.forEach(e => {\n    const sourceLabel = nodeMap[e.source][nodeLabelProp];\n    const targetLabel = nodeMap[e.target][nodeLabelProp];\n    const strNodeLabel1 = structure.nodes[0][nodeLabelProp];\n    const strNodeLabel2 = structure.nodes[1][nodeLabelProp];\n    const strEdgeLabel = structure.edges[0][edgeLabelProp];\n\n    if (e[edgeLabelProp] !== strEdgeLabel) return;\n    if (\n      (sourceLabel === strNodeLabel1 && targetLabel === strNodeLabel2) ||\n      (sourceLabel === strNodeLabel2 && targetLabel === strNodeLabel1)\n    ) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/**\n * structures 中寻找最具有代表性的一个。这个结构是使得 matchedCountMap 的分组方式类内间距最小，类间间距最大\n * @param matchedCountMap 每个 structure 分类后的各图匹配数量，格式 { [strcture.idx]: { [interInducedGraphKey]: count } }\n * @param structureNum strcuture 个数，与 matchedCountMap.length 对应\n * @param structures\n */\nconst findRepresentStructure = (matchedCountMap, structureNum, structures) => {\n  let maxOffset = Infinity,\n    representClusterType = 0;\n  for (let i = 0; i < structureNum; i++) {\n    // 一种分组的 map，key 是 intGraph 的 key，value 是 structures[i] 的匹配个数\n    const countMapI = matchedCountMap[i];\n    // 按照 value 为该组排序，生成 keys 的数组：\n    const sortedGraphKeys = Object.keys(countMapI).sort((a, b) => {\n      return countMapI[a] - countMapI[b];\n    });\n\n    // 共 100 个 graphKeys，将 graphKeys 按顺序分为 groupNum 组\n    const groupNum = 10;\n    const clusters = []; // 总共有 groupNum 个项\n    sortedGraphKeys.forEach((key, j) => {\n      if (!clusters[j % groupNum])\n        clusters[j % groupNum] = { graphs: [], totalCount: 0, aveCount: 0 };\n      clusters[j % groupNum].graphs.push(key);\n      clusters[j % groupNum].totalCount += countMapI[key];\n    });\n\n    // 计算 cluster 与 cluster 之间的距离 innerDist，每个 cluster 内部的距离 intraDist\n    let aveIntraDist = 0; // 该类的类内平均值\n    const aveCounts = []; // 类内平均匹配数量，将用于计算类间距离\n    clusters.forEach(graphsInCluster => {\n      // 类内均值\n      const aveCount = graphsInCluster.totalCount / graphsInCluster.graphs.length;\n      graphsInCluster.aveCount = aveCount;\n      aveCounts.push(aveCount);\n\n      // 对于每类，计算类内间距平均值\n      let aveIntraPerCluster = 0;\n      const graphsNum = graphsInCluster.length;\n      graphsInCluster.graphs.forEach((graphKey1, j) => {\n        const graph1Count = countMapI[graphKey1];\n        graphsInCluster.graphs.forEach((graphKey2, k) => {\n          if (j === k) return;\n          aveIntraPerCluster += Math.abs(graph1Count - countMapI[graphKey2]);\n        });\n      });\n      aveIntraPerCluster /= (graphsNum * (graphsNum - 1)) / 2;\n      aveIntraDist += aveIntraPerCluster;\n    });\n\n    aveIntraDist /= clusters.length;\n\n    // 用类内均值计算类间距\n    let aveInterDist = 0; // 类间间距平均值\n    aveCounts.forEach((aveCount1, j) => {\n      aveCounts.forEach((aveCount2, k) => {\n        if (j === k) return;\n        aveInterDist += Math.abs(aveCount1 - aveCount2);\n      });\n      aveInterDist /= (aveCounts.length * (aveCounts.length - 1)) / 2;\n    });\n\n    // 寻找 (类间间距均值-类内间距均值) 最大的一种分组方式（对应的 structure 就是最终要找的唯一 DS(G)）\n    const offset = aveInterDist - aveIntraDist;\n    if (maxOffset < offset) {\n      maxOffset = offset;\n      representClusterType = i;\n    }\n  }\n  return {\n    structure: structures[representClusterType],\n    structureCountMap: matchedCountMap[representClusterType],\n  };\n};\n\nconst getNodeMaps = (nodes, nodeLabelProp): { nodeMap: NodeMap; nodeLabelMap: LabelMap } => {\n  const nodeMap: NodeMap = {},\n    nodeLabelMap: LabelMap = {};\n  nodes.forEach((node, i) => {\n    nodeMap[node.id] = { idx: i, node, degree: 0 };\n    const label = node[nodeLabelProp];\n    if (!nodeLabelMap[label]) nodeLabelMap[label] = [];\n    nodeLabelMap[label].push(node);\n  });\n  return { nodeMap, nodeLabelMap };\n};\n\nconst getEdgeMaps = (\n  edges,\n  edgeLabelProp,\n  nodeMap: NodeMap,\n): { edgeMap: EdgeMap; edgeLabelMap: LabelMap } => {\n  const edgeMap = {},\n    edgeLabelMap = {};\n  edges.forEach((edge, i) => {\n    edgeMap[`${uniqueId}`] = { idx: i, edge };\n    const label = edge[edgeLabelProp];\n    if (!edgeLabelMap[label]) edgeLabelMap[label] = [];\n    edgeLabelMap[label].push(edge);\n\n    const sourceNode = nodeMap[edge.source];\n    if (sourceNode) sourceNode.degree++;\n    const targetNode = nodeMap[edge.target];\n    if (targetNode) targetNode.degree++;\n  });\n  return { edgeMap, edgeLabelMap };\n};\n\n/**\n * 输出最短路径的 map，key 为 sourceNode.id-targetNode.id，value 为这两个节点的最短路径长度\n * @param nodes\n * @param spm\n * @param directed\n */\nconst getSpmMap = (nodes, spm, directed): { [key: string]: number } => {\n  const length = spm.length;\n  const map = {};\n  spm.forEach((row, i) => {\n    const start = directed ? 0 : i + 1;\n    const iId = nodes[i].id;\n    for (let j = start; j < length; j++) {\n      if (i === j) continue;\n      const jId = nodes[j].id;\n      const dist = row[j];\n      map[`${iId}-${jId}`] = dist;\n      if (!directed) map[`${jId}-${iId}`] = dist;\n    }\n  });\n  return map;\n};\n\n/**\n * 计算一对节点（node1，node2）的 NDS 距离\n * @param graph 原图数据\n * @param node1\n * @param node2\n */\nconst getNDSDist = (\n  graph,\n  node1,\n  node2,\n  nodeMap,\n  spDist,\n  kNeighborUnits,\n  structure,\n  nodeLabelProp,\n  edgeLabelProp,\n  cachedNDSMap,\n  cachedInterInducedGraph,\n) => {\n  const key = `${node1.id}-${node2.id}`;\n  if (cachedNDSMap && cachedNDSMap[key]) return cachedNDSMap[key];\n  let interInducedGraph = cachedInterInducedGraph ? cachedInterInducedGraph[key] : undefined;\n  // 若没有缓存相交邻居诱导子图，计算\n  if (!interInducedGraph) {\n    const pairMap: NodePairMap = {\n      [key]: {\n        start: nodeMap[node1.id].idx,\n        end: nodeMap[node2.id].idx,\n        distance: spDist,\n      },\n    };\n\n    cachedInterInducedGraph = getIntersectNeighborInducedGraph(\n      pairMap,\n      kNeighborUnits,\n      graph,\n      cachedInterInducedGraph,\n    );\n    interInducedGraph = cachedInterInducedGraph[key];\n  }\n\n  return getMatchedCount(interInducedGraph, structure, nodeLabelProp, edgeLabelProp);\n};\n\n/**\n * GADDI 模式匹配\n * @param graphData 原图数据\n * @param pattern 搜索图（需要在原图上搜索的模式）数据\n * @param directed 是否计算有向图，默认 false\n * @param k 参数 k，表示 k-近邻\n * @param length 参数 length\n * @param nodeLabelProp 节点数据中代表节点标签（分类信息）的属性名。默认为 cluster\n * @param edgeLabelProp 边数据中代表边标签（分类信息）的属性名。默认为 cluster\n */\nconst GADDI = (\n  graphData: GraphData,\n  pattern: GraphData,\n  directed: boolean = false,\n  k: number,\n  length: number,\n  nodeLabelProp: string = 'cluster',\n  edgeLabelProp: string = 'cluster',\n): GraphData[] => {\n  if (!graphData || !graphData.nodes) return;\n  // 分为三步：\n  // 0. 预计算：节点/边数，邻接矩阵、最短路径矩阵\n  // 1. 处理原图 graphData。再分为 1~5 小步\n  // 2. 匹配\n\n  // console.log(\"----- stage-pre: preprocessing -------\");\n\n  // -------- 第零步，预计算：节点/边数，邻接矩阵、最短路径矩阵-------\n  const nodeNum = graphData.nodes.length;\n  if (!nodeNum) return;\n  // console.log(\"----- stage-pre.1: calc shortest path matrix for graph -------\");\n  const spm = floydWarshall(graphData, directed);\n  // console.log(\n  //   \"----- stage-pre.2: calc shortest path matrix for pattern -------\"\n  // );\n  const patternSpm = floydWarshall(pattern, directed);\n  // console.log(\n  //   \"----- stage-pre.3: calc shortest path matrix map for graph -------\"\n  // );\n  const spmMap = getSpmMap(graphData.nodes, spm, directed);\n  // console.log(\n  //   \"----- stage-pre.4: calc shortest path matrix map for pattern -------\"\n  // );\n  const patternSpmMap = getSpmMap(pattern.nodes, patternSpm, directed);\n\n  // console.log(\"----- stage-pre.5: establish maps -------\");\n  // 节点的 map，以 id 为 id 映射，方便后续快速检索\n  const { nodeMap, nodeLabelMap } = getNodeMaps(graphData.nodes, nodeLabelProp);\n  const { nodeMap: patternNodeMap, nodeLabelMap: patternNodeLabelMap } = getNodeMaps(\n    pattern.nodes,\n    nodeLabelProp,\n  );\n\n  // 计算节点度数\n  getEdgeMaps(graphData.edges, edgeLabelProp, nodeMap);\n\n  const { edgeLabelMap: patternEdgeLabelMap } = getEdgeMaps(\n    pattern.edges,\n    edgeLabelProp,\n    patternNodeMap,\n  );\n\n  // 若未指定 length，自动计算 pattern 半径（最短路径最大值）\n  if (!length) length = Math.max(...patternSpm[0], 2);\n  if (!k) k = length;\n\n  // console.log(\"params\", directed, length, k);\n\n  // console.log(\"----- stage-pre.6: calc k neighbor units -------\");\n  // 计算每个节点的 k 邻元集合\n  const kNeighborUnits = findKNeighborUnits(graphData, spm, nodeLabelProp, k);\n  const patternKNeighborUnits = findKNeighborUnits(pattern, patternSpm, nodeLabelProp, k);\n\n  // console.log(\n  //   \"----- stage0: going to processing graph and find intersect neighbor induced graphs -------\"\n  // );\n\n  // console.log(\"----- stage0.1: going to select random node pairs -------\");\n  // -------- 第一步，处理原图 graphData-------\n\n  // 1.1. 随机选择最多 100 个点对，满足距离小于 Length 和 k\n  // 当 graphData 少于 20 个节点，则不能找出 100 个点对，只找出不多于 n(n-1)/2 个点对\n  const maxNodePairNum = Math.min(100, (nodeNum * (nodeNum - 1)) / 2);\n  const nodePairsMap = findNodePairsRandomly(\n    k,\n    nodeNum,\n    maxNodePairNum,\n    patternKNeighborUnits,\n    spm,\n  );\n\n  // console.log(\n  //   \"----- stage0.2: going to calculate intersect neighbor induced graphs -------\"\n  // );\n  // 1.2. 生成上面节点对的相应相交邻居诱导子图。格式为 {'beginNodeIdx-endNodeIdx': {nodes: [], edges: []}}\n  let intGMap = getIntersectNeighborInducedGraph(nodePairsMap, kNeighborUnits, graphData);\n\n  // 1.3. 使用 gSpan 算法（frequent graph mining）计算 ISIntG 的前 10 个频率最高的子结构（3-4条边）\n  const top = 10,\n    minSupport = 1,\n    minNodeNum = 1,\n    maxNodeNum = 4;\n  const params = {\n    graphs: intGMap,\n    nodeLabelProp,\n    edgeLabelProp,\n    minSupport,\n    minNodeNum,\n    maxNodeNum,\n    directed,\n  };\n\n  // console.log(\n  //   \"----- stage1: (gSpan) going to find frequent structure dsG -------\"\n  // );\n  // console.log(\"----- stage1.1: going to run gSpan -------\");\n  // 暂时假设生成的 sub structure 都只有一条边\n  const freStructures = gSpan(params).slice(0, top);\n  // structureNum 可能小于 top\n  const structureNum = freStructures.length;\n\n  // 1.4. 计算上述 10 个子结构在 intGMap 中每个诱导子图的匹配个数\n  const matchedCountMap = [];\n  freStructures.forEach((structure, i) => {\n    matchedCountMap[i] = {};\n    Object.keys(intGMap).forEach(key => {\n      const graph = intGMap[key];\n      const subStructureCount = getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp);\n      matchedCountMap[i][key] = subStructureCount;\n    });\n  });\n\n  // console.log(\n  //   \"----- stage1.1: going to find the most represent strucutre -------\"\n  // );\n\n  // 1.5. 对于每个子结构，根据匹配个数为 intGMap 中的诱导子图分组，生成 structureNum 种分组\n  // 计算每种分组的类间距和类内间距，找到类间距最大、类内间距最小的一种分组，这种分组对应的子结构被选为唯一代表性子结构 DS(G)\n  const { structure: dsG, structureCountMap: ndsDist } = findRepresentStructure(\n    matchedCountMap,\n    structureNum,\n    freStructures,\n  );\n\n  // -------- 第二步，匹配-------\n  // 2.1 从 Q 中的第一个标签的第一个节点开始，寻找 G 中的匹配\n  const beginPNode = pattern.nodes[0];\n  const label = beginPNode[nodeLabelProp];\n  // 2.1.1 找到 G 中标签与之相同的节点\n  let candidates = nodeLabelMap[label];\n\n  // console.log(\"----- stage2: going to find candidates -------\");\n\n  // 全局缓存，避免重复计算\n  const minPatternNodeLabelDegreeMap = {}; // key 是 label，value 是该 label 节点的最小度数\n  let patternIntGraphMap = {},\n    patternNDSDist = {}, // key 为 node.id-node.id\n    patternNDSDistMap = {}; // key 为 node.id-label2，value nds距离值数组（按从大到小排序，无需关心具体对应哪个 node2）\n  // 2.2.2 对于 Q 中的另一个标签的 k 个节点，计算它们到 node 的最短路径以及 NDS 距离\n  const patternSpDist = {};\n  Object.keys(patternNodeLabelMap).forEach((label2, j) => {\n    patternSpDist[label2] = [];\n    let maxDist = -Infinity;\n    const patternNodesWithLabel2 = patternNodeLabelMap[label2];\n    const patternNodePairMap = {};\n    patternNodesWithLabel2.forEach(nodeWithLabel2 => {\n      const dist = patternSpmMap[`${beginPNode.id}-${nodeWithLabel2.id}`];\n      dist && patternSpDist[label2].push(dist);\n      if (maxDist < dist) maxDist = dist;\n      patternNodePairMap[`${beginPNode.id}-${nodeWithLabel2.id}`] = {\n        start: 0,\n        end: patternNodeMap[nodeWithLabel2.id].idx,\n        distance: dist,\n      };\n    });\n\n    // spDist[label2] 按照从小到大排序\n    patternSpDist[label2] = patternSpDist[label2].sort((a, b) => a - b);\n\n    // 计算 Q 中所有 label2 节点到 beginPNode 的 NDS 距离\n    // 所有 label2 节点到 beginPNode 的邻居相交诱导子图：\n    // key: node1.id-node2.id\n    patternIntGraphMap = getIntersectNeighborInducedGraph(\n      patternNodePairMap,\n      patternKNeighborUnits,\n      pattern,\n      patternIntGraphMap,\n    );\n    // pattern 中 beginNode 到当前 label2 节点 的 NDS 距离（数组，无需关心具体对应到哪个节点）\n    let currentPatternNDSDistArray = [];\n    Object.keys(patternNodePairMap).forEach(key => {\n      if (patternNDSDist[key]) {\n        currentPatternNDSDistArray.push(patternNDSDist[key]);\n        return; // 缓存过则不需要再次计算\n      }\n      const patternIntGraph = patternIntGraphMap[key];\n      patternNDSDist[key] = getMatchedCount(patternIntGraph, dsG, nodeLabelProp, edgeLabelProp);\n      currentPatternNDSDistArray.push(patternNDSDist[key]);\n    });\n\n    // 根据值为 currentPatternNDSDist 从大到小排序\n    currentPatternNDSDistArray = currentPatternNDSDistArray.sort((a, b) => b - a);\n    patternNDSDistMap[`${beginPNode.id}-${label2}`] = currentPatternNDSDistArray;\n\n    if (label2 === label) return;\n\n    const candidatesNum = candidates.length;\n    for (let m = candidatesNum - 1; m >= 0; m--) {\n      const cNode = candidates[m];\n\n      // prune1：若 candidates 中节点 cNode 的 kNeighborUnits 中标签为 label2 的节点个数少于 pattern 中 label2 个数，删去它\n      const graphNeighborUnit = kNeighborUnits[nodeMap[cNode.id].idx];\n      const graphNeighborUnitCountMap = graphNeighborUnit.nodeLabelCountMap[label2];\n      const patternLabel2Num = patternNodeLabelMap[label2].length;\n      if (!graphNeighborUnitCountMap || graphNeighborUnitCountMap.count < patternLabel2Num) {\n        candidates.splice(m, 1);\n        continue;\n      }\n\n      // prune2：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点最短路径大于 patternSpDist[label2]，删去它\n      // (prune2 规则即：candidate 相关的最短路径的最大 spDist[label2].length 个，按照大小顺序依次和 patternSpDist[label2] 中的值比较，只要遇到一个是 G > Q 的，就删去这个 candidate)\n      let prune2Invalid = false;\n      for (let n = 0; n < patternLabel2Num; n++) {\n        if (graphNeighborUnitCountMap.dists[n] > patternSpDist[label2][n]) {\n          prune2Invalid = true;\n          break;\n        }\n      }\n      if (prune2Invalid) {\n        candidates.splice(m, 1);\n        continue;\n      }\n\n      // prune3：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点 NDS 距离小于 patternNDSDist[beginNode.id-label2]，删去它\n      // TODO：prune3，currentPatternNDSDistArray 与 currentNDSDist 的比较\n\n      // 计算 G 中所有 label2 节点到 cNode 的 NDS 距离\n      // 所有 label2 节点到 cNode 的邻居相交诱导子图：\n      const cNodePairMap = {};\n      graphNeighborUnit.neighbors.forEach(neighborNode => {\n        const dist = spmMap[`${cNode.id}-${neighborNode.id}`];\n        cNodePairMap[`${cNode.id}-${neighborNode.id}`] = {\n          start: nodeMap[cNode.id].idx,\n          end: nodeMap[neighborNode.id].idx,\n          distance: dist,\n        };\n      });\n      // 更新 intGMap\n      intGMap = getIntersectNeighborInducedGraph(cNodePairMap, kNeighborUnits, graphData, intGMap);\n      // candidate 到它周围 label2 节点的 NDS 距离, key 是 node.id-node.id\n      let currentNDSDistArray = [];\n      Object.keys(cNodePairMap).forEach(key => {\n        if (ndsDist[key]) {\n          currentNDSDistArray.push(ndsDist[key]);\n          return; // 缓存过则不需要再次计算\n        }\n        const intGraph = intGMap[key];\n        ndsDist[key] = getMatchedCount(intGraph, dsG, nodeLabelProp, edgeLabelProp);\n        currentNDSDistArray.push(ndsDist[key]);\n      });\n\n      // 根据值为 currentNDSDistArray 从大到小排序\n      currentNDSDistArray = currentNDSDistArray.sort((a, b) => b - a);\n\n      let prune3Invalid = false;\n      for (let n = 0; n < patternLabel2Num; n++) {\n        if (currentNDSDistArray[n] < currentPatternNDSDistArray[n]) {\n          prune3Invalid = true;\n          break;\n        }\n      }\n      if (prune3Invalid) {\n        candidates.splice(m, 1);\n        continue;\n      }\n    }\n  });\n\n  const candidateGraphs = [];\n\n  // console.log(\n  //   \"----- stage3: going to splice neighbors for each candidate graph -------\"\n  // );\n\n  // candidates 经过筛选后，以每个 candidate 为中心，生成 Length-neighbor 的邻居诱导子图\n  // 并在诱导子图中去除不可能在 Q 上找到匹配的点：在 Q 上不存在的 label，其他 label 到 candidate 的最大最短距离符合 Q、NDS 距离符合 Q\n  candidates.forEach(candidate => {\n    const nodeIdx = nodeMap[candidate.id].idx;\n    const lengthNeighborUnit = findKNeighborUnit(\n      graphData.nodes,\n      spm[nodeIdx],\n      nodeIdx,\n      nodeLabelProp,\n      length,\n    );\n\n    const neighborNodes = lengthNeighborUnit.neighbors;\n\n    // 删除不可能找到匹配的邻居点\n    const neighborNum = neighborNodes.length;\n    let unmatched = false;\n    for (let i = neighborNum - 1; i >= 0; i--) {\n      // 如果通过裁剪，符合条件的节点数量已过少，说明不能匹配这个 candidate 相关的图\n      if (neighborNodes.length + 1 < pattern.nodes.length) {\n        unmatched = true;\n        return;\n      }\n      const neighborNode = neighborNodes[i];\n      const neighborLabel = neighborNode[nodeLabelProp];\n      // prune1: 若该邻居点的 label 不存在于 pattern 中，移除这个点\n      if (!patternNodeLabelMap[neighborLabel] || !patternNodeLabelMap[neighborLabel].length) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n\n      const key = `${candidate.id}-${neighborNode.id}`;\n\n      // prune2: 若该邻居点到 candidate 的最短路径比和它有相同 label 的节点到 beginPNode 的最大最短路径长度长，移除这个点\n      // prune2.1: 如果没有这个标签到 beginPNode 的距离记录，说明 pattern 上（可能 beginPNode 是这个 label）没有其他这个 label 的节点\n      if (!patternSpDist[neighborLabel] || !patternSpDist[neighborLabel].length) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n      // prune2.2\n      const distToCandidate = spmMap[key];\n      const maxDistWithLabelInPattern =\n        patternSpDist[neighborLabel][patternSpDist[neighborLabel].length - 1]; // patternSpDist[neighborLabel] 已经按照从小到大排序\n      if (distToCandidate > maxDistWithLabelInPattern) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n\n      // prune3: 若该邻居点到 candidate 的 NDS 距离比和它有相同 label 的节点到 beginPNode 的最小 NDS 距离小，移除这个点\n      const ndsToCandidate = ndsDist[key]\n        ? ndsDist[key]\n        : getNDSDist(\n            graphData,\n            candidate,\n            neighborNode,\n            nodeMap,\n            distToCandidate,\n            kNeighborUnits,\n            dsG,\n            nodeLabelProp,\n            edgeLabelProp,\n            ndsDist,\n            intGMap,\n          );\n      const patternKey = `${beginPNode.id}-${neighborLabel}`;\n      const minNdsWithLabelInPattern =\n        patternNDSDistMap[patternKey][patternNDSDistMap[patternKey].length - 1]; // patternNDSDist[key] 一定存在\n      if (ndsToCandidate < minNdsWithLabelInPattern) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n\n      // prune4: 若该邻居点的度数小于 pattern 同 label 节点最小度数，删去该点\n      let minPatternNodeLabelDegree = minPatternNodeLabelDegreeMap[neighborLabel];\n      if (minPatternNodeLabelDegree === undefined) {\n        minPatternNodeLabelDegree = Infinity;\n        patternNodeLabelMap[neighborLabel].forEach(patternNodeWithLabel => {\n          const patternNodeDegree = patternNodeMap[patternNodeWithLabel.id].degree;\n          if (minPatternNodeLabelDegree > patternNodeDegree)\n            minPatternNodeLabelDegree = patternNodeDegree;\n        });\n        minPatternNodeLabelDegreeMap[neighborLabel] = minPatternNodeLabelDegree;\n      }\n      if (nodeMap[neighborNode.id].degree < minPatternNodeLabelDegree) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n    }\n\n    // 节点在个数上符合匹配（不少于 pattern 的节点个数），现在筛选相关边\n    if (!unmatched) {\n      candidateGraphs.push({\n        nodes: [candidate].concat(neighborNodes),\n      });\n    }\n  });\n\n  // console.log(\n  //   \"----- stage4: going to splice edges and neighbors for each candidate graph -------\"\n  // );\n\n  const { length: undirectedLengthsToBeginPNode } = dijkstra(pattern, beginPNode.id, false);\n\n  let undirectedLengthsToBeginPNodeLabelMap = {};\n  if (directed) {\n    Object.keys(undirectedLengthsToBeginPNode).forEach(nodeId => {\n      const nodeLabel = patternNodeMap[nodeId].node[nodeLabelProp];\n      if (!undirectedLengthsToBeginPNodeLabelMap[nodeLabel])\n        undirectedLengthsToBeginPNodeLabelMap[nodeLabel] = [undirectedLengthsToBeginPNode[nodeId]];\n      else\n        undirectedLengthsToBeginPNodeLabelMap[nodeLabel].push(\n          undirectedLengthsToBeginPNode[nodeId],\n        );\n    });\n    Object.keys(undirectedLengthsToBeginPNodeLabelMap).forEach(pLabel => {\n      undirectedLengthsToBeginPNodeLabelMap[pLabel].sort((a, b) => a - b);\n    });\n  } else {\n    undirectedLengthsToBeginPNodeLabelMap = patternSpDist;\n  }\n\n  // 现在 candidateGraphs 里面只有节点，进行边的筛选\n  const candidateGraphNum = candidateGraphs.length;\n  for (let i = candidateGraphNum - 1; i >= 0; i--) {\n    const candidateGraph = candidateGraphs[i];\n    const candidate = candidateGraph.nodes[0];\n\n    const candidateNodeLabelCountMap = {};\n    const candidateNodeMap = {};\n    candidateGraph.nodes.forEach((node, q) => {\n      candidateNodeMap[node.id] = {\n        idx: q,\n        node,\n        degree: 0,\n      };\n      const cNodeLabel = node[nodeLabelProp];\n      if (!candidateNodeLabelCountMap[cNodeLabel]) candidateNodeLabelCountMap[cNodeLabel] = 1;\n      else candidateNodeLabelCountMap[cNodeLabel]++;\n    });\n\n    // 根据 candidate 和 neighborNodes 中的节点生成 G 的诱导子图\n    // 即，将 graphData 上两端都在 candidateGraph.nodes 中的边放入 candidateEdges\n    const candidateEdges = [];\n    const edgeLabelCountMap = {};\n    graphData.edges.forEach(edge => {\n      if (candidateNodeMap[edge.source] && candidateNodeMap[edge.target]) {\n        candidateEdges.push(edge);\n        if (!edgeLabelCountMap[edge[edgeLabelProp]]) edgeLabelCountMap[edge[edgeLabelProp]] = 1;\n        else edgeLabelCountMap[edge[edgeLabelProp]]++;\n        candidateNodeMap[edge.source].degree++;\n        candidateNodeMap[edge.target].degree++;\n      }\n    });\n\n    // prune：若有一个 edgeLabel 在 candidateGraph 上的个数少于 pattern，去除该图\n    const pattenrEdgeLabelNum = Object.keys(patternEdgeLabelMap).length;\n    let prunedByEdgeLabel = false;\n    for (let e = 0; e < pattenrEdgeLabelNum; e++) {\n      const label = Object.keys(patternEdgeLabelMap)[e];\n      if (\n        !edgeLabelCountMap[label] ||\n        edgeLabelCountMap[label] < patternEdgeLabelMap[label].length\n      ) {\n        prunedByEdgeLabel = true;\n        break;\n      }\n    }\n    if (prunedByEdgeLabel) {\n      candidateGraphs.splice(i, 1);\n      continue;\n    }\n\n    // 遍历 candidateEdges，进行边的筛选\n    let candidateEdgeNum = candidateEdges.length;\n\n    // prune：若边数过少，去除该图\n    if (candidateEdgeNum < pattern.edges.length) {\n      candidateGraphs.splice(i, 1);\n      break;\n    }\n    let candidateGraphInvalid = false;\n    for (let e = candidateEdgeNum - 1; e >= 0; e--) {\n      const edge = candidateEdges[e];\n      const edgeLabel = edge[edgeLabelProp];\n      const patternEdgesWithLabel = patternEdgeLabelMap[edgeLabel];\n\n      // prune 1: 若边的 label 不存在于 pattern 边 label 中，去除该边\n      if (!patternEdgesWithLabel || !patternEdgesWithLabel.length) {\n        edgeLabelCountMap[edgeLabel]--;\n        // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\n          candidateGraphInvalid = true;\n          break;\n        }\n        candidateEdges.splice(e, 1);\n        candidateNodeMap[edge.source].degree--;\n        candidateNodeMap[edge.target].degree--;\n        continue;\n      }\n\n      // prune 2: 若边的 label +两端 label 的三元组关系不能在 pattern 中找到，去除该边\n      const sourceLabel = candidateNodeMap[edge.source].node[nodeLabelProp];\n      const targetLabel = candidateNodeMap[edge.target].node[nodeLabelProp];\n\n      let edgeMatched = false;\n      patternEdgesWithLabel.forEach(patternEdge => {\n        const patternSource = patternNodeMap[patternEdge.source].node;\n        const patternTarget = patternNodeMap[patternEdge.target].node;\n        if (\n          patternSource[nodeLabelProp] === sourceLabel &&\n          patternTarget[nodeLabelProp] === targetLabel\n        )\n          edgeMatched = true;\n        if (\n          !directed &&\n          patternSource[nodeLabelProp] === targetLabel &&\n          patternTarget[nodeLabelProp] === sourceLabel\n        )\n          edgeMatched = true;\n      });\n      if (!edgeMatched) {\n        edgeLabelCountMap[edgeLabel]--;\n        // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\n          candidateGraphInvalid = true;\n          break;\n        }\n        candidateEdges.splice(e, 1);\n        candidateNodeMap[edge.source].degree--;\n        candidateNodeMap[edge.target].degree--;\n        continue;\n      }\n    }\n\n    // prune2: 删除边的过程中，发现边数过少/边 label 数过少时，去除该图\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      continue;\n    }\n\n    candidateGraph.edges = candidateEdges;\n\n    const { length: lengthsToCandidate } = dijkstra(\n      candidateGraph,\n      candidateGraph.nodes[0].id,\n      false, // 此处计算路径长度用于判断是否连通，因此使用无向图\n    );\n    Object.keys(lengthsToCandidate)\n      .reverse()\n      .forEach(targetId => {\n        if (targetId === candidateGraph.nodes[0].id || candidateGraphInvalid) return;\n        // prune4: 通过上述裁剪，可能导致该邻居子图变为不连通。裁剪掉目前在这个邻居子图中和 candidate（第一个节点）不连通的节点\n        if (lengthsToCandidate[targetId] === Infinity) {\n          const targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\n          candidateNodeLabelCountMap[targetNodeLabel]--;\n          if (\n            candidateNodeLabelCountMap[targetNodeLabel] <\n            patternNodeLabelMap[targetNodeLabel].length\n          ) {\n            candidateGraphInvalid = true;\n            return;\n          }\n          const idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\n          candidateGraph.nodes.splice(idx, 1);\n          candidateNodeMap[targetId] = undefined;\n          return;\n        }\n        // prune5: 经过边裁剪后，可能又出现了最短路径过长的节点 （比 pattern 中同 label 的节点到 beginNode 最大最短距离远），删去这些节点\n        const nLabel = nodeMap[targetId].node[nodeLabelProp];\n        if (\n          !undirectedLengthsToBeginPNodeLabelMap[nLabel] ||\n          !undirectedLengthsToBeginPNodeLabelMap[nLabel].length ||\n          lengthsToCandidate[targetId] >\n            undirectedLengthsToBeginPNodeLabelMap[nLabel][\n              undirectedLengthsToBeginPNodeLabelMap[nLabel].length - 1\n            ]\n        ) {\n          const targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\n          candidateNodeLabelCountMap[targetNodeLabel]--;\n          if (\n            candidateNodeLabelCountMap[targetNodeLabel] <\n            patternNodeLabelMap[targetNodeLabel].length\n          ) {\n            candidateGraphInvalid = true;\n            return;\n          }\n          const idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\n          candidateGraph.nodes.splice(idx, 1);\n          candidateNodeMap[targetId] = undefined;\n        }\n      });\n\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      continue;\n    }\n\n    let degreeChanged = true;\n    let loopCount = 0;\n    while (degreeChanged && !candidateGraphInvalid) {\n      degreeChanged = false;\n\n      // candidate 度数不足，删去该图\n      if (candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree) {\n        candidateGraphInvalid = true;\n        break;\n      }\n      // candidate label 个数不足，删去该图\n      if (\n        candidateNodeLabelCountMap[candidate[nodeLabelProp]] <\n        patternNodeLabelMap[candidate[nodeLabelProp]].length\n      ) {\n        candidateGraphInvalid = true;\n        break;\n      }\n\n      // prune6：去除度数过小的节点\n      const currentCandidateNodeNum = candidateGraph.nodes.length;\n      for (let o = currentCandidateNodeNum - 1; o >= 0; o--) {\n        const cgNode = candidateGraph.nodes[o];\n        const nodeDegree = candidateNodeMap[cgNode.id].degree;\n        const cNodeLabel = cgNode[nodeLabelProp];\n        if (nodeDegree < minPatternNodeLabelDegreeMap[cNodeLabel]) {\n          candidateNodeLabelCountMap[cgNode[nodeLabelProp]]--;\n          // 节点 label 个数不足\n          if (\n            candidateNodeLabelCountMap[cgNode[nodeLabelProp]] <\n            patternNodeLabelMap[cgNode[nodeLabelProp]].length\n          ) {\n            candidateGraphInvalid = true;\n            break;\n          }\n          candidateGraph.nodes.splice(o, 1);\n          candidateNodeMap[cgNode.id] = undefined;\n          degreeChanged = true;\n        }\n      }\n      if (candidateGraphInvalid || (!degreeChanged && loopCount !== 0)) break;\n      // 经过 prune5 节点裁剪，删去端点已经不在 candidateGraph 中的边\n      candidateEdgeNum = candidateEdges.length;\n      for (let y = candidateEdgeNum - 1; y >= 0; y--) {\n        const cedge = candidateEdges[y];\n        if (!candidateNodeMap[cedge.source] || !candidateNodeMap[cedge.target]) {\n          candidateEdges.splice(y, 1);\n          const edgeLabel = cedge[edgeLabelProp];\n          edgeLabelCountMap[edgeLabel]--;\n          candidateNodeMap[cedge.source] && candidateNodeMap[cedge.source].degree--;\n          candidateNodeMap[cedge.target] && candidateNodeMap[cedge.target].degree--;\n          // 边 label 数量不足\n          if (\n            patternEdgeLabelMap[edgeLabel] &&\n            edgeLabelCountMap[edgeLabel] < patternEdgeLabelMap[edgeLabel].length\n          ) {\n            candidateGraphInvalid = true;\n            break;\n          }\n          degreeChanged = true;\n        }\n      }\n      loopCount++;\n    }\n\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      continue;\n    }\n\n    // prune: 若节点/边数过少，节点/边 label 过少，去掉这个图\n    if (\n      candidateGraphInvalid ||\n      candidateGraph.nodes.length < pattern.nodes.length ||\n      candidateEdges.length < pattern.edges.length\n    ) {\n      candidateGraphs.splice(i, 1);\n      continue;\n    }\n  }\n\n  // 此时已经生成的多个 candidateGraphs，可能有重复\n\n  // console.log(\n  //   \"----- stage5: going to splice dulplicated candidate graphs -------\"\n  // );\n\n  // 删去 candidateGraphs 中一模一样的子图，通过边的 node-node-edgeLabel 作为 key，这类边个数作为 value，进行匹配\n  let currentLength = candidateGraphs.length;\n  for (let i = 0; i <= currentLength - 1; i++) {\n    const cg1 = candidateGraphs[i];\n    const cg1EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\n    cg1.edges.forEach(edge => {\n      const key = `${edge.source}-${edge.target}-${edge.label}`;\n      if (!cg1EdgeMap[key]) cg1EdgeMap[key] = 1;\n      else cg1EdgeMap[key]++;\n    });\n\n    for (let j = currentLength - 1; j > i; j--) {\n      const cg2 = candidateGraphs[j];\n      const cg2EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\n      cg2.edges.forEach(edge => {\n        const key = `${edge.source}-${edge.target}-${edge.label}`;\n        if (!cg2EdgeMap[key]) cg2EdgeMap[key] = 1;\n        else cg2EdgeMap[key]++;\n      });\n\n      let same = true;\n      if (Object.keys(cg2EdgeMap).length !== Object.keys(cg1EdgeMap).length) {\n        same = false;\n      } else {\n        Object.keys(cg1EdgeMap).forEach(key => {\n          if (cg2EdgeMap[key] !== cg1EdgeMap[key]) same = false;\n        });\n      }\n      if (same) {\n        candidateGraphs.splice(j, 1);\n      }\n    }\n    currentLength = candidateGraphs.length;\n  }\n\n  return candidateGraphs;\n};\n\nexport default GADDI;\n","export const ALGORITHM = {\n  pageRank: 'pageRank',\n  breadthFirstSearch: 'breadthFirstSearch',\n  connectedComponent: 'connectedComponent',\n  depthFirstSearch: 'depthFirstSearch',\n  detectCycle: 'detectCycle',\n  dijkstra: 'dijkstra',\n  findAllPath: 'findAllPath',\n  findShortestPath: 'findShortestPath',\n  floydWarshall: 'floydWarshall',\n  getAdjMatrix: 'getAdjMatrix',\n  getDegree: 'getDegree',\n  getInDegree: 'getInDegree',\n  getNeighbors: 'getNeighbors',\n  getOutDegree: 'getOutDegree',\n  labelPropagation: 'labelPropagation',\n  louvain: 'louvain',\n  GADDI: 'GADDI',\n  minimumSpanningTree: 'minimumSpanningTree',\n  SUCCESS: 'SUCCESS',\n  FAILURE: 'FAILURE',\n};\n\nexport const MESSAGE = {\n  SUCCESS: 'SUCCESS',\n  FAILURE: 'FAILURE',\n};\n","import * as algorithm from './algorithm';\nimport { MESSAGE } from './constant';\n\nconst ctx: Worker = self as any;\n\ninterface Event {\n  type: string;\n  data: any;\n}\n\nctx.onmessage = (event: Event) => {\n  const { type, data } = event.data;\n  if (typeof algorithm[type] === 'function') {\n    const result = algorithm[type](...data);\n    ctx.postMessage({ type: MESSAGE.SUCCESS, data: result });\n    return;\n  }\n\n  ctx.postMessage({ type: MESSAGE.FAILURE });\n};\n\n// https://stackoverflow.com/questions/50210416/webpack-worker-loader-fails-to-compile-typescript-worker\nexport default null as any;\n"],"sourceRoot":""}