{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nexport var getBBoxFromPoint = function getBBoxFromPoint(point) {\n  var x = point.x,\n      y = point.y;\n  return {\n    x: x,\n    y: y,\n    centerX: x,\n    centerY: y,\n    minX: x,\n    minY: y,\n    maxX: x,\n    maxY: y,\n    height: 0,\n    width: 0\n  };\n};\nexport var getBBoxFromPoints = function getBBoxFromPoints(points) {\n  if (points === void 0) {\n    points = [];\n  }\n\n  var xs = [];\n  var ys = [];\n  points.forEach(function (p) {\n    xs.push(p.x);\n    ys.push(p.y);\n  });\n  var minX = Math.min.apply(Math, xs);\n  var maxX = Math.max.apply(Math, xs);\n  var minY = Math.min.apply(Math, ys);\n  var maxY = Math.max.apply(Math, ys);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    maxX: maxX,\n    maxY: maxY,\n    minX: minX,\n    minY: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var isBBoxesOverlapping = function isBBoxesOverlapping(b1, b2) {\n  return Math.abs(b1.centerX - b2.centerX) * 2 < b1.width + b2.width && Math.abs(b1.centerY - b2.centerY) * 2 < b1.height + b2.height;\n};\nexport var filterConnectPoints = function filterConnectPoints(points) {\n  // pre-process: remove duplicated points\n  var result = [];\n  var pointsMap = {};\n  var pointsLength = points.length;\n\n  for (var i = 0; i < pointsLength; i++) {\n    var p = points[i];\n    p.id = p.x + \"|||\" + p.y;\n    pointsMap[p.id] = p;\n    result.push(p);\n  }\n\n  return result;\n};\nexport var simplifyPolyline = function simplifyPolyline(points) {\n  points = filterConnectPoints(points);\n  return points;\n};\nexport var getSimplePolyline = function getSimplePolyline(sPoint, tPoint) {\n  return [sPoint, {\n    x: sPoint.x,\n    y: tPoint.y\n  }, tPoint];\n};\nexport var getExpandedBBox = function getExpandedBBox(bbox, offset) {\n  if (bbox.width === 0 && bbox.height === 0) {\n    // when it is a point\n    return bbox;\n  }\n\n  return {\n    centerX: bbox.centerX,\n    centerY: bbox.centerY,\n    minX: bbox.minX - offset,\n    minY: bbox.minY - offset,\n    maxX: bbox.maxX + offset,\n    maxY: bbox.maxY + offset,\n    height: bbox.height + 2 * offset,\n    width: bbox.width + 2 * offset\n  };\n};\nexport var isHorizontalPort = function isHorizontalPort(port, bbox) {\n  var dx = Math.abs(port.x - bbox.centerX);\n  var dy = Math.abs(port.y - bbox.centerY);\n  if (dx === 0 && dy === 0) return 0;\n  return dx / bbox.width > dy / bbox.height;\n};\nexport var getExpandedBBoxPoint = function getExpandedBBoxPoint(bbox, point, anotherPoint) {\n  var isHorizontal = isHorizontalPort(point, bbox);\n\n  if (isHorizontal === 0) {\n    // 说明锚点是节点中心，linkCenter: true。需要根据两个节点的相对关系决定方向\n    var x = bbox.centerX;\n    var y = bbox.centerY;\n\n    if (anotherPoint.y < point.y) {\n      // 另一端在左上/右上方时，总是从上方走\n      y = bbox.minY;\n    } else if (anotherPoint.x > point.x) {\n      // 另一端在右下方，往右边走\n      x = bbox.maxX;\n    } else if (anotherPoint.x < point.x) {\n      // 另一端在左下方，往左边走\n      x = bbox.minX;\n    } else if (anotherPoint.x === point.x) {\n      // 另一段在正下方，往下走\n      y = bbox.maxY;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  }\n\n  if (isHorizontal) {\n    return {\n      x: point.x > bbox.centerX ? bbox.maxX : bbox.minX,\n      y: point.y\n    };\n  }\n\n  return {\n    x: point.x,\n    y: point.y > bbox.centerY ? bbox.maxY : bbox.minY\n  };\n};\n/**\n *\n * @param b1\n * @param b2\n */\n\nexport var mergeBBox = function mergeBBox(b1, b2) {\n  var minX = Math.min(b1.minX, b2.minX);\n  var minY = Math.min(b1.minY, b2.minY);\n  var maxX = Math.max(b1.maxX, b2.maxX);\n  var maxY = Math.max(b1.maxY, b2.maxY);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var getPointsFromBBox = function getPointsFromBBox(bbox) {\n  // anticlockwise\n  var minX = bbox.minX,\n      minY = bbox.minY,\n      maxX = bbox.maxX,\n      maxY = bbox.maxY;\n  return [{\n    x: minX,\n    y: minY\n  }, {\n    x: maxX,\n    y: minY\n  }, {\n    x: maxX,\n    y: maxY\n  }, {\n    x: minX,\n    y: maxY\n  }];\n};\nexport var isPointOutsideBBox = function isPointOutsideBBox(point, bbox) {\n  var x = point.x,\n      y = point.y;\n  return x < bbox.minX || x > bbox.maxX || y < bbox.minY || y > bbox.maxY;\n};\nexport var getBBoxXCrossPoints = function getBBoxXCrossPoints(bbox, x) {\n  if (x < bbox.minX || x > bbox.maxX) {\n    return [];\n  }\n\n  return [{\n    x: x,\n    y: bbox.minY\n  }, {\n    x: x,\n    y: bbox.maxY\n  }];\n};\nexport var getBBoxYCrossPoints = function getBBoxYCrossPoints(bbox, y) {\n  if (y < bbox.minY || y > bbox.maxY) {\n    return [];\n  }\n\n  return [{\n    x: bbox.minX,\n    y: y\n  }, {\n    x: bbox.maxX,\n    y: y\n  }];\n};\nexport var getBBoxCrossPointsByPoint = function getBBoxCrossPointsByPoint(bbox, point) {\n  return getBBoxXCrossPoints(bbox, point.x).concat(getBBoxYCrossPoints(bbox, point.y));\n};\n/**\n * 曼哈顿距离\n */\n\nexport var distance = function distance(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n/**\n * 如果 points 中的一个节点 x 与 p 相等，则消耗 -2。y 同\n * 即优先选择和 points 在同一水平线 / 垂直线上的点\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nexport var _costByPoints = function _costByPoints(p, points) {\n  var offset = -2;\n  var result = 0;\n  points.forEach(function (point) {\n    if (point) {\n      if (p.x === point.x) {\n        result += offset;\n      }\n\n      if (p.y === point.y) {\n        result += offset;\n      }\n    }\n  });\n  return result;\n};\n/**\n * ps 经过 p 到 pt 的距离，减去其他路过节点造成的消耗\n */\n\nexport var heuristicCostEstimate = function heuristicCostEstimate(p, ps, pt, source, target) {\n  return distance(p, ps) + distance(p, pt) + _costByPoints(p, [ps, pt, source, target]);\n};\nexport var reconstructPath = function reconstructPath(pathPoints, pointById, cameFrom, currentId, iterator) {\n  if (iterator === void 0) {\n    iterator = 0;\n  }\n\n  pathPoints.unshift(pointById[currentId]);\n\n  if (cameFrom[currentId] && cameFrom[currentId] !== currentId && iterator <= 100) {\n    reconstructPath(pathPoints, pointById, cameFrom, cameFrom[currentId], iterator + 1);\n  }\n};\n/**\n * 从 arr 中删去 item\n */\n\nexport var removeFrom = function removeFrom(arr, item) {\n  var index = arr.indexOf(item);\n\n  if (index > -1) {\n    arr.splice(index, 1);\n  }\n};\nexport var isSegmentsIntersected = function isSegmentsIntersected(p0, p1, p2, p3) {\n  var v1x = p2.x - p0.x;\n  var v1y = p2.y - p0.y;\n  var v2x = p3.x - p0.x;\n  var v2y = p3.y - p0.y;\n  var v3x = p2.x - p1.x;\n  var v3y = p2.y - p1.y;\n  var v4x = p3.x - p1.x;\n  var v4y = p3.y - p1.y;\n  var pd1 = v1x * v2y - v1y * v2x;\n  var pd2 = v3x * v4y - v3y * v4x;\n  var pd3 = v1x * v3y - v1y * v3x;\n  var pd4 = v2x * v4y - v2y * v4x;\n  return pd1 * pd2 <= 0 && pd3 * pd4 <= 0;\n};\nexport var isSegmentCrossingBBox = function isSegmentCrossingBBox(p1, p2, bbox) {\n  if (bbox.width === 0 && bbox.height === 0) {\n    return false;\n  }\n\n  var _a = getPointsFromBBox(bbox),\n      pa = _a[0],\n      pb = _a[1],\n      pc = _a[2],\n      pd = _a[3];\n\n  return isSegmentsIntersected(p1, p2, pa, pb) || isSegmentsIntersected(p1, p2, pa, pd) || isSegmentsIntersected(p1, p2, pb, pc) || isSegmentsIntersected(p1, p2, pc, pd);\n};\n/**\n * 在 points 中找到满足 x 或 y 和 point 的 x 或 y 相等，且与 point 连线不经过 bbox1 与 bbox2 的点\n */\n\nexport var getNeighborPoints = function getNeighborPoints(points, point, bbox1, bbox2) {\n  var neighbors = [];\n  points.forEach(function (p) {\n    if (p !== point) {\n      if (p.x === point.x || p.y === point.y) {\n        if (!isSegmentCrossingBBox(p, point, bbox1) && !isSegmentCrossingBBox(p, point, bbox2)) {\n          neighbors.push(p);\n        }\n      }\n    }\n  });\n  return filterConnectPoints(neighbors);\n};\nexport var pathFinder = function pathFinder(points, start, goal, sBBox, tBBox, os, ot) {\n  // A-Star Algorithm\n  var closedSet = [];\n  var openSet = [start];\n  var cameFrom = {};\n  var gScore = {}; // all default values are Infinity\n\n  var fScore = {}; // all default values are Infinity\n\n  gScore[start.id] = 0;\n  fScore[start.id] = heuristicCostEstimate(start, goal, start);\n  var pointById = {};\n  points.forEach(function (p) {\n    pointById[p.id] = p;\n  });\n\n  var _loop_1 = function _loop_1() {\n    var current;\n    var lowestFScore = Infinity; // 找到 openSet 中 fScore 最小的点\n\n    openSet.forEach(function (p) {\n      if (fScore[p.id] < lowestFScore) {\n        lowestFScore = fScore[p.id];\n        current = p;\n      }\n    }); // 若 openSet 中 fScore 最小的点就是终点\n\n    if (current === goal) {\n      // ending condition\n      var pathPoints = [];\n      reconstructPath(pathPoints, pointById, cameFrom, goal.id);\n      return {\n        value: pathPoints\n      };\n    }\n\n    removeFrom(openSet, current);\n    closedSet.push(current);\n    getNeighborPoints(points, current, sBBox, tBBox).forEach(function (neighbor) {\n      if (closedSet.indexOf(neighbor) !== -1) {\n        return;\n      }\n\n      if (openSet.indexOf(neighbor) === -1) {\n        openSet.push(neighbor);\n      }\n\n      var tentativeGScore = fScore[current.id] + distance(current, neighbor); // + distance(neighbor, goal);\n\n      if (gScore[neighbor.id] && tentativeGScore >= gScore[neighbor.id]) {\n        return;\n      }\n\n      cameFrom[neighbor.id] = current.id;\n      gScore[neighbor.id] = tentativeGScore;\n      fScore[neighbor.id] = gScore[neighbor.id] + heuristicCostEstimate(neighbor, goal, start, os, ot);\n    });\n  };\n\n  while (openSet.length) {\n    var state_1 = _loop_1();\n\n    if (_typeof(state_1) === \"object\") return state_1.value;\n  } // throw new Error('Cannot find path');\n\n\n  return [start, goal];\n};\nexport var isBending = function isBending(p0, p1, p2) {\n  return !(p0.x === p1.x && p1.x === p2.x || p0.y === p1.y && p1.y === p2.y);\n};\nexport var getBorderRadiusPoints = function getBorderRadiusPoints(p0, p1, p2, r) {\n  var d0 = distance(p0, p1);\n  var d1 = distance(p2, p1);\n\n  if (d0 < r) {\n    r = d0;\n  }\n\n  if (d1 < r) {\n    r = d1;\n  }\n\n  var ps = {\n    x: p1.x - r / d0 * (p1.x - p0.x),\n    y: p1.y - r / d0 * (p1.y - p0.y)\n  };\n  var pt = {\n    x: p1.x - r / d1 * (p1.x - p2.x),\n    y: p1.y - r / d1 * (p1.y - p2.y)\n  };\n  return [ps, pt];\n};\nexport var getPathWithBorderRadiusByPolyline = function getPathWithBorderRadiusByPolyline(points, borderRadius) {\n  // TODO\n  var pathSegments = [];\n  var startPoint = points[0];\n  pathSegments.push(\"M\" + startPoint.x + \" \" + startPoint.y);\n  points.forEach(function (p, i) {\n    var p1 = points[i + 1];\n    var p2 = points[i + 2];\n\n    if (p1 && p2) {\n      if (isBending(p, p1, p2)) {\n        var _a = getBorderRadiusPoints(p, p1, p2, borderRadius),\n            ps = _a[0],\n            pt = _a[1];\n\n        pathSegments.push(\"L\" + ps.x + \" \" + ps.y);\n        pathSegments.push(\"Q\" + p1.x + \" \" + p1.y + \" \" + pt.x + \" \" + pt.y);\n        pathSegments.push(\"L\" + pt.x + \" \" + pt.y);\n      } else {\n        pathSegments.push(\"L\" + p1.x + \" \" + p1.y);\n      }\n    } else if (p1) {\n      pathSegments.push(\"L\" + p1.x + \" \" + p1.y);\n    }\n  });\n  return pathSegments.join('');\n};\nexport var getPolylinePoints = function getPolylinePoints(start, end, sNode, tNode, offset) {\n  var sBBox, tBBox;\n\n  if (!sNode || !sNode.getType()) {\n    sBBox = getBBoxFromPoint(start);\n  } else if (sNode.getType() === 'combo') {\n    var sNodeKeyShape = sNode.getKeyShape();\n    sBBox = sNodeKeyShape.getCanvasBBox() || getBBoxFromPoint(start);\n    sBBox.centerX = (sBBox.minX + sBBox.maxX) / 2;\n    sBBox.centerY = (sBBox.minY + sBBox.maxY) / 2;\n  } else {\n    sBBox = sNode.getBBox();\n  }\n\n  if (!tNode || !tNode.getType()) {\n    tBBox = getBBoxFromPoint(end);\n  } else if (tNode.getType() === 'combo') {\n    var tNodeKeyShape = tNode.getKeyShape();\n    tBBox = tNodeKeyShape.getCanvasBBox() || getBBoxFromPoint(end);\n    tBBox.centerX = (tBBox.minX + tBBox.maxX) / 2;\n    tBBox.centerY = (tBBox.minY + tBBox.maxY) / 2;\n  } else {\n    tBBox = tNode && tNode.getBBox();\n  }\n\n  if (isBBoxesOverlapping(sBBox, tBBox)) {\n    // source and target nodes are overlapping\n    return simplifyPolyline(getSimplePolyline(start, end));\n  }\n\n  var sxBBox = getExpandedBBox(sBBox, offset);\n  var txBBox = getExpandedBBox(tBBox, offset);\n\n  if (isBBoxesOverlapping(sxBBox, txBBox)) {\n    // the expanded bounding boxes of source and target nodes are overlapping\n    return simplifyPolyline(getSimplePolyline(start, end));\n  }\n\n  var sPoint = getExpandedBBoxPoint(sxBBox, start, end);\n  var tPoint = getExpandedBBoxPoint(txBBox, end, start);\n  var lineBBox = getBBoxFromPoints([sPoint, tPoint]);\n  var sMixBBox = mergeBBox(sxBBox, lineBBox);\n  var tMixBBox = mergeBBox(txBBox, lineBBox);\n  var connectPoints = [];\n  connectPoints = connectPoints.concat(getPointsFromBBox(sMixBBox));\n  connectPoints = connectPoints.concat(getPointsFromBBox(tMixBBox));\n  var centerPoint = {\n    x: (start.x + end.x) / 2,\n    y: (start.y + end.y) / 2\n  };\n  [lineBBox, sMixBBox, tMixBBox].forEach(function (bbox) {\n    connectPoints = connectPoints.concat(getBBoxCrossPointsByPoint(bbox, centerPoint).filter(function (p) {\n      return isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox);\n    }));\n  });\n  [{\n    x: sPoint.x,\n    y: tPoint.y\n  }, {\n    x: tPoint.x,\n    y: sPoint.y\n  }].forEach(function (p) {\n    // impossible!!\n    if (isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox) // &&\n    // isPointInsideBBox(p, sMixBBox) && isPointInsideBBox(p, tMixBBox)\n    ) {\n        connectPoints.push(p);\n      }\n  });\n  connectPoints.unshift(sPoint);\n  connectPoints.push(tPoint); // filter out dulplicated points in connectPoints\n\n  connectPoints = filterConnectPoints(connectPoints); // , sxBBox, txBBox, outerBBox\n\n  var pathPoints = pathFinder(connectPoints, sPoint, tPoint, sBBox, tBBox, start, end);\n  pathPoints.unshift(start);\n  pathPoints.push(end);\n  return simplifyPolyline(pathPoints);\n};","map":{"version":3,"sources":["/Users/yangjiafeng/web-src/shake-book-manager/node_modules/@antv/g6-element/es/edges/polyline-util.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","getBBoxFromPoint","point","x","y","centerX","centerY","minX","minY","maxX","maxY","height","width","getBBoxFromPoints","points","xs","ys","forEach","p","push","Math","min","apply","max","isBBoxesOverlapping","b1","b2","abs","filterConnectPoints","result","pointsMap","pointsLength","length","i","id","simplifyPolyline","getSimplePolyline","sPoint","tPoint","getExpandedBBox","bbox","offset","isHorizontalPort","port","dx","dy","getExpandedBBoxPoint","anotherPoint","isHorizontal","mergeBBox","getPointsFromBBox","isPointOutsideBBox","getBBoxXCrossPoints","getBBoxYCrossPoints","getBBoxCrossPointsByPoint","concat","distance","p1","p2","_costByPoints","heuristicCostEstimate","ps","pt","source","target","reconstructPath","pathPoints","pointById","cameFrom","currentId","unshift","removeFrom","arr","item","index","indexOf","splice","isSegmentsIntersected","p0","p3","v1x","v1y","v2x","v2y","v3x","v3y","v4x","v4y","pd1","pd2","pd3","pd4","isSegmentCrossingBBox","_a","pa","pb","pc","pd","getNeighborPoints","bbox1","bbox2","neighbors","pathFinder","start","goal","sBBox","tBBox","os","ot","closedSet","openSet","gScore","fScore","_loop_1","current","lowestFScore","Infinity","value","neighbor","tentativeGScore","state_1","isBending","getBorderRadiusPoints","r","d0","d1","getPathWithBorderRadiusByPolyline","borderRadius","pathSegments","startPoint","join","getPolylinePoints","end","sNode","tNode","getType","sNodeKeyShape","getKeyShape","getCanvasBBox","getBBox","tNodeKeyShape","sxBBox","txBBox","lineBBox","sMixBBox","tMixBBox","connectPoints","centerPoint","filter"],"mappings":"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","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nexport var getBBoxFromPoint = function getBBoxFromPoint(point) {\n  var x = point.x,\n      y = point.y;\n  return {\n    x: x,\n    y: y,\n    centerX: x,\n    centerY: y,\n    minX: x,\n    minY: y,\n    maxX: x,\n    maxY: y,\n    height: 0,\n    width: 0\n  };\n};\nexport var getBBoxFromPoints = function getBBoxFromPoints(points) {\n  if (points === void 0) {\n    points = [];\n  }\n\n  var xs = [];\n  var ys = [];\n  points.forEach(function (p) {\n    xs.push(p.x);\n    ys.push(p.y);\n  });\n  var minX = Math.min.apply(Math, xs);\n  var maxX = Math.max.apply(Math, xs);\n  var minY = Math.min.apply(Math, ys);\n  var maxY = Math.max.apply(Math, ys);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    maxX: maxX,\n    maxY: maxY,\n    minX: minX,\n    minY: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var isBBoxesOverlapping = function isBBoxesOverlapping(b1, b2) {\n  return Math.abs(b1.centerX - b2.centerX) * 2 < b1.width + b2.width && Math.abs(b1.centerY - b2.centerY) * 2 < b1.height + b2.height;\n};\nexport var filterConnectPoints = function filterConnectPoints(points) {\n  // pre-process: remove duplicated points\n  var result = [];\n  var pointsMap = {};\n  var pointsLength = points.length;\n\n  for (var i = 0; i < pointsLength; i++) {\n    var p = points[i];\n    p.id = p.x + \"|||\" + p.y;\n    pointsMap[p.id] = p;\n    result.push(p);\n  }\n\n  return result;\n};\nexport var simplifyPolyline = function simplifyPolyline(points) {\n  points = filterConnectPoints(points);\n  return points;\n};\nexport var getSimplePolyline = function getSimplePolyline(sPoint, tPoint) {\n  return [sPoint, {\n    x: sPoint.x,\n    y: tPoint.y\n  }, tPoint];\n};\nexport var getExpandedBBox = function getExpandedBBox(bbox, offset) {\n  if (bbox.width === 0 && bbox.height === 0) {\n    // when it is a point\n    return bbox;\n  }\n\n  return {\n    centerX: bbox.centerX,\n    centerY: bbox.centerY,\n    minX: bbox.minX - offset,\n    minY: bbox.minY - offset,\n    maxX: bbox.maxX + offset,\n    maxY: bbox.maxY + offset,\n    height: bbox.height + 2 * offset,\n    width: bbox.width + 2 * offset\n  };\n};\nexport var isHorizontalPort = function isHorizontalPort(port, bbox) {\n  var dx = Math.abs(port.x - bbox.centerX);\n  var dy = Math.abs(port.y - bbox.centerY);\n  if (dx === 0 && dy === 0) return 0;\n  return dx / bbox.width > dy / bbox.height;\n};\nexport var getExpandedBBoxPoint = function getExpandedBBoxPoint(bbox, point, anotherPoint) {\n  var isHorizontal = isHorizontalPort(point, bbox);\n\n  if (isHorizontal === 0) {\n    // 说明锚点是节点中心，linkCenter: true。需要根据两个节点的相对关系决定方向\n    var x = bbox.centerX;\n    var y = bbox.centerY;\n\n    if (anotherPoint.y < point.y) {\n      // 另一端在左上/右上方时，总是从上方走\n      y = bbox.minY;\n    } else if (anotherPoint.x > point.x) {\n      // 另一端在右下方，往右边走\n      x = bbox.maxX;\n    } else if (anotherPoint.x < point.x) {\n      // 另一端在左下方，往左边走\n      x = bbox.minX;\n    } else if (anotherPoint.x === point.x) {\n      // 另一段在正下方，往下走\n      y = bbox.maxY;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  }\n\n  if (isHorizontal) {\n    return {\n      x: point.x > bbox.centerX ? bbox.maxX : bbox.minX,\n      y: point.y\n    };\n  }\n\n  return {\n    x: point.x,\n    y: point.y > bbox.centerY ? bbox.maxY : bbox.minY\n  };\n};\n/**\n *\n * @param b1\n * @param b2\n */\n\nexport var mergeBBox = function mergeBBox(b1, b2) {\n  var minX = Math.min(b1.minX, b2.minX);\n  var minY = Math.min(b1.minY, b2.minY);\n  var maxX = Math.max(b1.maxX, b2.maxX);\n  var maxY = Math.max(b1.maxY, b2.maxY);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var getPointsFromBBox = function getPointsFromBBox(bbox) {\n  // anticlockwise\n  var minX = bbox.minX,\n      minY = bbox.minY,\n      maxX = bbox.maxX,\n      maxY = bbox.maxY;\n  return [{\n    x: minX,\n    y: minY\n  }, {\n    x: maxX,\n    y: minY\n  }, {\n    x: maxX,\n    y: maxY\n  }, {\n    x: minX,\n    y: maxY\n  }];\n};\nexport var isPointOutsideBBox = function isPointOutsideBBox(point, bbox) {\n  var x = point.x,\n      y = point.y;\n  return x < bbox.minX || x > bbox.maxX || y < bbox.minY || y > bbox.maxY;\n};\nexport var getBBoxXCrossPoints = function getBBoxXCrossPoints(bbox, x) {\n  if (x < bbox.minX || x > bbox.maxX) {\n    return [];\n  }\n\n  return [{\n    x: x,\n    y: bbox.minY\n  }, {\n    x: x,\n    y: bbox.maxY\n  }];\n};\nexport var getBBoxYCrossPoints = function getBBoxYCrossPoints(bbox, y) {\n  if (y < bbox.minY || y > bbox.maxY) {\n    return [];\n  }\n\n  return [{\n    x: bbox.minX,\n    y: y\n  }, {\n    x: bbox.maxX,\n    y: y\n  }];\n};\nexport var getBBoxCrossPointsByPoint = function getBBoxCrossPointsByPoint(bbox, point) {\n  return getBBoxXCrossPoints(bbox, point.x).concat(getBBoxYCrossPoints(bbox, point.y));\n};\n/**\n * 曼哈顿距离\n */\n\nexport var distance = function distance(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n/**\n * 如果 points 中的一个节点 x 与 p 相等，则消耗 -2。y 同\n * 即优先选择和 points 在同一水平线 / 垂直线上的点\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nexport var _costByPoints = function _costByPoints(p, points) {\n  var offset = -2;\n  var result = 0;\n  points.forEach(function (point) {\n    if (point) {\n      if (p.x === point.x) {\n        result += offset;\n      }\n\n      if (p.y === point.y) {\n        result += offset;\n      }\n    }\n  });\n  return result;\n};\n/**\n * ps 经过 p 到 pt 的距离，减去其他路过节点造成的消耗\n */\n\nexport var heuristicCostEstimate = function heuristicCostEstimate(p, ps, pt, source, target) {\n  return distance(p, ps) + distance(p, pt) + _costByPoints(p, [ps, pt, source, target]);\n};\nexport var reconstructPath = function reconstructPath(pathPoints, pointById, cameFrom, currentId, iterator) {\n  if (iterator === void 0) {\n    iterator = 0;\n  }\n\n  pathPoints.unshift(pointById[currentId]);\n\n  if (cameFrom[currentId] && cameFrom[currentId] !== currentId && iterator <= 100) {\n    reconstructPath(pathPoints, pointById, cameFrom, cameFrom[currentId], iterator + 1);\n  }\n};\n/**\n * 从 arr 中删去 item\n */\n\nexport var removeFrom = function removeFrom(arr, item) {\n  var index = arr.indexOf(item);\n\n  if (index > -1) {\n    arr.splice(index, 1);\n  }\n};\nexport var isSegmentsIntersected = function isSegmentsIntersected(p0, p1, p2, p3) {\n  var v1x = p2.x - p0.x;\n  var v1y = p2.y - p0.y;\n  var v2x = p3.x - p0.x;\n  var v2y = p3.y - p0.y;\n  var v3x = p2.x - p1.x;\n  var v3y = p2.y - p1.y;\n  var v4x = p3.x - p1.x;\n  var v4y = p3.y - p1.y;\n  var pd1 = v1x * v2y - v1y * v2x;\n  var pd2 = v3x * v4y - v3y * v4x;\n  var pd3 = v1x * v3y - v1y * v3x;\n  var pd4 = v2x * v4y - v2y * v4x;\n  return pd1 * pd2 <= 0 && pd3 * pd4 <= 0;\n};\nexport var isSegmentCrossingBBox = function isSegmentCrossingBBox(p1, p2, bbox) {\n  if (bbox.width === 0 && bbox.height === 0) {\n    return false;\n  }\n\n  var _a = getPointsFromBBox(bbox),\n      pa = _a[0],\n      pb = _a[1],\n      pc = _a[2],\n      pd = _a[3];\n\n  return isSegmentsIntersected(p1, p2, pa, pb) || isSegmentsIntersected(p1, p2, pa, pd) || isSegmentsIntersected(p1, p2, pb, pc) || isSegmentsIntersected(p1, p2, pc, pd);\n};\n/**\n * 在 points 中找到满足 x 或 y 和 point 的 x 或 y 相等，且与 point 连线不经过 bbox1 与 bbox2 的点\n */\n\nexport var getNeighborPoints = function getNeighborPoints(points, point, bbox1, bbox2) {\n  var neighbors = [];\n  points.forEach(function (p) {\n    if (p !== point) {\n      if (p.x === point.x || p.y === point.y) {\n        if (!isSegmentCrossingBBox(p, point, bbox1) && !isSegmentCrossingBBox(p, point, bbox2)) {\n          neighbors.push(p);\n        }\n      }\n    }\n  });\n  return filterConnectPoints(neighbors);\n};\nexport var pathFinder = function pathFinder(points, start, goal, sBBox, tBBox, os, ot) {\n  // A-Star Algorithm\n  var closedSet = [];\n  var openSet = [start];\n  var cameFrom = {};\n  var gScore = {}; // all default values are Infinity\n\n  var fScore = {}; // all default values are Infinity\n\n  gScore[start.id] = 0;\n  fScore[start.id] = heuristicCostEstimate(start, goal, start);\n  var pointById = {};\n  points.forEach(function (p) {\n    pointById[p.id] = p;\n  });\n\n  var _loop_1 = function _loop_1() {\n    var current;\n    var lowestFScore = Infinity; // 找到 openSet 中 fScore 最小的点\n\n    openSet.forEach(function (p) {\n      if (fScore[p.id] < lowestFScore) {\n        lowestFScore = fScore[p.id];\n        current = p;\n      }\n    }); // 若 openSet 中 fScore 最小的点就是终点\n\n    if (current === goal) {\n      // ending condition\n      var pathPoints = [];\n      reconstructPath(pathPoints, pointById, cameFrom, goal.id);\n      return {\n        value: pathPoints\n      };\n    }\n\n    removeFrom(openSet, current);\n    closedSet.push(current);\n    getNeighborPoints(points, current, sBBox, tBBox).forEach(function (neighbor) {\n      if (closedSet.indexOf(neighbor) !== -1) {\n        return;\n      }\n\n      if (openSet.indexOf(neighbor) === -1) {\n        openSet.push(neighbor);\n      }\n\n      var tentativeGScore = fScore[current.id] + distance(current, neighbor); // + distance(neighbor, goal);\n\n      if (gScore[neighbor.id] && tentativeGScore >= gScore[neighbor.id]) {\n        return;\n      }\n\n      cameFrom[neighbor.id] = current.id;\n      gScore[neighbor.id] = tentativeGScore;\n      fScore[neighbor.id] = gScore[neighbor.id] + heuristicCostEstimate(neighbor, goal, start, os, ot);\n    });\n  };\n\n  while (openSet.length) {\n    var state_1 = _loop_1();\n\n    if (_typeof(state_1) === \"object\") return state_1.value;\n  } // throw new Error('Cannot find path');\n\n\n  return [start, goal];\n};\nexport var isBending = function isBending(p0, p1, p2) {\n  return !(p0.x === p1.x && p1.x === p2.x || p0.y === p1.y && p1.y === p2.y);\n};\nexport var getBorderRadiusPoints = function getBorderRadiusPoints(p0, p1, p2, r) {\n  var d0 = distance(p0, p1);\n  var d1 = distance(p2, p1);\n\n  if (d0 < r) {\n    r = d0;\n  }\n\n  if (d1 < r) {\n    r = d1;\n  }\n\n  var ps = {\n    x: p1.x - r / d0 * (p1.x - p0.x),\n    y: p1.y - r / d0 * (p1.y - p0.y)\n  };\n  var pt = {\n    x: p1.x - r / d1 * (p1.x - p2.x),\n    y: p1.y - r / d1 * (p1.y - p2.y)\n  };\n  return [ps, pt];\n};\nexport var getPathWithBorderRadiusByPolyline = function getPathWithBorderRadiusByPolyline(points, borderRadius) {\n  // TODO\n  var pathSegments = [];\n  var startPoint = points[0];\n  pathSegments.push(\"M\" + startPoint.x + \" \" + startPoint.y);\n  points.forEach(function (p, i) {\n    var p1 = points[i + 1];\n    var p2 = points[i + 2];\n\n    if (p1 && p2) {\n      if (isBending(p, p1, p2)) {\n        var _a = getBorderRadiusPoints(p, p1, p2, borderRadius),\n            ps = _a[0],\n            pt = _a[1];\n\n        pathSegments.push(\"L\" + ps.x + \" \" + ps.y);\n        pathSegments.push(\"Q\" + p1.x + \" \" + p1.y + \" \" + pt.x + \" \" + pt.y);\n        pathSegments.push(\"L\" + pt.x + \" \" + pt.y);\n      } else {\n        pathSegments.push(\"L\" + p1.x + \" \" + p1.y);\n      }\n    } else if (p1) {\n      pathSegments.push(\"L\" + p1.x + \" \" + p1.y);\n    }\n  });\n  return pathSegments.join('');\n};\nexport var getPolylinePoints = function getPolylinePoints(start, end, sNode, tNode, offset) {\n  var sBBox, tBBox;\n\n  if (!sNode || !sNode.getType()) {\n    sBBox = getBBoxFromPoint(start);\n  } else if (sNode.getType() === 'combo') {\n    var sNodeKeyShape = sNode.getKeyShape();\n    sBBox = sNodeKeyShape.getCanvasBBox() || getBBoxFromPoint(start);\n    sBBox.centerX = (sBBox.minX + sBBox.maxX) / 2;\n    sBBox.centerY = (sBBox.minY + sBBox.maxY) / 2;\n  } else {\n    sBBox = sNode.getBBox();\n  }\n\n  if (!tNode || !tNode.getType()) {\n    tBBox = getBBoxFromPoint(end);\n  } else if (tNode.getType() === 'combo') {\n    var tNodeKeyShape = tNode.getKeyShape();\n    tBBox = tNodeKeyShape.getCanvasBBox() || getBBoxFromPoint(end);\n    tBBox.centerX = (tBBox.minX + tBBox.maxX) / 2;\n    tBBox.centerY = (tBBox.minY + tBBox.maxY) / 2;\n  } else {\n    tBBox = tNode && tNode.getBBox();\n  }\n\n  if (isBBoxesOverlapping(sBBox, tBBox)) {\n    // source and target nodes are overlapping\n    return simplifyPolyline(getSimplePolyline(start, end));\n  }\n\n  var sxBBox = getExpandedBBox(sBBox, offset);\n  var txBBox = getExpandedBBox(tBBox, offset);\n\n  if (isBBoxesOverlapping(sxBBox, txBBox)) {\n    // the expanded bounding boxes of source and target nodes are overlapping\n    return simplifyPolyline(getSimplePolyline(start, end));\n  }\n\n  var sPoint = getExpandedBBoxPoint(sxBBox, start, end);\n  var tPoint = getExpandedBBoxPoint(txBBox, end, start);\n  var lineBBox = getBBoxFromPoints([sPoint, tPoint]);\n  var sMixBBox = mergeBBox(sxBBox, lineBBox);\n  var tMixBBox = mergeBBox(txBBox, lineBBox);\n  var connectPoints = [];\n  connectPoints = connectPoints.concat(getPointsFromBBox(sMixBBox));\n  connectPoints = connectPoints.concat(getPointsFromBBox(tMixBBox));\n  var centerPoint = {\n    x: (start.x + end.x) / 2,\n    y: (start.y + end.y) / 2\n  };\n  [lineBBox, sMixBBox, tMixBBox].forEach(function (bbox) {\n    connectPoints = connectPoints.concat(getBBoxCrossPointsByPoint(bbox, centerPoint).filter(function (p) {\n      return isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox);\n    }));\n  });\n  [{\n    x: sPoint.x,\n    y: tPoint.y\n  }, {\n    x: tPoint.x,\n    y: sPoint.y\n  }].forEach(function (p) {\n    // impossible!!\n    if (isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox) // &&\n    // isPointInsideBBox(p, sMixBBox) && isPointInsideBBox(p, tMixBBox)\n    ) {\n        connectPoints.push(p);\n      }\n  });\n  connectPoints.unshift(sPoint);\n  connectPoints.push(tPoint); // filter out dulplicated points in connectPoints\n\n  connectPoints = filterConnectPoints(connectPoints); // , sxBBox, txBBox, outerBBox\n\n  var pathPoints = pathFinder(connectPoints, sPoint, tPoint, sBBox, tBBox, start, end);\n  pathPoints.unshift(start);\n  pathPoints.push(end);\n  return simplifyPolyline(pathPoints);\n};"]},"metadata":{},"sourceType":"module"}