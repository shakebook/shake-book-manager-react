{"ast":null,"code":"!function (e, t) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = t() : \"function\" == typeof define && define.amd ? define([], t) : \"object\" == typeof exports ? exports.Algorithm = t() : e.Algorithm = t();\n}(this, function () {\n  return (() => {\n    \"use strict\";\n\n    var e,\n        t,\n        r = {\n      59: (e, t, r) => {\n        r.d(t, {\n          default: () => V\n        });\n\n        const n = function (e, t) {\n          var r = e.nodes,\n              n = e.edges,\n              o = [],\n              i = {};\n          if (!r) throw new Error(\"invalid nodes data!\");\n          return r && r.forEach(function (e, t) {\n            i[e.id] = t, o.push([]);\n          }), n && n.forEach(function (e) {\n            var r = e.source,\n                n = e.target,\n                a = i[r],\n                d = i[n];\n            !a && 0 !== a || !d && 0 !== d || (o[a][d] = 1, t || (o[d][a] = 1));\n          }), o;\n        };\n\n        var o = function (e, t) {\n          return e === t;\n        },\n            i = function () {\n          function e(e, t) {\n            void 0 === t && (t = null), this.value = e, this.next = t;\n          }\n\n          return e.prototype.toString = function (e) {\n            return e ? e(this.value) : \"\" + this.value;\n          }, e;\n        }();\n\n        const a = function () {\n          function e(e) {\n            void 0 === e && (e = o), this.head = null, this.tail = null, this.compare = e;\n          }\n\n          return e.prototype.prepend = function (e) {\n            var t = new i(e, this.head);\n            return this.head = t, this.tail || (this.tail = t), this;\n          }, e.prototype.append = function (e) {\n            var t = new i(e);\n            return this.head ? (this.tail.next = t, this.tail = t, this) : (this.head = t, this.tail = t, this);\n          }, e.prototype.delete = function (e) {\n            if (!this.head) return null;\n\n            for (var t = null; this.head && this.compare(this.head.value, e);) t = this.head, this.head = this.head.next;\n\n            var r = this.head;\n            if (null !== r) for (; r.next;) this.compare(r.next.value, e) ? (t = r.next, r.next = r.next.next) : r = r.next;\n            return this.compare(this.tail.value, e) && (this.tail = r), t;\n          }, e.prototype.find = function (e) {\n            var t = e.value,\n                r = void 0 === t ? void 0 : t,\n                n = e.callback,\n                o = void 0 === n ? void 0 : n;\n            if (!this.head) return null;\n\n            for (var i = this.head; i;) {\n              if (o && o(i.value)) return i;\n              if (void 0 !== r && this.compare(i.value, r)) return i;\n              i = i.next;\n            }\n\n            return null;\n          }, e.prototype.deleteTail = function () {\n            var e = this.tail;\n            if (this.head === this.tail) return this.head = null, this.tail = null, e;\n\n            for (var t = this.head; t.next;) t.next.next ? t = t.next : t.next = null;\n\n            return this.tail = t, e;\n          }, e.prototype.deleteHead = function () {\n            if (!this.head) return null;\n            var e = this.head;\n            return this.head.next ? this.head = this.head.next : (this.head = null, this.tail = null), e;\n          }, e.prototype.fromArray = function (e) {\n            var t = this;\n            return e.forEach(function (e) {\n              return t.append(e);\n            }), this;\n          }, e.prototype.toArray = function () {\n            for (var e = [], t = this.head; t;) e.push(t), t = t.next;\n\n            return e;\n          }, e.prototype.reverse = function () {\n            for (var e = this.head, t = null, r = null; e;) r = e.next, e.next = t, t = e, e = r;\n\n            this.tail = this.head, this.head = t;\n          }, e.prototype.toString = function (e) {\n            return void 0 === e && (e = void 0), this.toArray().map(function (t) {\n              return t.toString(e);\n            }).toString();\n          }, e;\n        }(),\n              d = function () {\n          function e() {\n            this.linkedList = new a();\n          }\n\n          return e.prototype.isEmpty = function () {\n            return !this.linkedList.head;\n          }, e.prototype.peek = function () {\n            return this.linkedList.head ? this.linkedList.head.value : null;\n          }, e.prototype.enqueue = function (e) {\n            this.linkedList.append(e);\n          }, e.prototype.dequeue = function () {\n            var e = this.linkedList.deleteHead();\n            return e ? e.value : null;\n          }, e.prototype.toString = function (e) {\n            return this.linkedList.toString(e);\n          }, e;\n        }();\n\n        var s = function (e, t, r) {\n          void 0 === t && (t = []);\n          var n = t.filter(function (t) {\n            return t.source === e || t.target === e;\n          });\n          return \"target\" === r ? n.filter(function (t) {\n            return t.source === e;\n          }).map(function (e) {\n            return e.target;\n          }) : \"source\" === r ? n.filter(function (t) {\n            return t.target === e;\n          }).map(function (e) {\n            return e.source;\n          }) : n.map(function (t) {\n            return t.source === e ? t.target : t.source;\n          });\n        },\n            u = function (e, t) {\n          return t.filter(function (t) {\n            return t.source === e || t.target === e;\n          });\n        },\n            f = function (e) {\n          return void 0 === e && (e = 0), e + \"-\" + (\"\" + Math.random()).split(\".\")[1].substr(0, 5) + (\"\" + Math.random()).split(\".\")[1].substr(0, 5);\n        };\n\n        var h = function (e) {\n          var t = {},\n              r = e.nodes,\n              n = void 0 === r ? [] : r,\n              o = e.edges,\n              i = void 0 === o ? [] : o;\n          return n.forEach(function (e) {\n            t[e.id] = {\n              degree: 0,\n              inDegree: 0,\n              outDegree: 0\n            };\n          }), i.forEach(function (e) {\n            t[e.source].degree++, t[e.source].outDegree++, t[e.target].degree++, t[e.target].inDegree++;\n          }), t;\n        };\n\n        const c = h;\n\n        function l(e, t, r, n) {\n          n.enter({\n            current: t,\n            previous: r\n          });\n          var o = e.edges;\n          s(t, void 0 === o ? [] : o, \"target\").forEach(function (o) {\n            n.allowTraversal({\n              previous: r,\n              current: t,\n              next: o\n            }) && l(e, o, t, n);\n          }), n.leave({\n            current: t,\n            previous: r\n          });\n        }\n\n        function p(e, t, r) {\n          l(e, t, \"\", function (e) {\n            void 0 === e && (e = {});\n\n            var t,\n                r = e,\n                n = function () {},\n                o = (t = {}, function (e) {\n              var r = e.next;\n              return !t[r] && (t[r] = !0, !0);\n            });\n\n            return r.allowTraversal = e.allowTraversal || o, r.enter = e.enter || n, r.leave = e.leave || n, r;\n          }(r));\n        }\n\n        function v() {\n          for (var e = 0, t = 0, r = arguments.length; t < r; t++) e += arguments[t].length;\n\n          var n = Array(e),\n              o = 0;\n\n          for (t = 0; t < r; t++) for (var i = arguments[t], a = 0, d = i.length; a < d; a++, o++) n[o] = i[a];\n\n          return n;\n        }\n\n        Object.create, Object.create;\n        var g = {}.toString;\n\n        const b = function (e, t) {\n          return g.call(e) === \"[object \" + t + \"]\";\n        },\n              y = function (e) {\n          return Array.isArray ? Array.isArray(e) : b(e, \"Array\");\n        };\n\n        Object.keys;\n        var m = Array.prototype;\n        m.splice, m.indexOf, Array.prototype.splice, Object.prototype.hasOwnProperty;\n        Number.isInteger && Number.isInteger, Math.PI, parseInt, Math.PI, Object.values, Object.prototype;\n\n        const E = function e(t) {\n          if (\"object\" != typeof t || null === t) return t;\n          var r;\n\n          if (y(t)) {\n            r = [];\n\n            for (var n = 0, o = t.length; n < o; n++) \"object\" == typeof t[n] && null != t[n] ? r[n] = e(t[n]) : r[n] = t[n];\n          } else for (var i in r = {}, t) \"object\" == typeof t[i] && null != t[i] ? r[i] = e(t[i]) : r[i] = t[i];\n\n          return r;\n        };\n\n        Object.prototype.hasOwnProperty, Object.prototype.hasOwnProperty, function () {\n          function e() {\n            this.map = {};\n          }\n\n          e.prototype.has = function (e) {\n            return void 0 !== this.map[e];\n          }, e.prototype.get = function (e, t) {\n            var r = this.map[e];\n            return void 0 === r ? t : r;\n          }, e.prototype.set = function (e, t) {\n            this.map[e] = t;\n          }, e.prototype.clear = function () {\n            this.map = {};\n          }, e.prototype.delete = function (e) {\n            delete this.map[e];\n          }, e.prototype.size = function () {\n            return Object.keys(this.map).length;\n          };\n        }();\n\n        const L = function (e, t, r, n) {\n          var o = e.nodes,\n              i = void 0 === o ? [] : o,\n              a = e.edges,\n              d = void 0 === a ? [] : a,\n              s = [],\n              f = {},\n              h = {},\n              c = {};\n          i.forEach(function (e, r) {\n            var n = e.id;\n            s.push(n), h[n] = 1 / 0, n === t && (h[n] = 0);\n          });\n\n          for (var l = i.length, p = function (e) {\n            var t = function (e, t, r) {\n              for (var n, o = 1 / 0, i = 0; i < t.length; i++) {\n                var a = t[i].id;\n                !r[a] && e[a] <= o && (o = e[a], n = t[i]);\n              }\n\n              return n;\n            }(h, i, f),\n                o = t.id;\n\n            if (f[o] = !0, h[o] === 1 / 0) return \"continue\";\n            (r ? function (e, t) {\n              return t.filter(function (t) {\n                return t.source === e;\n              });\n            }(o, d) : u(o, d)).forEach(function (e) {\n              var r = e.target,\n                  i = e.source,\n                  a = r === o ? i : r,\n                  d = n && e[n] ? e[n] : 1;\n              h[a] > h[t.id] + d ? (h[a] = h[t.id] + d, c[a] = [t.id]) : h[a] === h[t.id] + d && c[a].push(t.id);\n            });\n          }, v = 0; v < l; v++) p();\n\n          c[t] = [t];\n          var g = {};\n\n          for (var b in h) h[b] !== 1 / 0 && N(t, b, c, g);\n\n          var y = {};\n\n          for (var b in g) y[b] = g[b][0];\n\n          return {\n            length: h,\n            path: y,\n            allPaths: g\n          };\n        };\n\n        function N(e, t, r, n) {\n          if (e === t) return [e];\n          if (n[t]) return n[t];\n\n          for (var o = [], i = 0, a = r[t]; i < a.length; i++) {\n            var d = N(e, a[i], r, n);\n            if (!d) return;\n\n            for (var s = 0, u = d; s < u.length; s++) {\n              var f = u[s];\n              y(f) ? o.push(v(f, [t])) : o.push([f, t]);\n            }\n          }\n\n          return n[t] = o, n[t];\n        }\n\n        const k = function (e, t) {\n          for (var r = n(e, t), o = [], i = r.length, a = 0; a < i; a += 1) {\n            o[a] = [];\n\n            for (var d = 0; d < i; d += 1) a === d ? o[a][d] = 0 : 0 !== r[a][d] && r[a][d] ? o[a][d] = r[a][d] : o[a][d] = 1 / 0;\n          }\n\n          for (var s = 0; s < i; s += 1) for (a = 0; a < i; a += 1) for (d = 0; d < i; d += 1) o[a][d] > o[a][s] + o[s][d] && (o[a][d] = o[a][s] + o[s][d]);\n\n          return o;\n        };\n\n        var j = function (e, t, r, n) {\n          for (var o = t.length, i = 2 * n, a = 0, d = 0; d < o; d++) for (var s = e[d].clusterId, u = 0; u < o; u++) s === e[u].clusterId && (a += (t[d][u] || 0) - (r[d] || 0) * (r[u] || 0) / i);\n\n          return a * (1 / i);\n        };\n\n        const M = function () {\n          function e(e) {\n            this.count = e.length, this.parent = {};\n\n            for (var t = 0, r = e; t < r.length; t++) {\n              var n = r[t];\n              this.parent[n] = n;\n            }\n          }\n\n          return e.prototype.find = function (e) {\n            for (; this.parent[e] !== e;) e = this.parent[e];\n\n            return e;\n          }, e.prototype.union = function (e, t) {\n            var r = this.find(e),\n                n = this.find(t);\n            r !== n && (r < n ? (this.parent[t] !== t && this.union(this.parent[t], e), this.parent[t] = this.parent[e]) : (this.parent[e] !== e && this.union(this.parent[e], t), this.parent[e] = this.parent[t]));\n          }, e.prototype.connected = function (e, t) {\n            return this.find(e) === this.find(t);\n          }, e;\n        }();\n\n        var x = function (e, t) {\n          return e - t;\n        };\n\n        const w = function () {\n          function e(e) {\n            void 0 === e && (e = x), this.compareFn = e, this.list = [];\n          }\n\n          return e.prototype.getLeft = function (e) {\n            return 2 * e + 1;\n          }, e.prototype.getRight = function (e) {\n            return 2 * e + 2;\n          }, e.prototype.getParent = function (e) {\n            return 0 === e ? null : Math.floor((e - 1) / 2);\n          }, e.prototype.isEmpty = function () {\n            return this.list.length <= 0;\n          }, e.prototype.top = function () {\n            return this.isEmpty() ? void 0 : this.list[0];\n          }, e.prototype.delMin = function () {\n            var e = this.top(),\n                t = this.list.pop();\n            return this.list.length > 0 && (this.list[0] = t, this.moveDown(0)), e;\n          }, e.prototype.insert = function (e) {\n            if (null !== e) {\n              this.list.push(e);\n              var t = this.list.length - 1;\n              return this.moveUp(t), !0;\n            }\n\n            return !1;\n          }, e.prototype.moveUp = function (e) {\n            for (var t = this.getParent(e); e && e > 0 && this.compareFn(this.list[t], this.list[e]) > 0;) {\n              var r = this.list[t];\n              this.list[t] = this.list[e], this.list[e] = r, e = t, t = this.getParent(e);\n            }\n          }, e.prototype.moveDown = function (e) {\n            var t,\n                r = e,\n                n = this.getLeft(e),\n                o = this.getRight(e),\n                i = this.list.length;\n            null !== n && n < i && this.compareFn(this.list[r], this.list[n]) > 0 ? r = n : null !== o && o < i && this.compareFn(this.list[r], this.list[o]) > 0 && (r = o), e !== r && (t = [this.list[r], this.list[e]], this.list[e] = t[0], this.list[r] = t[1], this.moveDown(r));\n          }, e;\n        }();\n\n        var O = function (e, t) {\n          var r = [],\n              n = e.nodes,\n              o = void 0 === n ? [] : n,\n              i = e.edges,\n              a = void 0 === i ? [] : i;\n          if (0 === o.length) return r;\n          var d = o[0],\n              s = new Set();\n          s.add(d);\n          var f = new w(function (e, r) {\n            return t ? e.weight - r.weight : 0;\n          });\n\n          for (u(d.id, a).forEach(function (e) {\n            f.insert(e);\n          }); !f.isEmpty();) {\n            var h = f.delMin(),\n                c = h.source,\n                l = h.target;\n            s.has(c) && s.has(l) || (r.push(h), s.has(c) || (s.add(c), u(c, a).forEach(function (e) {\n              f.insert(e);\n            })), s.has(l) || (s.add(l), u(l, a).forEach(function (e) {\n              f.insert(e);\n            })));\n          }\n\n          return r;\n        },\n            I = function (e, t) {\n          var r = [],\n              n = e.nodes,\n              o = void 0 === n ? [] : n,\n              i = e.edges,\n              a = void 0 === i ? [] : i;\n          if (0 === o.length) return r;\n          var d = a.map(function (e) {\n            return e;\n          });\n          t && d.sort(function (e, t) {\n            return e.weight - t.weight;\n          });\n\n          for (var s = new M(o.map(function (e) {\n            return e.id;\n          })); d.length > 0;) {\n            var u = d.shift(),\n                f = u.source,\n                h = u.target;\n            s.connected(f, h) || (r.push(u), s.union(f, h));\n          }\n\n          return r;\n        };\n\n        var A = \"-1\",\n            S = function (e, t, r, n) {\n          void 0 === e && (e = -1), void 0 === t && (t = -1), void 0 === r && (r = -1), void 0 === n && (n = \"-1\"), this.id = e, this.from = t, this.to = r, this.label = n;\n        },\n            C = function () {\n          function e(e, t) {\n            void 0 === e && (e = -1), void 0 === t && (t = A), this.id = e, this.label = t, this.edges = [], this.edgeMap = {};\n          }\n\n          return e.prototype.addEdge = function (e) {\n            this.edges.push(e), this.edgeMap[e.id] = e;\n          }, e;\n        }(),\n            P = function () {\n          function e(e, t, r) {\n            void 0 === e && (e = -1), void 0 === t && (t = !0), void 0 === r && (r = !1), this.id = e, this.edgeIdAutoIncrease = t, this.edges = [], this.nodes = [], this.nodeMap = {}, this.edgeMap = {}, this.nodeLabelMap = {}, this.edgeLabelMap = {}, this.counter = 0, this.directed = r;\n          }\n\n          return e.prototype.getNodeNum = function () {\n            return this.nodes.length;\n          }, e.prototype.addNode = function (e, t) {\n            if (!this.nodeMap[e]) {\n              var r = new C(e, t);\n              this.nodes.push(r), this.nodeMap[e] = r, this.nodeLabelMap[t] || (this.nodeLabelMap[t] = []), this.nodeLabelMap[t].push(e);\n            }\n          }, e.prototype.addEdge = function (e, t, r, n) {\n            if ((this.edgeIdAutoIncrease || void 0 === e) && (e = this.counter++), !(this.nodeMap[t] && this.nodeMap[r] && this.nodeMap[r].edgeMap[e])) {\n              var o = new S(e, t, r, n);\n\n              if (this.edges.push(o), this.edgeMap[e] = o, this.nodeMap[t].addEdge(o), this.edgeLabelMap[n] || (this.edgeLabelMap[n] = []), this.edgeLabelMap[n].push(o), !this.directed) {\n                var i = new S(e, r, t, n);\n                this.nodeMap[r].addEdge(i), this.edgeLabelMap[n].push(i);\n              }\n            }\n          }, e;\n        }(),\n            T = function () {\n          function e(e, t, r, n, o) {\n            this.fromNode = e, this.toNode = t, this.nodeEdgeNodeLabel = {\n              nodeLabel1: r || A,\n              edgeLabel: n || \"-1\",\n              nodeLabel2: o || A\n            };\n          }\n\n          return e.prototype.equalTo = function (e) {\n            return this.fromNode === e.formNode && this.toNode === e.toNode && this.nodeEdgeNodeLabel === e.nodeEdgeNodeLabel;\n          }, e.prototype.notEqualTo = function (e) {\n            return !this.equalTo(e);\n          }, e;\n        }(),\n            D = function () {\n          function e() {\n            this.rmpath = [], this.dfsEdgeList = [];\n          }\n\n          return e.prototype.equalTo = function (e) {\n            var t = this.dfsEdgeList.length;\n            if (t !== e.length) return !1;\n\n            for (var r = 0; r < t; r++) if (this.dfsEdgeList[r] !== e[r]) return !1;\n\n            return !0;\n          }, e.prototype.notEqualTo = function (e) {\n            return !this.equalTo(e);\n          }, e.prototype.pushBack = function (e, t, r, n, o) {\n            return this.dfsEdgeList.push(new T(e, t, r, n, o)), this.dfsEdgeList;\n          }, e.prototype.toGraph = function (e, t) {\n            void 0 === e && (e = -1), void 0 === t && (t = !1);\n            var r = new P(e, !0, t);\n            return this.dfsEdgeList.forEach(function (e) {\n              var t = e.fromNode,\n                  n = e.toNode,\n                  o = e.nodeEdgeNodeLabel,\n                  i = o.nodeLabel1,\n                  a = o.edgeLabel,\n                  d = o.nodeLabel2;\n              i !== A && r.addNode(t, i), d !== A && r.addNode(n, d), r.addEdge(void 0, t, n, a);\n            }), r;\n          }, e.prototype.buildRmpath = function () {\n            this.rmpath = [];\n\n            for (var e = void 0, t = this.dfsEdgeList.length - 1; t >= 0; t--) {\n              var r = this.dfsEdgeList[t],\n                  n = r.fromNode,\n                  o = r.toNode;\n              n < o && (void 0 === e || o === e) && (this.rmpath.push(t), e = n);\n            }\n\n            return this.rmpath;\n          }, e.prototype.getNodeNum = function () {\n            var e = {};\n            return this.dfsEdgeList.forEach(function (t) {\n              e[t.fromNode] || (e[t.fromNode] = !0), e[t.toNode] || (e[t.toNode] = !0);\n            }), Object.keys(e).length;\n          }, e;\n        }(),\n            q = function () {\n          function e(e) {\n            if (this.his = {}, this.nodesUsed = {}, this.edgesUsed = {}, this.edges = [], e) {\n              for (; e;) {\n                var t = e.edge;\n                this.edges.push(t), this.nodesUsed[t.from] = 1, this.nodesUsed[t.to] = 1, this.edgesUsed[t.id] = 1, e = e.preNode;\n              }\n\n              this.edges = this.edges.reverse();\n            }\n          }\n\n          return e.prototype.hasNode = function (e) {\n            return 1 === this.nodesUsed[e.id];\n          }, e.prototype.hasEdge = function (e) {\n            return 1 === this.edgesUsed[e.id];\n          }, e;\n        }(),\n            F = function () {\n          function e(e) {\n            var t = e.graphs,\n                r = e.minSupport,\n                n = void 0 === r ? 2 : r,\n                o = e.minNodeNum,\n                i = void 0 === o ? 1 : o,\n                a = e.maxNodeNum,\n                d = void 0 === a ? 4 : a,\n                s = e.top,\n                u = void 0 === s ? 10 : s,\n                f = e.directed,\n                h = void 0 !== f && f,\n                c = e.verbose,\n                l = void 0 !== c && c;\n            this.graphs = t, this.dfsCode = new D(), this.support = 0, this.frequentSize1Subgraphs = [], this.frequentSubgraphs = [], this.minSupport = n, this.top = u, this.directed = h, this.counter = 0, this.maxNodeNum = d, this.minNodeNum = i, this.verbose = l, this.maxNodeNum < this.minNodeNum && (this.maxNodeNum = this.minNodeNum), this.reportDF = [];\n          }\n\n          return e.prototype.findForwardRootEdges = function (e, t) {\n            var r = this,\n                n = [],\n                o = e.nodeMap;\n            return t.edges.forEach(function (e) {\n              (r.directed || t.label <= o[e.to].label) && n.push(e);\n            }), n;\n          }, e.prototype.findBackwardEdge = function (e, t, r, n) {\n            if (!this.directed && t === r) return null;\n\n            for (var o = e.nodeMap, i = o[r.to].edges, a = i.length, d = 0; d < a; d++) {\n              var s = i[d];\n              if (!n.hasEdge(s) && s.to === t.from) if (this.directed) {\n                if (o[t.from].label < o[r.to].label || o[t.from].label === o[r.to].label && t.label <= s.label) return s;\n              } else if (t.label < s.label || t.label === s.label && o[t.to].label <= o[r.to].label) return s;\n            }\n\n            return null;\n          }, e.prototype.findForwardPureEdges = function (e, t, r, n) {\n            for (var o = [], i = t.to, a = e.nodeMap[i].edges, d = a.length, s = 0; s < d; s++) {\n              var u = a[s],\n                  f = e.nodeMap[u.to];\n              r <= f.label && !n.hasNode(f) && o.push(u);\n            }\n\n            return o;\n          }, e.prototype.findForwardRmpathEdges = function (e, t, r, n) {\n            for (var o = [], i = e.nodeMap, a = i[t.to].label, d = i[t.from].edges, s = d.length, u = 0; u < s; u++) {\n              var f = d[u],\n                  h = i[f.to].label;\n              t.to === f.to || r > h || n.hasNode(i[f.to]) || (t.label < f.label || t.label === f.label && a <= h) && o.push(f);\n            }\n\n            return o;\n          }, e.prototype.getSupport = function (e) {\n            var t = {};\n            return e.forEach(function (e) {\n              t[e.graphId] || (t[e.graphId] = !0);\n            }), Object.keys(t).length;\n          }, e.prototype.findMinLabel = function (e) {\n            var t = void 0;\n            return Object.keys(e).forEach(function (r) {\n              var n = e[r],\n                  o = n.nodeLabel1,\n                  i = n.edgeLabel,\n                  a = n.nodeLabel2;\n              t ? (o < t.nodeLabel1 || o === t.nodeLabel1 && i < t.edgeLabel || o === t.nodeLabel1 && i === t.edgeLabel && a < t.nodeLabel2) && (t = {\n                nodeLabel1: o,\n                edgeLabel: i,\n                nodeLabel2: a\n              }) : t = {\n                nodeLabel1: o,\n                edgeLabel: i,\n                nodeLabel2: a\n              };\n            }), t;\n          }, e.prototype.isMin = function () {\n            var e = this,\n                t = this.dfsCode;\n            if (this.verbose && console.log(\"isMin checking\", t), 1 === t.dfsEdgeList.length) return !0;\n            var r = this.directed,\n                n = t.toGraph(-1, r),\n                o = n.nodeMap,\n                i = new D(),\n                a = {};\n            n.nodes.forEach(function (t) {\n              e.findForwardRootEdges(n, t).forEach(function (e) {\n                var r = o[e.to],\n                    i = t.label + \"-\" + e.label + \"-\" + r.label;\n                a[i] || (a[i] = {\n                  projected: [],\n                  nodeLabel1: t.label,\n                  edgeLabel: e.label,\n                  nodeLabel2: r.label\n                });\n                var d = {\n                  graphId: n.id,\n                  edge: e,\n                  preNode: null\n                };\n                a[i].projected.push(d);\n              });\n            });\n            var d = this.findMinLabel(a);\n            i.dfsEdgeList.push(new T(0, 1, d.nodeLabel1, d.edgeLabel, d.nodeLabel2));\n\n            var s = function (a) {\n              for (var d = i.buildRmpath(), u = i.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1, f = i.dfsEdgeList[d[0]].toNode, h = {}, c = !1, l = 0, p = r ? -1 : 0, v = function (t) {\n                if (c) return \"break\";\n                a.forEach(function (r) {\n                  var o = new q(r),\n                      a = e.findBackwardEdge(n, o.edges[d[t]], o.edges[d[0]], o);\n                  a && (h[a.label] || (h[a.label] = {\n                    projected: [],\n                    edgeLabel: a.label\n                  }), h[a.label].projected.push({\n                    graphId: n.id,\n                    edge: h,\n                    preNode: r\n                  }), l = i.dfsEdgeList[d[t]].fromNode, c = !0);\n                });\n              }, g = d.length - 1; g > p && \"break\" !== v(g); g--);\n\n              if (c) {\n                var b = e.findMinLabel(h);\n                i.dfsEdgeList.push(new T(f, l, A, b.edgeLabel, A));\n                var y = i.dfsEdgeList.length - 1;\n                return e.dfsCode.dfsEdgeList[y] === i.dfsEdgeList[y] && s(h[b.edgeLabel].projected);\n              }\n\n              var m = {};\n              c = !1;\n              var E = 0;\n              a.forEach(function (t) {\n                var r = new q(t),\n                    i = e.findForwardPureEdges(n, r.edges[d[0]], u, r);\n                i.length > 0 && (c = !0, E = f, i.forEach(function (e) {\n                  var r = e.label + \"-\" + o[e.to].label;\n                  m[r] || (m[r] = {\n                    projected: [],\n                    edgeLabel: e.label,\n                    nodeLabel2: o[e.to].label\n                  }), m[r].projected.push({\n                    graphId: n.id,\n                    edge: e,\n                    preNode: t\n                  });\n                }));\n              });\n\n              var L = d.length,\n                  N = function (t) {\n                if (c) return \"break\";\n                var r = d[t];\n                a.forEach(function (t) {\n                  var a = new q(t),\n                      d = e.findForwardRmpathEdges(n, a.edges[r], u, a);\n                  d.length > 0 && (c = !0, E = i.dfsEdgeList[r].fromNode, d.forEach(function (e) {\n                    var r = e.label + \"-\" + o[e.to].label;\n                    m[r] || (m[r] = {\n                      projected: [],\n                      edgeLabel: e.label,\n                      nodeLabel2: o[e.to].label\n                    }), m[r].projected.push({\n                      graphId: n.id,\n                      edge: e,\n                      preNode: t\n                    });\n                  }));\n                });\n              };\n\n              for (g = 0; g < L && \"break\" !== N(g); g++);\n\n              if (!c) return !0;\n              var k = e.findMinLabel(m);\n              i.dfsEdgeList.push(new T(E, f + 1, A, k.edgeLabel, k.nodeLabel2));\n              var j = i.dfsEdgeList.length - 1;\n              return t.dfsEdgeList[j] === i.dfsEdgeList[j] && s(m[k.edgeLabel + \"-\" + k.nodeLabel2].projected);\n            },\n                u = d.nodeLabel1 + \"-\" + d.edgeLabel + \"-\" + d.nodeLabel2;\n\n            return s(a[u].projected);\n          }, e.prototype.report = function () {\n            if (!(this.dfsCode.getNodeNum() < this.minNodeNum)) {\n              this.counter++;\n              var e = this.dfsCode.toGraph(this.counter, this.directed);\n              this.frequentSubgraphs.push(E(e));\n            }\n          }, e.prototype.subGraphMining = function (e) {\n            var t = this;\n\n            if (!(this.getSupport(e) < this.minSupport) && this.isMin()) {\n              this.report();\n              var r = this.dfsCode.getNodeNum(),\n                  n = this.dfsCode.buildRmpath(),\n                  o = this.dfsCode.dfsEdgeList[n[0]].toNode,\n                  i = this.dfsCode.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1,\n                  a = {},\n                  d = {};\n              e.forEach(function (e) {\n                for (var s = t.graphs[e.graphId], u = s.nodeMap, f = new q(e), h = n.length - 1; h >= 0; h--) {\n                  var c = t.findBackwardEdge(s, f.edges[n[h]], f.edges[n[0]], f);\n\n                  if (c) {\n                    var l = t.dfsCode.dfsEdgeList[n[h]].fromNode + \"-\" + c.label;\n                    d[l] || (d[l] = {\n                      projected: [],\n                      toNodeId: t.dfsCode.dfsEdgeList[n[h]].fromNode,\n                      edgeLabel: c.label\n                    }), d[l].projected.push({\n                      graphId: e.graphId,\n                      edge: c,\n                      preNode: e\n                    });\n                  }\n                }\n\n                if (!(r >= t.maxNodeNum)) {\n                  t.findForwardPureEdges(s, f.edges[n[0]], i, f).forEach(function (t) {\n                    var r = o + \"-\" + t.label + \"-\" + u[t.to].label;\n                    a[r] || (a[r] = {\n                      projected: [],\n                      fromNodeId: o,\n                      edgeLabel: t.label,\n                      nodeLabel2: u[t.to].label\n                    }), a[r].projected.push({\n                      graphId: e.graphId,\n                      edge: t,\n                      preNode: e\n                    });\n                  });\n\n                  var p = function (r) {\n                    t.findForwardRmpathEdges(s, f.edges[n[r]], i, f).forEach(function (o) {\n                      var i = t.dfsCode.dfsEdgeList[n[r]].fromNode + \"-\" + o.label + \"-\" + u[o.to].label;\n                      a[i] || (a[i] = {\n                        projected: [],\n                        fromNodeId: t.dfsCode.dfsEdgeList[n[r]].fromNode,\n                        edgeLabel: o.label,\n                        nodeLabel2: u[o.to].label\n                      }), a[i].projected.push({\n                        graphId: e.graphId,\n                        edge: o,\n                        preNode: e\n                      });\n                    });\n                  };\n\n                  for (h = 0; h < n.length; h++) p(h);\n                }\n              }), Object.keys(d).forEach(function (e) {\n                var r = d[e],\n                    n = r.toNodeId,\n                    i = r.edgeLabel;\n                t.dfsCode.dfsEdgeList.push(new T(o, n, \"-1\", i, \"-1\")), t.subGraphMining(d[e].projected), t.dfsCode.dfsEdgeList.pop();\n              }), Object.keys(a).forEach(function (e) {\n                var r = a[e],\n                    n = r.fromNodeId,\n                    i = r.edgeLabel,\n                    d = r.nodeLabel2;\n                t.dfsCode.dfsEdgeList.push(new T(n, o + 1, A, i, d)), t.subGraphMining(a[e].projected), t.dfsCode.dfsEdgeList.pop();\n              });\n            }\n          }, e.prototype.generate1EdgeFrequentSubGraphs = function () {\n            var e = this.graphs,\n                t = this.directed,\n                r = this.minSupport,\n                n = this.frequentSize1Subgraphs,\n                o = {},\n                i = {},\n                a = {},\n                d = {};\n            return Object.keys(e).forEach(function (r) {\n              var n = e[r],\n                  s = n.nodeMap;\n              n.nodes.forEach(function (e, n) {\n                var u = e.label,\n                    f = r + \"-\" + u;\n\n                if (!a[f]) {\n                  var h = o[u] || 0;\n                  h++, o[u] = h;\n                }\n\n                a[f] = {\n                  graphKey: r,\n                  label: u\n                }, e.edges.forEach(function (e) {\n                  var n = u,\n                      o = s[e.to].label;\n\n                  if (!t && n > o) {\n                    var a = o;\n                    o = n, n = a;\n                  }\n\n                  var f = e.label,\n                      h = r + \"-\" + n + \"-\" + f + \"-\" + o,\n                      c = n + \"-\" + f + \"-\" + o;\n\n                  if (!i[c]) {\n                    var l = i[c] || 0;\n                    l++, i[c] = l;\n                  }\n\n                  d[h] = {\n                    graphId: r,\n                    nodeLabel1: n,\n                    edgeLabel: f,\n                    nodeLabel2: o\n                  };\n                });\n              });\n            }), Object.keys(o).forEach(function (e) {\n              if (!(o[e] < r)) {\n                var t = {\n                  nodes: [],\n                  edges: []\n                };\n                t.nodes.push({\n                  id: \"0\",\n                  label: e\n                }), n.push(t);\n              }\n            }), n;\n          }, e.prototype.run = function () {\n            var e = this;\n\n            if (this.frequentSize1Subgraphs = this.generate1EdgeFrequentSubGraphs(), !(this.maxNodeNum < 2)) {\n              var t = this.graphs,\n                  r = (this.directed, {});\n              Object.keys(t).forEach(function (n) {\n                var o = t[n],\n                    i = o.nodeMap;\n                o.nodes.forEach(function (t) {\n                  e.findForwardRootEdges(o, t).forEach(function (e) {\n                    var o = i[e.to],\n                        a = t.label + \"-\" + e.label + \"-\" + o.label;\n                    r[a] || (r[a] = {\n                      projected: [],\n                      nodeLabel1: t.label,\n                      edgeLabel: e.label,\n                      nodeLabel2: o.label\n                    });\n                    var d = {\n                      graphId: n,\n                      edge: e,\n                      preNode: null\n                    };\n                    r[a].projected.push(d);\n                  });\n                });\n              }), Object.keys(r).forEach(function (t) {\n                var n = r[t],\n                    o = n.projected,\n                    i = n.nodeLabel1,\n                    a = n.edgeLabel,\n                    d = n.nodeLabel2;\n                e.dfsCode.dfsEdgeList.push(new T(0, 1, i, a, d)), e.subGraphMining(o), e.dfsCode.dfsEdgeList.pop();\n              });\n            }\n          }, e;\n        }(),\n            R = \"cluster\";\n\n        var G = function (e, t, r, n) {\n          void 0 === r && (r = \"cluster\"), void 0 === n && (n = 2);\n          var o = [],\n              i = e.nodes;\n          return t.forEach(function (e, t) {\n            o.push(U(i, e, t, r, n));\n          }), o;\n        },\n            U = function (e, t, r, n, o) {\n          var i = [r],\n              a = [],\n              d = {};\n          return t.forEach(function (t, s) {\n            if (t <= o && r !== s) {\n              i.push(s), a.push(e[s]);\n              var u = e[s][n];\n              d[u] ? (d[u].count++, d[u].dists.push(t)) : d[u] = {\n                count: 1,\n                dists: [t]\n              };\n            }\n          }), Object.keys(d).forEach(function (e) {\n            d[e].dists = d[e].dists.sort(function (e, t) {\n              return e - t;\n            });\n          }), {\n            nodeIdx: r,\n            nodeId: e[r].id,\n            nodeIdxs: i,\n            neighbors: a,\n            neighborNum: i.length - 1,\n            nodeLabelCountMap: d\n          };\n        },\n            B = function (e, t, r, n) {\n          var o = r.nodes;\n          return n || (n = {}), Object.keys(e).forEach(function (i) {\n            var a, d;\n\n            if (!n || !n[i]) {\n              n[i] = {\n                nodes: [],\n                edges: []\n              };\n              var s = e[i],\n                  u = null === (a = t[s.start]) || void 0 === a ? void 0 : a.nodeIdxs,\n                  f = null === (d = t[s.end]) || void 0 === d ? void 0 : d.nodeIdxs;\n\n              if (u && f) {\n                var h = new Set(f),\n                    c = u.filter(function (e) {\n                  return h.has(e);\n                });\n\n                if (c && c.length) {\n                  for (var l = {}, p = c.length, v = 0; v < p; v++) {\n                    var g = o[c[v]];\n                    n[i].nodes.push(g), l[g.id] = !0;\n                  }\n\n                  r.edges.forEach(function (e) {\n                    l[e.source] && l[e.target] && n[i].edges.push(e);\n                  });\n                }\n              }\n            }\n          }), n;\n        },\n            z = function (e, t, r, n) {\n          var o = {};\n          e.nodes.forEach(function (e) {\n            o[e.id] = e;\n          });\n          var i = 0;\n          return e.edges.forEach(function (e) {\n            var a = o[e.source][r],\n                d = o[e.target][r],\n                s = t.nodes[0][r],\n                u = t.nodes[1][r],\n                f = t.edges[0][n];\n            e[n] === f && (a === s && d === u || a === u && d === s) && i++;\n          }), i;\n        },\n            _ = function (e, t) {\n          var r = {},\n              n = {};\n          return e.forEach(function (e, o) {\n            r[e.id] = {\n              idx: o,\n              node: e,\n              degree: 0\n            };\n            var i = e[t];\n            n[i] || (n[i] = []), n[i].push(e);\n          }), {\n            nodeMap: r,\n            nodeLabelMap: n\n          };\n        },\n            H = function (e, t, r) {\n          var n = {},\n              o = {};\n          return e.forEach(function (e, i) {\n            n[\"\" + f] = {\n              idx: i,\n              edge: e\n            };\n            var a = e[t];\n            o[a] || (o[a] = []), o[a].push(e);\n            var d = r[e.source];\n            d && d.degree++;\n            var s = r[e.target];\n            s && s.degree++;\n          }), {\n            edgeMap: n,\n            edgeLabelMap: o\n          };\n        },\n            W = function (e, t, r) {\n          var n = t.length,\n              o = {};\n          return t.forEach(function (t, i) {\n            for (var a = r ? 0 : i + 1, d = e[i].id, s = a; s < n; s++) if (i !== s) {\n              var u = e[s].id,\n                  f = t[s];\n              o[d + \"-\" + u] = f, r || (o[u + \"-\" + d] = f);\n            }\n          }), o;\n        };\n\n        var K = function () {\n          function e(e) {\n            void 0 === e && (e = 10), this.linkedList = new a(), this.maxStep = e;\n          }\n\n          return Object.defineProperty(e.prototype, \"length\", {\n            get: function () {\n              return this.linkedList.toArray().length;\n            },\n            enumerable: !1,\n            configurable: !0\n          }), e.prototype.isEmpty = function () {\n            return !this.linkedList.head;\n          }, e.prototype.isMaxStack = function () {\n            return this.toArray().length >= this.maxStep;\n          }, e.prototype.peek = function () {\n            return this.isEmpty() ? null : this.linkedList.head.value;\n          }, e.prototype.push = function (e) {\n            this.linkedList.prepend(e), this.length > this.maxStep && this.linkedList.deleteTail();\n          }, e.prototype.pop = function () {\n            var e = this.linkedList.deleteHead();\n            return e ? e.value : null;\n          }, e.prototype.toArray = function () {\n            return this.linkedList.toArray().map(function (e) {\n              return e.value;\n            });\n          }, e.prototype.clear = function () {\n            for (; !this.isEmpty();) this.pop();\n          }, e;\n        }(),\n            J = \"SUCCESS\";\n\n        const Q = function (e) {\n          return function () {\n            for (var t = [], n = 0; n < arguments.length; n++) t[n] = arguments[n];\n\n            return new Promise(function (n, o) {\n              r.e(1).then(r.bind(r, 1)).then(function (r) {\n                var i = new r.default();\n                i.postMessage({\n                  type: e,\n                  data: t\n                }), i.onmessage = function (e) {\n                  var t = e.data,\n                      r = t.data,\n                      a = t.type;\n                  J === a ? n(r) : o(), i.terminate();\n                };\n              });\n            });\n          };\n        },\n              V = {\n          getAdjMatrix: n,\n          breadthFirstSearch: function (e, t, r) {\n            var n = function (e) {\n              void 0 === e && (e = {});\n\n              var t,\n                  r = e,\n                  n = function () {},\n                  o = (t = {}, function (e) {\n                var r = e.next;\n                return !t[r] && (t[r] = !0, !0);\n              });\n\n              return r.allowTraversal = e.allowTraversal || o, r.enter = e.enter || n, r.leave = e.leave || n, r;\n            }(r),\n                o = new d(),\n                i = e.edges,\n                a = void 0 === i ? [] : i;\n\n            o.enqueue(t);\n\n            for (var u = \"\", f = function () {\n              var e = o.dequeue();\n              n.enter({\n                current: e,\n                previous: u\n              }), s(e, a, \"target\").forEach(function (t) {\n                n.allowTraversal({\n                  previous: u,\n                  current: e,\n                  next: t\n                }) && o.enqueue(t);\n              }), n.leave({\n                current: e,\n                previous: u\n              }), u = e;\n            }; !o.isEmpty();) f();\n          },\n          connectedComponent: function (e, t) {\n            return t ? function (e) {\n              for (var t = e.nodes, r = void 0 === t ? [] : t, n = e.edges, o = void 0 === n ? [] : n, i = [], a = {}, d = {}, u = {}, f = [], h = 0, c = function (e) {\n                d[e.id] = h, u[e.id] = h, h += 1, i.push(e), a[e.id] = !0;\n\n                for (var t = s(e.id, o, \"target\").filter(function (e) {\n                  return r.map(function (e) {\n                    return e.id;\n                  }).indexOf(e) > -1;\n                }), n = function (n) {\n                  var o = t[n];\n                  if (d[o] || 0 === d[o]) a[o] && (u[e.id] = Math.min(u[e.id], d[o]));else {\n                    var i = r.filter(function (e) {\n                      return e.id === o;\n                    });\n                    i.length > 0 && c(i[0]), u[e.id] = Math.min(u[e.id], u[o]);\n                  }\n                }, l = 0; l < t.length; l++) n(l);\n\n                if (u[e.id] === d[e.id]) {\n                  for (var p = []; i.length > 0;) {\n                    var v = i.pop();\n                    if (a[v.id] = !1, p.push(v), v === e) break;\n                  }\n\n                  p.length > 0 && f.push(p);\n                }\n              }, l = 0, p = r; l < p.length; l++) {\n                var v = p[l];\n                d[v.id] || 0 === d[v.id] || c(v);\n              }\n\n              return f;\n            }(e) : function (e) {\n              for (var t = e.nodes, r = void 0 === t ? [] : t, n = e.edges, o = void 0 === n ? [] : n, i = [], a = {}, d = [], u = function (e) {\n                d.push(e), a[e.id] = !0;\n\n                for (var t = s(e.id, o), n = function (e) {\n                  var n = t[e];\n\n                  if (!a[n]) {\n                    var o = r.filter(function (e) {\n                      return e.id === n;\n                    });\n                    o.length > 0 && u(o[0]);\n                  }\n                }, i = 0; i < t.length; ++i) n(i);\n              }, f = 0; f < r.length; f++) {\n                var h = r[f];\n\n                if (!a[h.id]) {\n                  u(h);\n\n                  for (var c = []; d.length > 0;) c.push(d.pop());\n\n                  i.push(c);\n                }\n              }\n\n              return i;\n            }(e);\n          },\n          getDegree: c,\n          getInDegree: function (e, t) {\n            return h(e)[t] ? h(e)[t].inDegree : 0;\n          },\n          getOutDegree: function (e, t) {\n            return h(e)[t] ? h(e)[t].outDegree : 0;\n          },\n          detectCycle: function (e) {\n            var t = null,\n                r = e.nodes,\n                n = {},\n                o = {},\n                i = {},\n                a = {};\n            (void 0 === r ? [] : r).forEach(function (e) {\n              o[e.id] = e;\n            });\n\n            for (var d = {\n              enter: function (e) {\n                var r = e.current,\n                    a = e.previous;\n\n                if (i[r]) {\n                  t = {};\n\n                  for (var d = r, s = a; s !== r;) t[d] = s, d = s, s = n[s];\n\n                  t[d] = s;\n                } else i[r] = r, delete o[r], n[r] = a;\n              },\n              leave: function (e) {\n                var t = e.current;\n                a[t] = t, delete i[t];\n              },\n              allowTraversal: function (e) {\n                var r = e.next;\n                return !t && !a[r];\n              }\n            }; Object.keys(o).length;) p(e, Object.keys(o)[0], d);\n\n            return t;\n          },\n          depthFirstSearch: p,\n          dijkstra: L,\n          findAllPath: function (e, t, r, n) {\n            var o;\n            if (t === r) return [[t]];\n            var i = e.edges,\n                a = void 0 === i ? [] : i,\n                d = [t],\n                u = ((o = {})[t] = !0, o),\n                f = [],\n                h = [],\n                c = n ? s(t, a, \"target\") : s(t, a);\n\n            for (f.push(c); d.length > 0 && f.length > 0;) {\n              var l = f[f.length - 1];\n\n              if (l.length) {\n                var p = l.shift();\n\n                if (p && (d.push(p), u[p] = !0, c = n ? s(p, a, \"target\") : s(p, a), f.push(c.filter(function (e) {\n                  return !u[e];\n                }))), d[d.length - 1] === r) {\n                  var v = d.map(function (e) {\n                    return e;\n                  });\n                  h.push(v), g = d.pop(), u[g] = !1, f.pop();\n                }\n              } else {\n                var g = d.pop();\n                u[g] = !1, f.pop();\n              }\n            }\n\n            return h;\n          },\n          findShortestPath: function (e, t, r, n, o) {\n            var i = L(e, t, n, o),\n                a = i.length,\n                d = i.path,\n                s = i.allPaths;\n            return {\n              length: a[r],\n              path: d[r],\n              allPath: s[r]\n            };\n          },\n          floydWarshall: k,\n          labelPropagation: function (e, t, r, o) {\n            void 0 === t && (t = !1), void 0 === r && (r = \"weight\"), void 0 === o && (o = 1e3);\n            var i = e.nodes,\n                a = void 0 === i ? [] : i,\n                d = e.edges,\n                s = void 0 === d ? [] : d,\n                u = {},\n                h = {};\n            a.forEach(function (e, t) {\n              var r = f();\n              e.clusterId = r, u[r] = {\n                id: r,\n                nodes: [e]\n              }, h[e.id] = {\n                node: e,\n                idx: t\n              };\n            });\n            var c = n(e, t),\n                l = [],\n                p = {};\n            c.forEach(function (e, t) {\n              var r = 0,\n                  n = a[t].id;\n              p[n] = {}, e.forEach(function (e, t) {\n                if (e) {\n                  r += e;\n                  var o = a[t].id;\n                  p[n][o] = e;\n                }\n              }), l.push(r);\n            });\n\n            for (var v = 0, g = function () {\n              var e = !1;\n              if (a.forEach(function (t) {\n                var r = {};\n                Object.keys(p[t.id]).forEach(function (e) {\n                  var n = p[t.id][e],\n                      o = h[e].node.clusterId;\n                  r[o] || (r[o] = 0), r[o] += n;\n                });\n                var n = -1 / 0,\n                    o = [];\n\n                if (Object.keys(r).forEach(function (e) {\n                  n < r[e] ? (n = r[e], o = [e]) : n === r[e] && o.push(e);\n                }), 1 !== o.length || o[0] !== t.clusterId) {\n                  var i = o.indexOf(t.clusterId);\n\n                  if (i >= 0 && o.splice(i, 1), o && o.length) {\n                    e = !0;\n                    var a = u[t.clusterId],\n                        d = a.nodes.indexOf(t);\n                    a.nodes.splice(d, 1);\n                    var s = Math.floor(Math.random() * o.length),\n                        f = u[o[s]];\n                    f.nodes.push(t), t.clusterId = f.id;\n                  }\n                }\n              }), !e) return \"break\";\n              v++;\n            }; v < o && \"break\" !== g(););\n\n            Object.keys(u).forEach(function (e) {\n              var t = u[e];\n              t.nodes && t.nodes.length || delete u[e];\n            });\n            var b = [],\n                y = {};\n            s.forEach(function (e) {\n              var t = e.source,\n                  n = e.target,\n                  o = e[r] || 1,\n                  i = h[t].node.clusterId,\n                  a = h[n].node.clusterId,\n                  d = i + \"---\" + a;\n              if (y[d]) y[d].weight += o, y[d].count++;else {\n                var s = {\n                  source: i,\n                  target: a,\n                  weight: o,\n                  count: 1\n                };\n                y[d] = s, b.push(s);\n              }\n            });\n            var m = [];\n            return Object.keys(u).forEach(function (e) {\n              m.push(u[e]);\n            }), {\n              clusters: m,\n              clusterEdges: b\n            };\n          },\n          louvain: function (e, t, r, o) {\n            void 0 === t && (t = !1), void 0 === r && (r = \"weight\"), void 0 === o && (o = 1e-4);\n            var i = e.nodes,\n                a = void 0 === i ? [] : i,\n                d = e.edges,\n                s = void 0 === d ? [] : d,\n                u = {},\n                h = {};\n            a.forEach(function (e, t) {\n              var r = f();\n              e.clusterId = r, u[r] = {\n                id: r,\n                nodes: [e]\n              }, h[e.id] = {\n                node: e,\n                idx: t\n              };\n            });\n            var c = n(e, t),\n                l = [],\n                p = {},\n                v = 0;\n            c.forEach(function (e, t) {\n              var r = 0,\n                  n = a[t].id;\n              p[n] = {}, e.forEach(function (e, t) {\n                if (e) {\n                  r += e;\n                  var o = a[t].id;\n                  p[n][o] = e, v += e;\n                }\n              }), l.push(r);\n            }), v /= 2;\n\n            for (var g = 1 / 0, b = 1 / 0, y = 0; g = j(a, c, l, v), !(Math.abs(g - b) < o || y > 100);) b = g, y++, Object.keys(u).forEach(function (e) {\n              var t = 0;\n              s.forEach(function (n) {\n                var o = n.source,\n                    i = n.target,\n                    a = h[o].node.clusterId,\n                    d = h[i].node.clusterId;\n                (a === e && d !== e || d === e && a !== e) && (t += n[r] || 1);\n              }), u[e].sumTot = t;\n            }), a.forEach(function (e, t) {\n              var n,\n                  o = u[e.clusterId],\n                  i = 0,\n                  a = l[t] / (2 * v),\n                  d = 0;\n              o.nodes.forEach(function (e) {\n                var r = h[e.id].idx;\n                d += c[t][r] || 0;\n              });\n              var f = d - o.sumTot * a,\n                  g = p[e.id];\n\n              if (Object.keys(g).forEach(function (r) {\n                var o = h[r].node.clusterId;\n\n                if (o !== e.clusterId) {\n                  var d = u[o],\n                      s = d.nodes;\n\n                  if (s && s.length) {\n                    var l = 0;\n                    s.forEach(function (e) {\n                      var r = h[e.id].idx;\n                      l += c[t][r] || 0;\n                    });\n                    var p = l - d.sumTot * a - f;\n                    p > i && (i = p, n = d);\n                  }\n                }\n              }), i > 0) {\n                n.nodes.push(e);\n                var b = e.clusterId;\n                e.clusterId = n.id;\n                var y = o.nodes.indexOf(e);\n                o.nodes.splice(y, 1);\n                var m = 0,\n                    E = 0;\n                s.forEach(function (e) {\n                  var t = e.source,\n                      o = e.target,\n                      i = h[t].node.clusterId,\n                      a = h[o].node.clusterId;\n                  (i === n.id && a !== n.id || a === n.id && i !== n.id) && (m += e[r] || 1), (i === b && a !== b || a === b && i !== b) && (E += e[r] || 1);\n                }), n.sumTot = m, o.sumTot = E;\n              }\n            });\n\n            Object.keys(u).forEach(function (e) {\n              var t = u[e];\n              t.nodes && t.nodes.length || delete u[e];\n            });\n            var m = [],\n                E = {};\n            s.forEach(function (e) {\n              var t = e.source,\n                  n = e.target,\n                  o = e[r] || 1,\n                  i = h[t].node.clusterId,\n                  a = h[n].node.clusterId,\n                  d = i + \"---\" + a;\n              if (E[d]) E[d].weight += o, E[d].count++;else {\n                var s = {\n                  source: i,\n                  target: a,\n                  weight: o,\n                  count: 1\n                };\n                E[d] = s, m.push(s);\n              }\n            });\n            var L = [];\n            return Object.keys(u).forEach(function (e) {\n              L.push(u[e]);\n            }), {\n              clusters: L,\n              clusterEdges: m\n            };\n          },\n          minimumSpanningTree: function (e, t, r) {\n            return r ? {\n              prim: O,\n              kruskal: I\n            }[r](e, t) : I(e, t);\n          },\n          pageRank: function (e, t, r) {\n            \"number\" != typeof t && (t = 1e-6), \"number\" != typeof r && (r = .85);\n\n            for (var n, o = 1, i = 0, a = 1e3, d = e.nodes, u = void 0 === d ? [] : d, f = e.edges, h = void 0 === f ? [] : f, l = u.length, p = {}, v = {}, g = 0; g < l; ++g) p[y = (k = u[g]).id] = 1 / l, v[y] = 1 / l;\n\n            for (var b = c(e); a > 0 && o > t;) {\n              for (i = 0, g = 0; g < l; ++g) {\n                var y = (k = u[g]).id;\n                if (n = 0, 0 === b[k.id].inDegree) p[y] = 0;else {\n                  for (var m = s(y, h, \"source\"), E = 0; E < m.length; ++E) {\n                    var L = m[E],\n                        N = b[L].outDegree;\n                    N > 0 && (n += v[L] / N);\n                  }\n\n                  p[y] = r * n, i += p[y];\n                }\n              }\n\n              for (i = (1 - i) / l, o = 0, g = 0; g < l; ++g) {\n                var k;\n                n = p[y = (k = u[g]).id] + i, o += Math.abs(n - v[y]), v[y] = n;\n              }\n\n              a -= 1;\n            }\n\n            return v;\n          },\n          getNeighbors: s,\n          Stack: K,\n          GADDI: function (e, t, r, n, o, i, a) {\n            if (void 0 === r && (r = !1), void 0 === i && (i = \"cluster\"), void 0 === a && (a = \"cluster\"), e && e.nodes) {\n              var d = e.nodes.length;\n\n              if (d) {\n                var s = k(e, r),\n                    u = k(t, r),\n                    f = W(e.nodes, s, r),\n                    h = W(t.nodes, u, r),\n                    c = _(e.nodes, i),\n                    l = c.nodeMap,\n                    p = c.nodeLabelMap,\n                    g = _(t.nodes, i),\n                    b = g.nodeMap,\n                    y = g.nodeLabelMap;\n\n                H(e.edges, a, l);\n                var m = H(t.edges, a, b).edgeLabelMap;\n                o || (o = Math.max.apply(Math, v(u[0], [2]))), n || (n = o);\n\n                var E = G(e, s, i, n),\n                    N = G(t, u, i, n),\n                    j = function (e, t, r, n, o) {\n                  var i = Math.ceil(r / t),\n                      a = {},\n                      d = 0;\n                  return n.forEach(function (e, n) {\n                    for (var s = 0, u = 0, f = e.nodeIdxs, h = e.neighborNum - 1; s < i;) {\n                      for (var c = f[1 + Math.floor(Math.random() * h)], l = 0; (a[n + \"-\" + c] || a[c + \"-\" + n]) && (c = Math.floor(Math.random() * t), !(++l > 2 * t)););\n\n                      if (l < 2 * t && (a[n + \"-\" + c] = {\n                        start: n,\n                        end: c,\n                        distance: o[n][c]\n                      }, s++, ++d >= r)) return a;\n                      if (++u > 2 * t) break;\n                    }\n\n                    s < i && (i = (i + (i - s)) / (t - n - 1));\n                  }), a;\n                }(0, d, Math.min(100, d * (d - 1) / 2), N, s),\n                    M = B(j, E, e),\n                    x = function (e) {\n                  var t = e.graphs,\n                      r = e.directed,\n                      n = void 0 !== r && r,\n                      o = e.nodeLabelProp,\n                      i = void 0 === o ? R : o,\n                      a = e.edgeLabelProp,\n                      d = void 0 === a ? R : a,\n                      s = function (e, t, r, n) {\n                    var o = {};\n                    return Object.keys(e).forEach(function (i, a) {\n                      var d = e[i],\n                          s = new P(a, !0, t),\n                          u = {};\n                      d.nodes.forEach(function (e, t) {\n                        s.addNode(t, e[r]), u[e.id] = t;\n                      }), d.edges.forEach(function (e, t) {\n                        var r = u[e.source],\n                            o = u[e.target];\n                        s.addEdge(-1, r, o, e[n]);\n                      }), s && s.getNodeNum() && (o[s.id] = s);\n                    }), o;\n                  }(t, n, i, d),\n                      u = e.minSupport,\n                      f = e.maxNodeNum,\n                      h = e.minNodeNum,\n                      c = e.verbose,\n                      l = e.top,\n                      p = new F({\n                    graphs: s,\n                    minSupport: u,\n                    maxNodeNum: f,\n                    minNodeNum: h,\n                    top: l,\n                    verbose: c,\n                    directed: n\n                  });\n\n                  return p.run(), function (e, t, r) {\n                    var n = [];\n                    return e.forEach(function (e) {\n                      var o = {\n                        nodes: [],\n                        edges: []\n                      };\n                      e.nodes.forEach(function (e) {\n                        var r;\n                        o.nodes.push(((r = {\n                          id: \"\" + e.id\n                        })[t] = e.label, r));\n                      }), e.edges.forEach(function (e) {\n                        var t;\n                        o.edges.push(((t = {\n                          source: \"\" + e.from,\n                          target: \"\" + e.to\n                        })[r] = e.label, t));\n                      }), n.push(o);\n                    }), n;\n                  }(p.frequentSubgraphs, i, d);\n                }({\n                  graphs: M,\n                  nodeLabelProp: i,\n                  edgeLabelProp: a,\n                  minSupport: 1,\n                  minNodeNum: 1,\n                  maxNodeNum: 4,\n                  directed: r\n                }).slice(0, 10),\n                    w = x.length,\n                    O = [];\n\n                x.forEach(function (e, t) {\n                  O[t] = {}, Object.keys(M).forEach(function (r) {\n                    var n = M[r],\n                        o = z(n, e, i, a);\n                    O[t][r] = o;\n                  });\n                });\n\n                var I = function (e, t, r) {\n                  for (var n = 1 / 0, o = 0, i = function (t) {\n                    var r = e[t],\n                        i = Object.keys(r).sort(function (e, t) {\n                      return r[e] - r[t];\n                    }),\n                        a = [];\n                    i.forEach(function (e, t) {\n                      a[t % 10] || (a[t % 10] = {\n                        graphs: [],\n                        totalCount: 0,\n                        aveCount: 0\n                      }), a[t % 10].graphs.push(e), a[t % 10].totalCount += r[e];\n                    });\n                    var d = 0,\n                        s = [];\n                    a.forEach(function (e) {\n                      var t = e.totalCount / e.graphs.length;\n                      e.aveCount = t, s.push(t);\n                      var n = 0,\n                          o = e.length;\n                      e.graphs.forEach(function (t, o) {\n                        var i = r[t];\n                        e.graphs.forEach(function (e, t) {\n                          o !== t && (n += Math.abs(i - r[e]));\n                        });\n                      }), d += n /= o * (o - 1) / 2;\n                    }), d /= a.length;\n                    var u = 0;\n                    s.forEach(function (e, t) {\n                      s.forEach(function (r, n) {\n                        t !== n && (u += Math.abs(e - r));\n                      }), u /= s.length * (s.length - 1) / 2;\n                    });\n                    var f = u - d;\n                    n < f && (n = f, o = t);\n                  }, a = 0; a < t; a++) i(a);\n\n                  return {\n                    structure: r[o],\n                    structureCountMap: e[o]\n                  };\n                }(O, w, x),\n                    A = I.structure,\n                    S = I.structureCountMap,\n                    C = t.nodes[0],\n                    T = C[i],\n                    D = p[T],\n                    q = {},\n                    K = {},\n                    J = {},\n                    Q = {},\n                    V = {};\n\n                Object.keys(y).forEach(function (r, n) {\n                  V[r] = [];\n                  var o = -1 / 0,\n                      d = y[r],\n                      s = {};\n                  d.forEach(function (e) {\n                    var t = h[C.id + \"-\" + e.id];\n                    t && V[r].push(t), o < t && (o = t), s[C.id + \"-\" + e.id] = {\n                      start: 0,\n                      end: b[e.id].idx,\n                      distance: t\n                    };\n                  }), V[r] = V[r].sort(function (e, t) {\n                    return e - t;\n                  }), K = B(s, N, t, K);\n                  var u = [];\n                  if (Object.keys(s).forEach(function (e) {\n                    if (J[e]) u.push(J[e]);else {\n                      var t = K[e];\n                      J[e] = z(t, A, i, a), u.push(J[e]);\n                    }\n                  }), u = u.sort(function (e, t) {\n                    return t - e;\n                  }), Q[C.id + \"-\" + r] = u, r !== T) for (var c = function (t) {\n                    var n = D[t],\n                        o = E[l[n.id].idx],\n                        d = o.nodeLabelCountMap[r],\n                        s = y[r].length;\n                    if (!d || d.count < s) return D.splice(t, 1), \"continue\";\n\n                    for (var h = !1, c = 0; c < s; c++) if (d.dists[c] > V[r][c]) {\n                      h = !0;\n                      break;\n                    }\n\n                    if (h) return D.splice(t, 1), \"continue\";\n                    var p = {};\n                    o.neighbors.forEach(function (e) {\n                      var t = f[n.id + \"-\" + e.id];\n                      p[n.id + \"-\" + e.id] = {\n                        start: l[n.id].idx,\n                        end: l[e.id].idx,\n                        distance: t\n                      };\n                    }), M = B(p, E, e, M);\n                    var v = [];\n                    Object.keys(p).forEach(function (e) {\n                      if (S[e]) v.push(S[e]);else {\n                        var t = M[e];\n                        S[e] = z(t, A, i, a), v.push(S[e]);\n                      }\n                    }), v = v.sort(function (e, t) {\n                      return t - e;\n                    });\n                    var g = !1;\n\n                    for (c = 0; c < s; c++) if (v[c] < u[c]) {\n                      g = !0;\n                      break;\n                    }\n\n                    return g ? (D.splice(t, 1), \"continue\") : void 0;\n                  }, p = D.length - 1; p >= 0; p--) c(p);\n                });\n                var X = [];\n                D.forEach(function (r) {\n                  for (var n = l[r.id].idx, d = U(e.nodes, s[n], n, i, o).neighbors, u = d.length, h = !1, c = function (n) {\n                    if (d.length + 1 < t.nodes.length) return h = !0, {\n                      value: void 0\n                    };\n                    var o = d[n],\n                        s = o[i];\n                    if (!y[s] || !y[s].length) return d.splice(n, 1), \"continue\";\n                    var u = r.id + \"-\" + o.id;\n                    if (!V[s] || !V[s].length) return d.splice(n, 1), \"continue\";\n                    var c = f[u];\n                    if (c > V[s][V[s].length - 1]) return d.splice(n, 1), \"continue\";\n                    var p = S[u] ? S[u] : function (e, t, r, n, o, i, a, d, s, u, f) {\n                      var h,\n                          c = t.id + \"-\" + r.id;\n                      if (u && u[c]) return u[c];\n                      var l = f ? f[c] : void 0;\n\n                      if (!l) {\n                        var p = ((h = {})[c] = {\n                          start: n[t.id].idx,\n                          end: n[r.id].idx,\n                          distance: o\n                        }, h);\n                        l = (f = B(p, i, e, f))[c];\n                      }\n\n                      return z(l, a, d, s);\n                    }(e, r, o, l, c, E, A, i, a, S, M),\n                        v = C.id + \"-\" + s;\n                    if (p < Q[v][Q[v].length - 1]) return d.splice(n, 1), \"continue\";\n                    var g = q[s];\n                    return void 0 === g && (g = 1 / 0, y[s].forEach(function (e) {\n                      var t = b[e.id].degree;\n                      g > t && (g = t);\n                    }), q[s] = g), l[o.id].degree < g ? (d.splice(n, 1), \"continue\") : void 0;\n                  }, p = u - 1; p >= 0; p--) {\n                    var v = c(p);\n                    if (\"object\" == typeof v) return v.value;\n                  }\n\n                  h || X.push({\n                    nodes: [r].concat(d)\n                  });\n                });\n                var Y = L(t, C.id, !1).length,\n                    Z = {};\n                r ? (Object.keys(Y).forEach(function (e) {\n                  var t = b[e].node[i];\n                  Z[t] ? Z[t].push(Y[e]) : Z[t] = [Y[e]];\n                }), Object.keys(Z).forEach(function (e) {\n                  Z[e].sort(function (e, t) {\n                    return e - t;\n                  });\n                })) : Z = V;\n\n                for (var $ = function (n) {\n                  var o = X[n],\n                      d = o.nodes[0],\n                      s = {},\n                      u = {};\n                  o.nodes.forEach(function (e, t) {\n                    u[e.id] = {\n                      idx: t,\n                      node: e,\n                      degree: 0\n                    };\n                    var r = e[i];\n                    s[r] ? s[r]++ : s[r] = 1;\n                  });\n                  var f = [],\n                      h = {};\n                  e.edges.forEach(function (e) {\n                    u[e.source] && u[e.target] && (f.push(e), h[e[a]] ? h[e[a]]++ : h[e[a]] = 1, u[e.source].degree++, u[e.target].degree++);\n                  });\n\n                  for (var c = Object.keys(m).length, p = !1, v = 0; v < c; v++) {\n                    var g = Object.keys(m)[v];\n\n                    if (!h[g] || h[g] < m[g].length) {\n                      p = !0;\n                      break;\n                    }\n                  }\n\n                  if (p) return X.splice(n, 1), \"continue\";\n                  var E = f.length;\n                  if (E < t.edges.length) return X.splice(n, 1), \"break\";\n\n                  var N = !1,\n                      k = function (e) {\n                    var t = f[e],\n                        n = t[a],\n                        o = m[n];\n                    if (!o || !o.length) return h[n]--, o && h[n] < o.length ? (N = !0, \"break\") : (f.splice(e, 1), u[t.source].degree--, u[t.target].degree--, \"continue\");\n                    var d = u[t.source].node[i],\n                        s = u[t.target].node[i],\n                        c = !1;\n                    return o.forEach(function (e) {\n                      var t = b[e.source].node,\n                          n = b[e.target].node;\n                      t[i] === d && n[i] === s && (c = !0), r || t[i] !== s || n[i] !== d || (c = !0);\n                    }), c ? void 0 : (h[n]--, o && h[n] < o.length ? (N = !0, \"break\") : (f.splice(e, 1), u[t.source].degree--, u[t.target].degree--, \"continue\"));\n                  };\n\n                  for (v = E - 1; v >= 0 && \"break\" !== k(v); v--);\n\n                  if (N) return X.splice(n, 1), \"continue\";\n                  o.edges = f;\n                  var j = L(o, o.nodes[0].id, !1).length;\n                  if (Object.keys(j).reverse().forEach(function (e) {\n                    if (e !== o.nodes[0].id && !N) {\n                      if (j[e] === 1 / 0) {\n                        var t = u[e].node[i];\n                        if (s[t]--, s[t] < y[t].length) return void (N = !0);\n                        var r = o.nodes.indexOf(u[e].node);\n                        return o.nodes.splice(r, 1), void (u[e] = void 0);\n                      }\n\n                      var n = l[e].node[i];\n\n                      if (!Z[n] || !Z[n].length || j[e] > Z[n][Z[n].length - 1]) {\n                        if (t = u[e].node[i], s[t]--, s[t] < y[t].length) return void (N = !0);\n                        r = o.nodes.indexOf(u[e].node), o.nodes.splice(r, 1), u[e] = void 0;\n                      }\n                    }\n                  }), N) return X.splice(n, 1), \"continue\";\n\n                  for (var M = !0, x = 0; M && !N;) {\n                    if (M = !1, u[d.id].degree < b[C.id].degree) {\n                      N = !0;\n                      break;\n                    }\n\n                    if (s[d[i]] < y[d[i]].length) {\n                      N = !0;\n                      break;\n                    }\n\n                    for (var w = o.nodes.length - 1; w >= 0; w--) {\n                      var O = o.nodes[w],\n                          I = u[O.id].degree,\n                          A = O[i];\n\n                      if (I < q[A]) {\n                        if (s[O[i]]--, s[O[i]] < y[O[i]].length) {\n                          N = !0;\n                          break;\n                        }\n\n                        o.nodes.splice(w, 1), u[O.id] = void 0, M = !0;\n                      }\n                    }\n\n                    if (N || !M && 0 !== x) break;\n\n                    for (var S = (E = f.length) - 1; S >= 0; S--) {\n                      var P = f[S];\n\n                      if (!u[P.source] || !u[P.target]) {\n                        f.splice(S, 1);\n                        var T = P[a];\n\n                        if (h[T]--, u[P.source] && u[P.source].degree--, u[P.target] && u[P.target].degree--, m[T] && h[T] < m[T].length) {\n                          N = !0;\n                          break;\n                        }\n\n                        M = !0;\n                      }\n                    }\n\n                    x++;\n                  }\n\n                  return N || N || o.nodes.length < t.nodes.length || f.length < t.edges.length ? (X.splice(n, 1), \"continue\") : void 0;\n                }, ee = X.length - 1; ee >= 0 && \"break\" !== $(ee); ee--);\n\n                var te = X.length,\n                    re = function (e) {\n                  var t = X[e],\n                      r = {};\n                  t.edges.forEach(function (e) {\n                    var t = e.source + \"-\" + e.target + \"-\" + e.label;\n                    r[t] ? r[t]++ : r[t] = 1;\n                  });\n\n                  for (var n = function (e) {\n                    var t = X[e],\n                        n = {};\n                    t.edges.forEach(function (e) {\n                      var t = e.source + \"-\" + e.target + \"-\" + e.label;\n                      n[t] ? n[t]++ : n[t] = 1;\n                    });\n                    var o = !0;\n                    Object.keys(n).length !== Object.keys(r).length ? o = !1 : Object.keys(r).forEach(function (e) {\n                      n[e] !== r[e] && (o = !1);\n                    }), o && X.splice(e, 1);\n                  }, o = te - 1; o > e; o--) n(o);\n\n                  te = X.length;\n                };\n\n                for (ee = 0; ee <= te - 1; ee++) re(ee);\n\n                return X;\n              }\n            }\n          },\n          getAdjMatrixAsync: function (e, t) {\n            return Q(\"getAdjMatrix\").apply(void 0, [e, t]);\n          },\n          connectedComponentAsync: function (e, t) {\n            return Q(\"connectedComponent\").apply(void 0, [e, t]);\n          },\n          getDegreeAsync: function (e) {\n            return Q(\"getDegree\")(e);\n          },\n          getInDegreeAsync: function (e, t) {\n            return Q(\"getInDegree\")(e, t);\n          },\n          getOutDegreeAsync: function (e, t) {\n            return Q(\"getOutDegree\")(e, t);\n          },\n          detectCycleAsync: function (e) {\n            return Q(\"detectCycle\")(e);\n          },\n          dijkstraAsync: function (e, t, r, n) {\n            return Q(\"dijkstra\").apply(void 0, [e, t, r, n]);\n          },\n          findAllPathAsync: function (e, t, r, n) {\n            return Q(\"findAllPath\").apply(void 0, [e, t, r, n]);\n          },\n          findShortestPathAsync: function (e, t, r, n, o) {\n            return Q(\"findShortestPath\").apply(void 0, [e, t, r, n, o]);\n          },\n          floydWarshallAsync: function (e, t) {\n            return Q(\"floydWarshall\").apply(void 0, [e, t]);\n          },\n          labelPropagationAsync: function (e, t, r, n) {\n            return Q(\"labelPropagation\")(e, t, r, n);\n          },\n          louvainAsync: function (e, t, r, n) {\n            return Q(\"louvain\")(e, t, r, n);\n          },\n          minimumSpanningTreeAsync: function (e, t, r) {\n            return Q(\"minimumSpanningTree\").apply(void 0, [e, t, r]);\n          },\n          pageRankAsync: function (e, t, r) {\n            return Q(\"pageRank\").apply(void 0, [e, t, r]);\n          },\n          getNeighborsAsync: function (e, t, r) {\n            return Q(\"getNeighbors\").apply(void 0, [e, t, r]);\n          },\n          GADDIAsync: function (e, t, r, n, o, i, a) {\n            return void 0 === r && (r = !1), void 0 === i && (i = \"cluster\"), void 0 === a && (a = \"cluster\"), Q(\"GADDI\").apply(void 0, [e, t, r, n, o, i, a]);\n          }\n        };\n      }\n    },\n        n = {};\n\n    function o(e) {\n      if (n[e]) return n[e].exports;\n      var t = n[e] = {\n        exports: {}\n      };\n      return r[e](t, t.exports, o), t.exports;\n    }\n\n    return o.m = r, o.n = e => {\n      var t = e && e.__esModule ? () => e.default : () => e;\n      return o.d(t, {\n        a: t\n      }), t;\n    }, o.d = (e, t) => {\n      for (var r in t) o.o(t, r) && !o.o(e, r) && Object.defineProperty(e, r, {\n        enumerable: !0,\n        get: t[r]\n      });\n    }, o.f = {}, o.e = e => Promise.all(Object.keys(o.f).reduce((t, r) => (o.f[r](e, t), t), [])), o.u = e => e + \".min.js\", o.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t), e = {}, t = \"Algorithm:\", o.l = (r, n, i, a) => {\n      if (e[r]) e[r].push(n);else {\n        var d, s;\n        if (void 0 !== i) for (var u = document.getElementsByTagName(\"script\"), f = 0; f < u.length; f++) {\n          var h = u[f];\n\n          if (h.getAttribute(\"src\") == r || h.getAttribute(\"data-webpack\") == t + i) {\n            d = h;\n            break;\n          }\n        }\n        d || (s = !0, (d = document.createElement(\"script\")).charset = \"utf-8\", d.timeout = 120, o.nc && d.setAttribute(\"nonce\", o.nc), d.setAttribute(\"data-webpack\", t + i), d.src = r), e[r] = [n];\n\n        var c = (t, n) => {\n          d.onerror = d.onload = null, clearTimeout(l);\n          var o = e[r];\n          if (delete e[r], d.parentNode && d.parentNode.removeChild(d), o && o.forEach(e => e(n)), t) return t(n);\n        },\n            l = setTimeout(c.bind(null, void 0, {\n          type: \"timeout\",\n          target: d\n        }), 12e4);\n\n        d.onerror = c.bind(null, d.onerror), d.onload = c.bind(null, d.onload), s && document.head.appendChild(d);\n      }\n    }, o.r = e => {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(e, \"__esModule\", {\n        value: !0\n      });\n    }, o.p = \"./dist\", (() => {\n      var e = {\n        826: 0\n      };\n\n      o.f.j = (t, r) => {\n        var n = o.o(e, t) ? e[t] : void 0;\n        if (0 !== n) if (n) r.push(n[2]);else {\n          var i = new Promise((r, o) => {\n            n = e[t] = [r, o];\n          });\n          r.push(n[2] = i);\n          var a = o.p + o.u(t),\n              d = new Error();\n          o.l(a, r => {\n            if (o.o(e, t) && (0 !== (n = e[t]) && (e[t] = void 0), n)) {\n              var i = r && (\"load\" === r.type ? \"missing\" : r.type),\n                  a = r && r.target && r.target.src;\n              d.message = \"Loading chunk \" + t + \" failed.\\n(\" + i + \": \" + a + \")\", d.name = \"ChunkLoadError\", d.type = i, d.request = a, n[1](d);\n            }\n          }, \"chunk-\" + t, t);\n        }\n      };\n\n      var t = (t, r) => {\n        for (var n, i, [a, d, s] = r, u = 0, f = []; u < a.length; u++) i = a[u], o.o(e, i) && e[i] && f.push(e[i][0]), e[i] = 0;\n\n        for (n in d) o.o(d, n) && (o.m[n] = d[n]);\n\n        for (s && s(o), t && t(r); f.length;) f.shift()();\n      },\n          r = this.webpackChunkAlgorithm = this.webpackChunkAlgorithm || [];\n\n      r.forEach(t.bind(null, 0)), r.push = t.bind(null, r.push.bind(r));\n    })(), o(59);\n  })().default;\n});","map":{"version":3,"sources":["webpack://Algorithm/webpack/universalModuleDefinition","webpack:/Algorithm/webpack/runtime/load script","webpack://Algorithm/src/adjacent-matrix.ts","webpack://Algorithm/src/structs/linked-list.ts","webpack://Algorithm/src/structs/queue.ts","webpack://Algorithm/src/util.ts","webpack://Algorithm/src/degree.ts","webpack://Algorithm/src/dfs.ts","webpack://Algorithm/node_modules/_tslib@2.1.0@tslib/tslib.es6.js","webpack://Algorithm/src/is-type.ts","webpack://Algorithm/src/is-array.ts","webpack://Algorithm/src/keys.ts","webpack://Algorithm/src/pull.ts","webpack://Algorithm/src/pull-at.ts","webpack://Algorithm/src/group-by.ts","webpack://Algorithm/src/is-integer.ts","webpack://Algorithm/src/to-degree.ts","webpack://Algorithm/src/to-integer.ts","webpack://Algorithm/src/to-radian.ts","webpack://Algorithm/src/values.ts","webpack://Algorithm/src/is-prototype.ts","webpack://Algorithm/src/clone.ts","webpack://Algorithm/src/is-empty.ts","webpack://Algorithm/src/pick.ts","webpack://Algorithm/src/cache.ts","webpack://Algorithm/src/dijkstra.ts","webpack://Algorithm/src/floydWarshall.ts","webpack://Algorithm/src/louvain.ts","webpack://Algorithm/src/structs/union-find.ts","webpack://Algorithm/src/structs/binary-heap.ts","webpack://Algorithm/src/mts.ts","webpack://Algorithm/src/gSpan/struct.ts","webpack://Algorithm/src/gSpan/gSpan.ts","webpack://Algorithm/src/gaddi.ts","webpack://Algorithm/src/structs/stack.ts","webpack://Algorithm/src/workers/constant.ts","webpack://Algorithm/src/workers/createWorker.ts","webpack://Algorithm/src/index.ts","webpack://Algorithm/src/bfs.ts","webpack://Algorithm/src/connected-component.ts","webpack://Algorithm/src/detect-cycle.ts","webpack://Algorithm/src/find-path.ts","webpack://Algorithm/src/label-propagation.ts","webpack://Algorithm/src/pageRank.ts","webpack://Algorithm/src/workers/index.ts","webpack://Algorithm/webpack/bootstrap","webpack://Algorithm/webpack/startup","webpack:/Algorithm/webpack/runtime/compat get default export","webpack:/Algorithm/webpack/runtime/define property getters","webpack:/Algorithm/webpack/runtime/ensure chunk","webpack:/Algorithm/webpack/runtime/get javascript chunk filename","webpack:/Algorithm/webpack/runtime/hasOwnProperty shorthand","webpack:/Algorithm/webpack/runtime/make namespace object","webpack://Algorithm/webpack/runtime/publicPath","webpack:/Algorithm/webpack/runtime/jsonp chunk loading"],"names":["root","factory","exports","module","define","amd","this","inProgress","dataWebpackPrefix","__webpack_require__","l","url","done","key","chunkId","push","script","needAttach","undefined","scripts","document","getElementsByTagName","i","length","s","getAttribute","createElement","charset","timeout","nc","setAttribute","src","onScriptComplete","prev","event","onerror","onload","clearTimeout","doneFns","parentNode","removeChild","forEach","fn","setTimeout","bind","type","target","head","appendChild","graphData","directed","edges","matrix","nodeMap","nodes","Error","node","id","edge","sIndex","source","tIndex","defaultComparator","a","b","value","next","callback","comparator","tail","compare","newNode","LinkedListNode","deleteNode","currentNode","deletedTail","deletedHead","values","append","prevNode","nextNode","toArray","map","toString","linkedList","removeHead","deleteHead","nodeId","currentEdges","filter","getEdgesByNodeId","uniqueId","index","Math","random","split","substr","degree","degrees","inDegree","outDegree","callbacks","initiatedCallback","stubCallback","allowTraversalCallback","seen","allowTraversal","enter","leave","depthFirstSearchRecursive","previousNode","current","previous","depthFirstSearch","startNodeId","Object","create","__spreadArrays","il","arguments","r","Array","k","j","jl","rst","obj","default_1","prototype","get","D","marks","minDis","Infinity","minNode","weightPropertyName","nodeIds","prevs","nodeNum","minVertex","minNodeId","getOutEdgesNodeId","edgeTarget","edgeSource","w","weight","allPaths","findAllPaths","path","foundPaths","paths","prevPaths","prePath","adjacentMatrix","dist","size","getModularity","adjMatrix","ks","m","param","modularity","clusteri","clusterId","threshold","clusters","cid","idx","neighbors","row","iid","entry","jid","totalModularity","previousModularity","iter","abs","keys","sumTot","sourceClusterId","targetClusterId","selfCluster","bestIncrease","bestCluster","commonParam","kiin","scNodeIdx","scNode","removeModurarity","nodeNeighborIds","neighborNodeId","neighborClusterId","neighborCluster","clusterNodes","neighborClusterKiin","cNodeIdx","cNode","increase","nodeInSelfClusterIdx","indexOf","splice","cluster","clusterEdges","clusterEdgeMap","newEdgeId","count","newEdge","clustersArray","items","parent","item","rootA","find","rootB","union","defaultCompare","compareFn","list","floor","isEmpty","top","bottom","pop","moveDown","moveUp","getParent","tmp","element","left","getLeft","right","getRight","primMST","selectedEdges","currNode","visited","Set","add","edgeQueue","insert","currEdge","delMin","has","kruskalMST","weightEdges","sort","disjointSet","n","curEdge","shift","connected","algo","prim","kruskal","VACANT_NODE_LABEL","from","to","label","edgeMap","edgeIdAutoIncrease","nodeLabelMap","edgeLabelMap","counter","Node","Edge","addEdge","rEdge","fromNode","toNode","fromNodeLabel","edgeLabel","toNodeLabel","nodeEdgeNodeLabel","nodeLabel1","nodeLabel2","other","formNode","equalTo","rmpath","dfsEdgeList","aLength","DFSedge","graphId","graph","Graph","dfsEdge","fromNodeId","toNodeId","addNode","oldFrom","fromNodeIdx","toNodeIdx","pdfs","his","nodesUsed","edgesUsed","e","preNode","reverse","graphs","dfsCode","DFScode","support","frequentSize1Subgraphs","frequentSubgraphs","minSupport","maxNodeNum","minNodeNum","verbose","reportDF","result","edge1","edge2","history","edge2ToEdges","edgeLength","hasEdge","rightmostEdge","minNodeLabel","rightmostEdgeToId","hasNode","newToNodeLabel","projected","graphMap","pro","minLabel","console","log","toGraph","dfsCodeMin","findForwardRootEdges","otherNode","findMinLabel","projectIsMin","buildRmpath","maxToC","backwardRoot","flag","newTo","end","p","History","backwardEdge","findBackwardEdge","minBackwardEdgeLabel","forwardRoot","newFrom","forwardPureEdges","findForwardPureEdges","pathLength","forwardRmpathEdges","findForwardRmpathEdges","forwardMinEdgeNodeLabel","getNodeNum","getSupport","isMin","report","subGraphMining","nodeLabelCounter","nodeEdgeNodeCounter","nodeLableCounted","nodeEdgeNodeLabelCounted","nodeLabel","graphNodeKey","graphKey","graphNodeEdgeNodeKey","nodeEdgeNodeKey","g","generate1EdgeFrequentSubGraphs","nodeLabelProp","edgeLabelProp","fGraph","nodeIdxMap","sourceIdx","targetIdx","DEFAULT_LABEL_NAME","params","formattedGraphs","formatGraphs","calculator","GSpan","run","toGraphDatas","findKNeighborUnits","spm","units","findKNeighborUnit","unitNodeIdxs","labelCountMap","v","dists","nodeIdx","nodeIdxs","neighborNum","nodeLabelCountMap","maxNodePairNum","kNeighborUnits","nodePairNumEachNode","ceil","nodePairMap","foundNodePairCount","unit","nodePairForICount","outerLoopCount","oidx","innerLoopCount","start","distance","getIntersectNeighborInducedGraph","neighborUnits","cachedInducedGraphMap","pair","startUnitNodeIds","endUnitNodeIds","endSet","intersect","x","intersectIdMap","intersectLength","getMatchedCount","structure","sourceLabel","targetLabel","strNodeLabel1","strNodeLabel2","strEdgeLabel","matchedCountMap","structureNum","structures","maxOffset","representClusterType","countMapI","sortedGraphKeys","totalCount","aveCount","aveIntraDist","aveCounts","graphsInCluster","aveIntraPerCluster","graphsNum","graphKey1","graph1Count","graphKey2","aveInterDist","aveCount1","aveCount2","offset","structureCountMap","getNodeMaps","getEdgeMaps","sourceNode","targetNode","getSpmMap","iId","jId","node1","node2","spDist","cachedNDSMap","cachedInterInducedGraph","interInducedGraph","pairMap","pattern","patternSpm","spmMap","patternSpmMap","patternNodeMap","patternNodeLabelMap","patternEdgeLabelMap","max","patternKNeighborUnits","min","nodePairsMap","findNodePairsRandomly","intGMap","freStructures","slice","subStructureCount","dsG","ndsDist","findRepresentStructure","beginPNode","candidates","minPatternNodeLabelDegreeMap","patternIntGraphMap","patternNDSDist","patternNDSDistMap","patternSpDist","label2","maxDist","patternNodesWithLabel2","patternNodePairMap","nodeWithLabel2","currentPatternNDSDistArray","patternIntGraph","graphNeighborUnit","graphNeighborUnitCountMap","patternLabel2Num","prune2Invalid","cNodePairMap","neighborNode","currentNDSDistArray","intGraph","prune3Invalid","candidateGraphs","candidate","neighborNodes","unmatched","neighborLabel","distToCandidate","ndsToCandidate","getNDSDist","patternKey","minPatternNodeLabelDegree","patternNodeDegree","patternNodeWithLabel","concat","undirectedLengthsToBeginPNode","undirectedLengthsToBeginPNodeLabelMap","pLabel","candidateGraph","candidateNodeLabelCountMap","candidateNodeMap","q","cNodeLabel","candidateEdges","edgeLabelCountMap","pattenrEdgeLabelNum","prunedByEdgeLabel","candidateEdgeNum","candidateGraphInvalid","patternEdgesWithLabel","edgeMatched","patternSource","patternEdge","patternTarget","lengthsToCandidate","targetId","targetNodeLabel","nLabel","degreeChanged","loopCount","o","cgNode","nodeDegree","y","cedge","currentLength","cg1","cg1EdgeMap","cg2","cg2EdgeMap","same","maxStep","prepend","deleteTail","MESSAGE","Promise","resolve","reject","then","worker","Worker","default","postMessage","data","onmessage","terminate","getAdjMatrix","breadthFirstSearch","connectedComponent","getDegree","getInDegree","getOutDegree","detectCycle","dijkstra","findAllPath","findShortestPath","floydWarshall","labelPropagation","louvain","minimumSpanningTree","pageRank","getNeighbors","Stack","GADDI","getAdjMatrixAsync","connectedComponentAsync","getDegreeAsync","getInDegreeAsync","getOutDegreeAsync","detectCycleAsync","dijkstraAsync","findAllPathAsync","findShortestPathAsync","floydWarshallAsync","labelPropagationAsync","louvainAsync","minimumSpanningTreeAsync","pageRankAsync","getNeighborsAsync","GADDIAsync","originalCallbacks","initCallbacks","nodeQueue","enqueue","dequeue","allComponents","nodeStack","getComponent","neighbor","component","inStack","indices","lowLink","targetNodeID","tmpNode","detectConnectedComponents","cycle","dfsParentMap","unvisitedSet","visitingSet","visitedSet","currentCycleNode","previousCycleNode","allPath","isVisited","stack","children","child","maxIteration","changed","neighborClusters","neighborWeight","neighborId","maxWeight","bestClusterIds","selfClusterIdx","randomIdx","epsilon","linkProb","leakedRank","maxIterations","nodesCount","currentRank","curRanks","prevRanks","__webpack_module_cache__","moduleId","__webpack_modules__","getter","__esModule","d","definition","defineProperty","enumerable","f","all","reduce","promises","u","prop","hasOwnProperty","call","Symbol","toStringTag","installedChunks","826","installedChunkData","promise","error","errorType","realSrc","message","name","request","webpackJsonpCallback","parentChunkLoadingFunction","chunkIds","moreModules","runtime","resolves","chunkLoadingGlobal"],"mappings":"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","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Algorithm\"] = factory();\n\telse\n\t\troot[\"Algorithm\"] = factory();\n})(this, function() {\nreturn ","var inProgress = {};\nvar dataWebpackPrefix = \"Algorithm:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\t;\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","import { GraphData, Matrix } from \"./types\";\n\nconst adjMatrix = (graphData: GraphData, directed?: boolean) => {\n  const { nodes, edges } = graphData;\n  const matrix: Matrix[] = [];\n  // map node with index in data.nodes\n  const nodeMap: {\n    [key: string]: number;\n  } = {};\n\n  if (!nodes) {\n    throw new Error(\"invalid nodes data!\");\n  }\n\n  if (nodes) {\n    nodes.forEach((node, i) => {\n      nodeMap[node.id] = i;\n      const row: number[] = [];\n      matrix.push(row);\n    });\n  }\n\n  if (edges) {\n    edges.forEach((edge) => {\n      const { source, target } = edge;\n      const sIndex = nodeMap[source as string];\n      const tIndex = nodeMap[target as string];\n      if ((!sIndex && sIndex !== 0) || (!tIndex && tIndex !== 0)) return;\n      matrix[sIndex][tIndex] = 1;\n      if (!directed) {\n        matrix[tIndex][sIndex] = 1;\n      }\n    });\n  }\n  return matrix;\n};\n\nexport default adjMatrix;\n","const defaultComparator = (a, b) => {\n  if (a === b) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * 链表中单个元素节点\n */\nexport class LinkedListNode {\n  public value;\n\n  public next: LinkedListNode;\n\n  constructor(value, next: LinkedListNode = null) {\n    this.value = value;\n    this.next = next;\n  }\n\n  toString(callback?: any) {\n    return callback ? callback(this.value) : `${this.value}`;\n  }\n}\n\nexport default class LinkedList {\n  public head: LinkedListNode;\n\n  public tail: LinkedListNode;\n\n  public compare: Function;\n\n  constructor(comparator = defaultComparator) {\n    this.head = null;\n    this.tail = null;\n    this.compare = comparator;\n  }\n\n  /**\n   * 将指定元素添加到链表头部\n   * @param value\n   */\n  prepend(value) {\n    // 在头部添加一个节点\n    const newNode = new LinkedListNode(value, this.head);\n    this.head = newNode;\n\n    if (!this.tail) {\n      this.tail = newNode;\n    }\n\n    return this;\n  }\n\n  /**\n   * 将指定元素添加到链表中\n   * @param value\n   */\n  append(value) {\n    const newNode = new LinkedListNode(value);\n\n    // 如果不存在头节点，则将创建的新节点作为头节点\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n\n      return this;\n    }\n\n    // 将新节点附加到链表末尾\n    this.tail.next = newNode;\n    this.tail = newNode;\n\n    return this;\n  }\n\n  /**\n   * 删除指定元素\n   * @param value 要删除的元素\n   */\n  delete(value): LinkedListNode {\n    if (!this.head) {\n      return null;\n    }\n\n    let deleteNode = null;\n\n    // 如果删除的是头部元素，则将next作为头元素\n    while (this.head && this.compare(this.head.value, value)) {\n      deleteNode = this.head;\n      this.head = this.head.next;\n    }\n\n    let currentNode = this.head;\n\n    if (currentNode !== null) {\n      // 如果删除了节点以后，将next节点前移\n      while (currentNode.next) {\n        if (this.compare(currentNode.next.value, value)) {\n          deleteNode = currentNode.next;\n          currentNode.next = currentNode.next.next;\n        } else {\n          currentNode = currentNode.next;\n        }\n      }\n    }\n\n    // 检查尾部节点是否被删除\n    if (this.compare(this.tail.value, value)) {\n      this.tail = currentNode;\n    }\n\n    return deleteNode;\n  }\n\n  /**\n   * 查找指定的元素\n   * @param param0\n   */\n  find({ value = undefined, callback = undefined }): LinkedListNode {\n    if (!this.head) {\n      return null;\n    }\n\n    let currentNode = this.head;\n\n    while (currentNode) {\n      // 如果指定了 callback，则按指定的 callback 查找\n      if (callback && callback(currentNode.value)) {\n        return currentNode;\n      }\n\n      // 如果指定了 value，则按 value 查找\n      if (value !== undefined && this.compare(currentNode.value, value)) {\n        return currentNode;\n      }\n\n      currentNode = currentNode.next;\n    }\n\n    return null;\n  }\n\n  /**\n   * 删除尾部节点\n   */\n  deleteTail() {\n    const deletedTail = this.tail;\n\n    if (this.head === this.tail) {\n      // 链表中只有一个元素\n      this.head = null;\n      this.tail = null;\n      return deletedTail;\n    }\n\n    let currentNode = this.head;\n    while (currentNode.next) {\n      if (!currentNode.next.next) {\n        currentNode.next = null;\n      } else {\n        currentNode = currentNode.next;\n      }\n    }\n\n    this.tail = currentNode;\n\n    return deletedTail;\n  }\n\n  /**\n   * 删除头部节点\n   */\n  deleteHead() {\n    if (!this.head) {\n      return null;\n    }\n\n    const deletedHead = this.head;\n\n    if (this.head.next) {\n      this.head = this.head.next;\n    } else {\n      this.head = null;\n      this.tail = null;\n    }\n\n    return deletedHead;\n  }\n\n  /**\n   * 将一组元素转成链表中的节点\n   * @param values 链表中的元素\n   */\n  fromArray(values) {\n    values.forEach((value) => this.append(value));\n    return this;\n  }\n\n  /**\n   * 将链表中的节点转成数组元素\n   */\n  toArray() {\n    const nodes = [];\n\n    let currentNode = this.head;\n\n    while (currentNode) {\n      nodes.push(currentNode);\n      currentNode = currentNode.next;\n    }\n\n    return nodes;\n  }\n\n  /**\n   * 反转链表中的元素节点\n   */\n  reverse() {\n    let currentNode = this.head;\n    let prevNode = null;\n    let nextNode = null;\n    while (currentNode) {\n      // 存储下一个元素节点\n      nextNode = currentNode.next;\n\n      // 更改当前节点的下一个节点，以便将它连接到上一个节点上\n      currentNode.next = prevNode;\n\n      // 将 prevNode 和 currentNode 向前移动一步\n      prevNode = currentNode;\n      currentNode = nextNode;\n    }\n\n    this.tail = this.head;\n    this.head = prevNode;\n  }\n\n  toString(callback = undefined) {\n    return this.toArray()\n      .map((node) => node.toString(callback))\n      .toString();\n  }\n}\n","import LinkedList from './linked-list';\n\nexport default class Queue {\n  public linkedList: LinkedList;\n\n  constructor() {\n    this.linkedList = new LinkedList();\n  }\n\n  /**\n   * 队列是否为空\n   */\n  public isEmpty() {\n    return !this.linkedList.head;\n  }\n\n  /**\n   * 读取队列头部的元素， 不删除队列中的元素\n   */\n  public peek() {\n    if (!this.linkedList.head) {\n      return null;\n    }\n    return this.linkedList.head.value;\n  }\n\n  /**\n   * 在队列的尾部新增一个元素\n   * @param value\n   */\n  public enqueue(value) {\n    this.linkedList.append(value);\n  }\n\n  /**\n   * 删除队列中的头部元素，如果队列为空，则返回 null\n   */\n  public dequeue() {\n    const removeHead = this.linkedList.deleteHead();\n    return removeHead ? removeHead.value : null;\n  }\n\n  public toString(callback?: any) {\n    return this.linkedList.toString(callback);\n  }\n}\n","import { EdgeConfig, GraphData, Matrix } from './types'\n\n/**\n * 获取指定节点的所有邻居\n * @param nodeId 节点 ID\n * @param edges 图中的所有边数据\n * @param type 邻居类型\n */\nexport const getNeighbors = (nodeId: string, edges: EdgeConfig[] = [], type?: 'target' | 'source' | undefined): string[] => {\n  const currentEdges = edges.filter(edge => edge.source === nodeId || edge.target === nodeId)\n  if (type === 'target') {\n    // 当前节点为 source，它所指向的目标节点\n    const neighhborsConverter = (edge: EdgeConfig) => {\n      return edge.source === nodeId;\n    };\n    return currentEdges.filter(neighhborsConverter).map((edge) => edge.target);\n  }\n  if (type === 'source') {\n    // 当前节点为 target，它所指向的源节点\n    const neighhborsConverter = (edge: EdgeConfig) => {\n      return edge.target === nodeId;\n    };\n    return currentEdges.filter(neighhborsConverter).map((edge) => edge.source);\n  }\n\n  // 若未指定 type ，则返回所有邻居\n  const neighhborsConverter = (edge: EdgeConfig) => {\n    return edge.source === nodeId ? edge.target : edge.source;\n  };\n  return currentEdges.map(neighhborsConverter);\n}\n\n/**\n * 获取指定节点的出边\n * @param nodeId 节点 ID\n * @param edges 图中的所有边数据\n */\nexport const getOutEdgesNodeId = (nodeId: string, edges: EdgeConfig[]) => {\n  return edges.filter(edge => edge.source === nodeId)\n}\n\n/**\n * 获取指定节点的边，包括出边和入边\n * @param nodeId 节点 ID\n * @param edges 图中的所有边数据\n */\nexport const getEdgesByNodeId = (nodeId: string, edges: EdgeConfig[]) => {\n  return edges.filter(edge => edge.source === nodeId || edge.target === nodeId)\n}\n\n/**\n * 生成唯一的 ID，规则是序号 + 时间戳\n * @param index 序号\n */\nexport const uniqueId = (index: number = 0) => {\n  const random1 = `${Math.random()}`.split('.')[1].substr(0, 5);\n  const random2 = `${Math.random()}`.split('.')[1].substr(0, 5);\n  return `${index}-${random1}${random2}`\n};\n","import { GraphData, DegreeType } from \"./types\";\n\nconst degree = (graphData: GraphData): DegreeType => {\n  const degrees: DegreeType = {};\n  const { nodes = [], edges = [] } = graphData\n\n  nodes.forEach((node) => {\n    degrees[node.id] = {\n      degree: 0,\n      inDegree: 0,\n      outDegree: 0,\n    };\n  });\n\n  edges.forEach((edge) => {\n    degrees[edge.source].degree++;\n    degrees[edge.source].outDegree++;\n    degrees[edge.target].degree++;\n    degrees[edge.target].inDegree++;\n  });\n\n  return degrees;\n};\n\nexport default degree;\n\n/**\n * 获取指定节点的入度\n * @param graphData 图数据\n * @param nodeId 节点ID\n */\nexport const getInDegree = (graphData: GraphData, nodeId: string) => {\n  const nodeDegree = degree(graphData)\n  if (nodeDegree[nodeId]) {\n    return degree(graphData)[nodeId].inDegree\n  }\n  return 0\n}\n\n/**\n * 获取指定节点的出度\n * @param graphData 图数据\n * @param nodeId 节点ID\n */\nexport const getOutDegree = (graphData: GraphData, nodeId: string) => {\n  const nodeDegree = degree(graphData)\n  if (nodeDegree[nodeId]) {\n    return degree(graphData)[nodeId].outDegree\n  }\n  return 0\n}\n","import { IAlgorithmCallbacks, GraphData } from './types'\nimport { getNeighbors } from './util'\n\nfunction initCallbacks(callbacks: IAlgorithmCallbacks = {} as IAlgorithmCallbacks) {\n  const initiatedCallback = callbacks;\n\n  const stubCallback = () => {};\n\n  const allowTraversalCallback = (() => {\n    const seen = {};\n    return ({ next }) => {\n      if (!seen[next]) {\n        seen[next] = true;\n        return true;\n      }\n      return false;\n    };\n  })();\n\n  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;\n  initiatedCallback.enter = callbacks.enter || stubCallback;\n  initiatedCallback.leave = callbacks.leave || stubCallback;\n\n  return initiatedCallback;\n}\n\n/**\n * @param {Graph} graph\n * @param {GraphNode} currentNode\n * @param {GraphNode} previousNode\n * @param {Callbacks} callbacks\n */\nfunction depthFirstSearchRecursive(\n  graphData: GraphData,\n  currentNode: string,\n  previousNode: string,\n  callbacks: IAlgorithmCallbacks,\n) {\n  callbacks.enter({\n    current: currentNode,\n    previous: previousNode,\n  });\n\n  const { edges = [] } = graphData\n\n  getNeighbors(currentNode, edges, 'target').forEach((nextNode) => {\n    if (\n      callbacks.allowTraversal({\n        previous: previousNode,\n        current: currentNode,\n        next: nextNode,\n      })\n    ) {\n      depthFirstSearchRecursive(graphData, nextNode, currentNode, callbacks);\n    }\n  });\n\n  callbacks.leave({\n    current: currentNode,\n    previous: previousNode,\n  });\n}\n\n/**\n * 深度优先遍历图\n * @param data GraphData 图数据\n * @param startNodeId 开始遍历的节点的 ID\n * @param originalCallbacks 回调\n */\nexport default function depthFirstSearch(\n  graphData: GraphData,\n  startNodeId: string,\n  callbacks?: IAlgorithmCallbacks,\n) {\n  depthFirstSearchRecursive(graphData, startNodeId, '', initCallbacks(callbacks));\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","var toString = {}.toString;\nvar isType = function (value, type) { return toString.call(value) === '[object ' + type + ']'; };\nexport default isType;\n//# sourceMappingURL=is-type.js.map","import isType from './is-type';\nexport default (function (value) {\n    return Array.isArray ?\n        Array.isArray(value) :\n        isType(value, 'Array');\n});\n//# sourceMappingURL=is-array.js.map","import each from './each';\nimport isFunction from './is-function';\nvar keys = Object.keys ? function (obj) { return Object.keys(obj); } : function (obj) {\n    var result = [];\n    each(obj, function (value, key) {\n        if (!(isFunction(obj) && key === 'prototype')) {\n            result.push(key);\n        }\n    });\n    return result;\n};\nexport default keys;\n//# sourceMappingURL=keys.js.map","var arrPrototype = Array.prototype;\nvar splice = arrPrototype.splice;\nvar indexOf = arrPrototype.indexOf;\nvar pull = function (arr) {\n    var values = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        values[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < values.length; i++) {\n        var value = values[i];\n        var fromIndex = -1;\n        while ((fromIndex = indexOf.call(arr, value)) > -1) {\n            splice.call(arr, fromIndex, 1);\n        }\n    }\n    return arr;\n};\nexport default pull;\n//# sourceMappingURL=pull.js.map","import isArrayLike from './is-array-like';\nvar splice = Array.prototype.splice;\nvar pullAt = function pullAt(arr, indexes) {\n    if (!isArrayLike(arr)) {\n        return [];\n    }\n    var length = arr ? indexes.length : 0;\n    var last = length - 1;\n    while (length--) {\n        var previous = void 0;\n        var index = indexes[length];\n        if (length === last || index !== previous) {\n            previous = index;\n            splice.call(arr, index, 1);\n        }\n    }\n    return arr;\n};\nexport default pullAt;\n//# sourceMappingURL=pull-at.js.map","import isArray from './is-array';\nimport isFunction from './is-function';\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction groupBy(data, condition) {\n    if (!condition || !isArray(data)) {\n        return {};\n    }\n    var result = {};\n    // 兼容方法和 字符串的写法\n    var predicate = isFunction(condition) ? condition : function (item) { return item[condition]; };\n    var key;\n    for (var i = 0; i < data.length; i++) {\n        var item = data[i];\n        key = predicate(item);\n        if (hasOwnProperty.call(result, key)) {\n            result[key].push(item);\n        }\n        else {\n            result[key] = [item];\n        }\n    }\n    return result;\n}\nexport default groupBy;\n//# sourceMappingURL=group-by.js.map","import isNumber from './is-number';\nvar isInteger = Number.isInteger ? Number.isInteger : function (num) {\n    return isNumber(num) && num % 1 === 0;\n};\nexport default isInteger;\n//# sourceMappingURL=is-integer.js.map","var DEGREE = 180 / Math.PI;\nvar toDegree = function (radian) {\n    return DEGREE * radian;\n};\nexport default toDegree;\n//# sourceMappingURL=to-degree.js.map","export default parseInt;\n//# sourceMappingURL=to-integer.js.map","var RADIAN = Math.PI / 180;\nvar toRadian = function (degree) {\n    return RADIAN * degree;\n};\nexport default toRadian;\n//# sourceMappingURL=to-radian.js.map","import each from './each';\nimport isFunction from './is-function';\n// @ts-ignore\nvar values = Object.values ? function (obj) { return Object.values(obj); } : function (obj) {\n    var result = [];\n    each(obj, function (value, key) {\n        if (!(isFunction(obj) && key === 'prototype')) {\n            result.push(value);\n        }\n    });\n    return result;\n};\nexport default values;\n//# sourceMappingURL=values.js.map","var objectProto = Object.prototype;\nvar isPrototype = function (value) {\n    var Ctor = value && value.constructor;\n    var proto = (typeof Ctor === 'function' && Ctor.prototype) || objectProto;\n    return value === proto;\n};\nexport default isPrototype;\n//# sourceMappingURL=is-prototype.js.map","import isArray from './is-array';\nvar clone = function (obj) {\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n    var rst;\n    if (isArray(obj)) {\n        rst = [];\n        for (var i = 0, l = obj.length; i < l; i++) {\n            if (typeof obj[i] === 'object' && obj[i] != null) {\n                rst[i] = clone(obj[i]);\n            }\n            else {\n                rst[i] = obj[i];\n            }\n        }\n    }\n    else {\n        rst = {};\n        for (var k in obj) {\n            if (typeof obj[k] === 'object' && obj[k] != null) {\n                rst[k] = clone(obj[k]);\n            }\n            else {\n                rst[k] = obj[k];\n            }\n        }\n    }\n    return rst;\n};\nexport default clone;\n//# sourceMappingURL=clone.js.map","import isNil from './is-nil';\nimport isArrayLike from './is-array-like';\nimport getType from './get-type';\nimport isPrototype from './is-prototype';\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction isEmpty(value) {\n    /**\n     * isEmpty(null) => true\n     * isEmpty() => true\n     * isEmpty(true) => true\n     * isEmpty(1) => true\n     * isEmpty([1, 2, 3]) => false\n     * isEmpty('abc') => false\n     * isEmpty({ a: 1 }) => false\n     */\n    if (isNil(value)) {\n        return true;\n    }\n    if (isArrayLike(value)) {\n        return !value.length;\n    }\n    var type = getType(value);\n    if (type === 'Map' || type === 'Set') {\n        return !value.size;\n    }\n    if (isPrototype(value)) {\n        return !Object.keys(value).length;\n    }\n    for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n            return false;\n        }\n    }\n    return true;\n}\nexport default isEmpty;\n//# sourceMappingURL=is-empty.js.map","import each from './each';\nimport isPlainObject from './is-plain-object';\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport default (function (object, keys) {\n    if (object === null || !isPlainObject(object)) {\n        return {};\n    }\n    var result = {};\n    each(keys, function (key) {\n        if (hasOwnProperty.call(object, key)) {\n            result[key] = object[key];\n        }\n    });\n    return result;\n});\n//# sourceMappingURL=pick.js.map","/**\n * k-v 存储\n */\nvar default_1 = /** @class */ (function () {\n    function default_1() {\n        this.map = {};\n    }\n    default_1.prototype.has = function (key) {\n        return this.map[key] !== undefined;\n    };\n    default_1.prototype.get = function (key, def) {\n        var v = this.map[key];\n        return v === undefined ? def : v;\n    };\n    default_1.prototype.set = function (key, value) {\n        this.map[key] = value;\n    };\n    default_1.prototype.clear = function () {\n        this.map = {};\n    };\n    default_1.prototype.delete = function (key) {\n        delete this.map[key];\n    };\n    default_1.prototype.size = function () {\n        return Object.keys(this.map).length;\n    };\n    return default_1;\n}());\nexport default default_1;\n//# sourceMappingURL=cache.js.map","import { isArray } from '@antv/util';\nimport { GraphData, NodeConfig, EdgeConfig } from './types';\nimport { getOutEdgesNodeId, getEdgesByNodeId } from './util';\n\nconst minVertex = (\n  D: { [key: string]: number },\n  nodes: NodeConfig[],\n  marks: { [key: string]: boolean },\n): NodeConfig => {\n  // 找出最小的点\n  let minDis = Infinity;\n  let minNode;\n  for (let i = 0; i < nodes.length; i++) {\n    const nodeId = nodes[i].id;\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\n      minDis = D[nodeId];\n      minNode = nodes[i];\n    }\n  }\n  return minNode;\n};\n\nconst dijkstra = (\n  graphData: GraphData,\n  source: string,\n  directed?: boolean,\n  weightPropertyName?: string,\n) => {\n  const { nodes = [], edges = [] } = graphData;\n  const nodeIds = [];\n  const marks = {};\n  const D = {};\n  const prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\n  nodes.forEach((node, i) => {\n    const id = node.id;\n    nodeIds.push(id);\n    D[id] = Infinity;\n    if (id === source) D[id] = 0;\n  });\n\n  const nodeNum = nodes.length;\n  for (let i = 0; i < nodeNum; i++) {\n    // Process the vertices\n    const minNode = minVertex(D, nodes, marks);\n    const minNodeId = minNode.id;\n    marks[minNodeId] = true;\n\n    if (D[minNodeId] === Infinity) continue; // Unreachable vertices cannot be the intermediate point\n\n    let relatedEdges: EdgeConfig[] = [];\n    if (directed) relatedEdges = getOutEdgesNodeId(minNodeId, edges);\n    else relatedEdges = getEdgesByNodeId(minNodeId, edges);\n\n    relatedEdges.forEach(edge => {\n      const edgeTarget = edge.target;\n      const edgeSource = edge.source;\n      const w = edgeTarget === minNodeId ? edgeSource : edgeTarget;\n      const weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;\n      if (D[w] > D[minNode.id] + weight) {\n        D[w] = D[minNode.id] + weight;\n        prevs[w] = [minNode.id];\n      } else if (D[w] === D[minNode.id] + weight) {\n        prevs[w].push(minNode.id);\n      }\n    });\n  }\n\n  prevs[source] = [source];\n  // 每个节点存可能存在多条最短路径\n  const allPaths = {};\n  for (const target in D) {\n    if (D[target] !== Infinity) {\n      findAllPaths(source, target, prevs, allPaths);\n    }\n  }\n\n  // 兼容之前单路径\n  const path = {};\n  for (const target in allPaths) {\n    path[target] = allPaths[target][0];\n  }\n  return { length: D, path, allPaths };\n};\n\nexport default dijkstra;\n\nfunction findAllPaths(source, target, prevs, foundPaths) {\n  if (source === target) {\n    return [source];\n  }\n  if (foundPaths[target]) {\n    return foundPaths[target];\n  }\n  const paths = [];\n  for (let prev of prevs[target]) {\n    const prevPaths = findAllPaths(source, prev, prevs, foundPaths);\n    if (!prevPaths) return;\n    for (let prePath of prevPaths) {\n      if (isArray(prePath)) paths.push([...prePath, target]);\n      else paths.push([prePath, target]);\n    }\n  }\n  foundPaths[target] = paths;\n  return foundPaths[target];\n}\n","import getAdjMatrix from \"./adjacent-matrix\";\nimport { GraphData, Matrix } from \"./types\";\n\nconst floydWarshall = (graphData: GraphData, directed?: boolean) => {\n  const adjacentMatrix = getAdjMatrix(graphData, directed);\n\n  const dist: Matrix[] = [];\n  const size = adjacentMatrix.length;\n  for (let i = 0; i < size; i += 1) {\n    dist[i] = [];\n    for (let j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjacentMatrix[i][j] === 0 || !adjacentMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjacentMatrix[i][j];\n      }\n    }\n  }\n  // floyd\n  for (let k = 0; k < size; k += 1) {\n    for (let i = 0; i < size; i += 1) {\n      for (let j = 0; j < size; j += 1) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n  return dist;\n};\n\nexport default floydWarshall;\n","import getAdjMatrix from './adjacent-matrix'\nimport { uniqueId } from './util';\nimport { NodeConfig, ClusterData, GraphData } from './types';\n\nconst getModularity = (\n  nodes: NodeConfig[],\n  adjMatrix: number[][],\n  ks: number[],\n  m: number\n) => {\n  const length = adjMatrix.length;\n  const param = 2 * m;\n  let modularity = 0;\n  for (let i = 0; i < length; i++) {\n    const clusteri = nodes[i].clusterId;\n    for (let j = 0; j < length; j++) {\n      const clusterj = nodes[j].clusterId;\n      if (clusteri !== clusterj) continue;\n      const entry = adjMatrix[i][j] || 0;\n      const ki = ks[i] || 0;\n      const kj = ks[j] || 0;\n      modularity += (entry - ki * kj / param);\n    }\n  }\n  modularity *= (1 / param);\n  return modularity;\n}\n\n/**\n * 社区发现 louvain 算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param threshold \n */\nconst louvain = (\n  graphData: GraphData,\n  directed: boolean = false,\n  weightPropertyName: string = 'weight',\n  threshold: number = 0.0001\n): ClusterData => {\n  // the origin data\n  const { nodes = [], edges = [] } = graphData;\n\n  const clusters = {};\n  const nodeMap = {};\n  // init the clusters and nodeMap\n  nodes.forEach((node, i) => {\n    const cid: string = uniqueId();\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node,\n      idx: i\n    };\n  });\n\n  // the adjacent matrix of calNodes inside clusters\n  const adjMatrix = getAdjMatrix(graphData, directed);\n  // the sum of each row in adjacent matrix\n  const ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n  const neighbors = {};\n  // the sum of the weights of all edges in the graph\n  let m = 0;\n  adjMatrix.forEach((row, i) => {\n    let k = 0;\n    const iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach((entry, j) => {\n      if (!entry) return;\n      k += entry;\n      const jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n      m += entry;\n    });\n    ks.push(k);\n  });\n\n  m /= 2;\n\n  let totalModularity = Infinity;\n  let previousModularity = Infinity;\n  let iter = 0;\n\n  while (true) {\n    // whether to terminate the iterations\n    totalModularity = getModularity(nodes, adjMatrix, ks, m);\n    if (Math.abs(totalModularity - previousModularity) < threshold || iter > 100) break;\n    previousModularity = totalModularity;\n    iter++;\n\n    // pre compute some values for current clusters\n    Object.keys(clusters).forEach(clusterId => {\n      // sum of weights of edges to nodes in cluster\n      let sumTot = 0;\n      edges.forEach(edge => {\n        const { source, target } = edge;\n        const sourceClusterId = nodeMap[source].node.clusterId;\n        const targetClusterId = nodeMap[target].node.clusterId;\n        if ((sourceClusterId === clusterId && targetClusterId !== clusterId)\n          || (targetClusterId === clusterId && sourceClusterId !== clusterId)) {\n          sumTot = sumTot + (edge[weightPropertyName] as number || 1);\n        }\n      });\n      clusters[clusterId].sumTot = sumTot;\n    });\n\n\n    // move the nodes to increase the delta modularity\n    nodes.forEach((node, i) => {\n      const selfCluster = clusters[node.clusterId as string];\n      let bestIncrease = 0;\n      let bestCluster;\n\n      const commonParam = ks[i] / (2 * m);\n\n      // sum of weights of edges from node to nodes in cluster\n      let kiin = 0;\n      const selfClusterNodes = selfCluster.nodes;\n      selfClusterNodes.forEach(scNode => {\n        const scNodeIdx = nodeMap[scNode.id].idx;\n        kiin += adjMatrix[i][scNodeIdx] || 0;\n      });\n      // the modurarity for **removing** the node i from the origin cluster of node i\n      const removeModurarity = kiin - selfCluster.sumTot * commonParam;\n\n      // the neightbors of the node\n      const nodeNeighborIds = neighbors[node.id];\n      Object.keys(nodeNeighborIds).forEach(neighborNodeId => {\n        const neighborNode = nodeMap[neighborNodeId].node\n        const neighborClusterId = neighborNode.clusterId;\n\n        // if the node and the neighbor of node are in the same cluster, reutrn\n        if (neighborClusterId === node.clusterId) return;\n        const neighborCluster = clusters[neighborClusterId];\n        const clusterNodes = neighborCluster.nodes;\n\n        // if the cluster is empty, remove the cluster and return\n        if (!clusterNodes || !clusterNodes.length) return;\n\n        // sum of weights of edges from node to nodes in cluster\n        let neighborClusterKiin = 0;\n        clusterNodes.forEach(cNode => {\n          const cNodeIdx = nodeMap[cNode.id].idx;\n          neighborClusterKiin += adjMatrix[i][cNodeIdx] || 0;\n        });\n\n        // modurarity for **adding** node i into this neighbor cluster\n        const addModurarity = neighborClusterKiin - neighborCluster.sumTot * commonParam;\n\n        // the increase modurarity is the difference between addModurarity and removeModurarity\n        const increase = addModurarity - removeModurarity;\n\n        // find the best cluster to move node i into\n        if (increase > bestIncrease) {\n          bestIncrease = increase;\n          bestCluster = neighborCluster;\n        }\n      });\n\n      // if found a best cluster to move into\n      if (bestIncrease > 0) {\n        bestCluster.nodes.push(node);\n        const previousClusterId = node.clusterId;\n        node.clusterId = bestCluster.id;\n        // move the node to the best cluster\n        const nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        // remove from origin cluster\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);\n        // update sumTot for clusters\n        // sum of weights of edges to nodes in cluster\n        let neighborClusterSumTot = 0;\n        let selfClusterSumTot = 0;\n        edges.forEach(edge => {\n          const { source, target } = edge;\n          const sourceClusterId = nodeMap[source].node.clusterId;\n          const targetClusterId = nodeMap[target].node.clusterId;\n          if ((sourceClusterId === bestCluster.id && targetClusterId !== bestCluster.id)\n            || (targetClusterId === bestCluster.id && sourceClusterId !== bestCluster.id)) {\n            neighborClusterSumTot = neighborClusterSumTot + (edge[weightPropertyName] as number || 1);\n          }\n          if ((sourceClusterId === previousClusterId && targetClusterId !== previousClusterId)\n            || (targetClusterId === previousClusterId && sourceClusterId !== previousClusterId)) {\n            selfClusterSumTot = selfClusterSumTot + (edge[weightPropertyName] as number || 1);\n          }\n        });\n\n        // the nodes of the clusters to move into and remove are changed, update their sumTot\n        bestCluster.sumTot = neighborClusterSumTot;\n        selfCluster.sumTot = selfClusterSumTot;\n      }\n    });\n  }\n\n  // delete the empty clusters\n  Object.keys(clusters).forEach(clusterId => {\n    const cluster = clusters[clusterId];\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n    }\n  });\n\n  // get the cluster edges\n  const clusterEdges = [];\n  const clusterEdgeMap = {};\n  edges.forEach(edge => {\n    const { source, target } = edge;\n    const weight = edge[weightPropertyName] || 1;\n    const sourceClusterId = nodeMap[source].node.clusterId;\n    const targetClusterId = nodeMap[target].node.clusterId;\n    const newEdgeId = `${sourceClusterId}---${targetClusterId}`;\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      const newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n\n  const clustersArray = [];\n  Object.keys(clusters).forEach(clusterId => {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges\n  }\n}\n\nexport default louvain;\n","/**\n * 并查集 Disjoint set to support quick union\n */\nexport default class UnionFind {\n  count: number;\n\n  parent: {};\n\n  constructor(items: (number | string)[]) {\n    this.count = items.length;\n    this.parent = {};\n    for (const i of items) {\n      this.parent[i] = i;\n    }\n  }\n\n  // find the root of the item\n  find(item) {\n    while (this.parent[item] !== item) {\n      item = this.parent[item];\n    }\n    return item;\n  }\n\n  union(a, b) {\n    const rootA = this.find(a);\n    const rootB = this.find(b);\n\n    if (rootA === rootB) return;\n\n    // make the element with smaller root the parent\n    if (rootA < rootB) {\n      if (this.parent[b] !== b) this.union(this.parent[b], a);\n      this.parent[b] = this.parent[a];\n    } else {\n      if (this.parent[a] !== a) this.union(this.parent[a], b);\n      this.parent[a] = this.parent[b];\n    }\n  }\n\n  // whether a and b are connected, i.e. a and b have the same root\n  connected(a, b) {\n    return this.find(a) === this.find(b);\n  }\n}\n","const defaultCompare = (a, b) => {\n  return a - b;\n};\n\nexport default class MinBinaryHeap {\n  list: any[];\n\n  compareFn: (a: any, b: any) => number;\n\n  constructor(compareFn = defaultCompare) {\n    this.compareFn = compareFn;\n    this.list = [];\n  }\n\n  getLeft(index) {\n    return 2 * index + 1;\n  }\n\n  getRight(index) {\n    return 2 * index + 2;\n  }\n\n  getParent(index) {\n    if (index === 0) {\n      return null;\n    }\n    return Math.floor((index - 1) / 2);\n  }\n\n  isEmpty() {\n    return this.list.length <= 0;\n  }\n\n  top() {\n    return this.isEmpty() ? undefined : this.list[0];\n  }\n\n  delMin() {\n    const top = this.top();\n    const bottom = this.list.pop();\n    if (this.list.length > 0) {\n      this.list[0] = bottom;\n      this.moveDown(0);\n    }\n    return top;\n  }\n\n  insert(value) {\n    if (value !== null) {\n      this.list.push(value);\n      const index = this.list.length - 1;\n      this.moveUp(index);\n      return true;\n    }\n    return false;\n  }\n\n  moveUp(index) {\n    let parent = this.getParent(index);\n    while (index && index > 0 && this.compareFn(this.list[parent], this.list[index]) > 0) {\n      // swap\n      const tmp = this.list[parent];\n      this.list[parent] = this.list[index];\n      this.list[index] = tmp;\n      // [this.list[index], this.list[parent]] = [this.list[parent], this.list[index]]\n      index = parent;\n      parent = this.getParent(index);\n    }\n  }\n\n  moveDown(index) {\n    let element = index;\n    const left = this.getLeft(index);\n    const right = this.getRight(index);\n    const size = this.list.length;\n    if (left !== null && left < size && this.compareFn(this.list[element], this.list[left]) > 0) {\n      element = left;\n    } else if (\n      right !== null &&\n      right < size &&\n      this.compareFn(this.list[element], this.list[right]) > 0\n    ) {\n      element = right;\n    }\n    if (index !== element) {\n      [this.list[index], this.list[element]] = [this.list[element], this.list[index]];\n      this.moveDown(element);\n    }\n  }\n}\n","import UnionFind from './structs/union-find';\nimport MinBinaryHeap from './structs/binary-heap';\nimport { GraphData, EdgeConfig } from './types';\nimport { getEdgesByNodeId } from './util';\n\n/**\n * Prim algorithm，use priority queue，复杂度 O(E+V*logV), V: 节点数量，E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n */\nconst primMST = (graphData: GraphData, weight?: string) => {\n  const selectedEdges = [];\n  const { nodes = [], edges = [] } = graphData;\n  if (nodes.length === 0) {\n    return selectedEdges;\n  }\n\n  // 从nodes[0]开始\n  const currNode = nodes[0];\n  const visited = new Set();\n  visited.add(currNode);\n\n  // 用二叉堆维护距已加入节点的其他节点的边的权值\n  const compareWeight = (a: EdgeConfig, b: EdgeConfig) => {\n    if (weight) {\n      return a.weight - b.weight;\n    }\n    return 0;\n\n  };\n  const edgeQueue = new MinBinaryHeap(compareWeight);\n  getEdgesByNodeId(currNode.id, edges).forEach((edge) => {\n    edgeQueue.insert(edge);\n  });\n\n  while (!edgeQueue.isEmpty()) {\n    // 选取与已加入的结点之间边权最小的结点\n    const currEdge: EdgeConfig = edgeQueue.delMin();\n    const source = currEdge.source;\n    const target = currEdge.target;\n    if (visited.has(source) && visited.has(target)) continue;\n    selectedEdges.push(currEdge);\n\n    if (!visited.has(source)) {\n      visited.add(source);\n      getEdgesByNodeId(source, edges).forEach((edge) => {\n        edgeQueue.insert(edge);\n      });\n    }\n    if (!visited.has(target)) {\n      visited.add(target);\n      getEdgesByNodeId(target, edges).forEach((edge) => {\n        edgeQueue.insert(edge);\n      });\n    }\n  }\n  return selectedEdges;\n};\n\n/**\n * Kruskal algorithm，复杂度 O(E*logE), E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @return IEdge[] 返回构成MST的边的数组\n */\nconst kruskalMST = (graphData: GraphData, weight?: string): EdgeConfig[] => {\n  const selectedEdges = [];\n  const { nodes = [], edges = [] } = graphData\n  if (nodes.length === 0) {\n    return selectedEdges;\n  }\n\n  // 若指定weight，则将所有的边按权值从小到大排序\n  const weightEdges = edges.map((edge) => edge);\n  if (weight) {\n    weightEdges.sort((a, b) => {\n      return a.weight - b.weight;\n    });\n  }\n  const disjointSet = new UnionFind(nodes.map((n) => n.id));\n\n  // 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边\n  // 直到遍历完所有点或边\n  while (weightEdges.length > 0) {\n    const curEdge = weightEdges.shift();\n    const source = curEdge.source;\n    const target = curEdge.target;\n    if (!disjointSet.connected(source, target)) {\n      selectedEdges.push(curEdge);\n      disjointSet.union(source, target);\n    }\n  }\n  return selectedEdges;\n};\n\n/**\n * 最小生成树\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @param algo 'prim' | 'kruskal' 算法类型\n * @return EdgeConfig[] 返回构成MST的边的数组\n */\nconst minimumSpanningTree = (graphData: GraphData, weight?: string, algo?: string): EdgeConfig[] => {\n  const algos = {\n    prim: primMST,\n    kruskal: kruskalMST,\n  };\n  if (!algo) return kruskalMST(graphData, weight);\n\n  return algos[algo](graphData, weight);\n}\n\nexport default minimumSpanningTree\n","import { indexOf } from \"@antv/util\";\n\nexport const VACANT_EDGE_ID = -1;\nexport const VACANT_NODE_ID = -1;\nexport const VACANT_EDGE_LABEL = \"-1\";\nexport const VACANT_NODE_LABEL = \"-1\";\nexport const VACANT_GRAPH_ID = -1;\nexport const AUTO_EDGE_ID = \"-1\";\n\nexport class Edge {\n  public id: number;\n  public from: number;\n  public to: number;\n  public label: string;\n\n  constructor(\n    id = VACANT_EDGE_ID,\n    from = VACANT_NODE_ID,\n    to = VACANT_NODE_ID,\n    label = VACANT_EDGE_LABEL\n  ) {\n    this.id = id;\n    this.from = from;\n    this.to = to;\n    this.label = label;\n  }\n}\n\nexport class Node {\n  public id: number;\n  public from: number;\n  public to: number;\n  public label: string;\n  public edges: Edge[];\n  public edgeMap: {};\n\n  constructor(id = VACANT_NODE_ID, label = VACANT_NODE_LABEL) {\n    this.id = id;\n    this.label = label;\n    this.edges = [];\n    this.edgeMap = {};\n  }\n\n  addEdge(edge) {\n    this.edges.push(edge);\n    this.edgeMap[edge.id] = edge;\n  }\n}\n\nexport class Graph {\n  public id: number;\n  public from: number;\n  public to: number;\n  public label: string;\n  public edgeIdAutoIncrease: boolean;\n  public nodes: Node[];\n  public edges: Edge[];\n  public nodeMap: {};\n  public edgeMap: {};\n  public nodeLabelMap: {}; // key 是 label，value 是节点 id 的数组\n  public edgeLabelMap: {};\n  private counter: number; // 自增用于自动生成边 id\n  public directed: boolean;\n\n  constructor(\n    id = VACANT_NODE_ID,\n    edgeIdAutoIncrease = true,\n    directed = false\n  ) {\n    this.id = id;\n    this.edgeIdAutoIncrease = edgeIdAutoIncrease;\n    this.edges = [];\n    this.nodes = [];\n    this.nodeMap = {};\n    this.edgeMap = {};\n    this.nodeLabelMap = {};\n    this.edgeLabelMap = {};\n    this.counter = 0;\n    this.directed = directed;\n  }\n\n  getNodeNum() {\n    return this.nodes.length;\n  }\n\n  addNode(id: number, label: string) {\n    if (this.nodeMap[id]) return;\n    const node = new Node(id, label);\n    this.nodes.push(node);\n    this.nodeMap[id] = node;\n    if (!this.nodeLabelMap[label]) this.nodeLabelMap[label] = [];\n    this.nodeLabelMap[label].push(id);\n  }\n\n  addEdge(id: number, from: number, to: number, label: string) {\n    if (this.edgeIdAutoIncrease || id === undefined) id = this.counter++;\n    if (this.nodeMap[from] && this.nodeMap[to] && this.nodeMap[to].edgeMap[id])\n      return;\n    const edge = new Edge(id, from, to, label);\n    this.edges.push(edge);\n    this.edgeMap[id] = edge;\n\n    this.nodeMap[from].addEdge(edge);\n\n    if (!this.edgeLabelMap[label]) this.edgeLabelMap[label] = [];\n    this.edgeLabelMap[label].push(edge);\n\n    if (!this.directed) {\n      const rEdge = new Edge(id, to, from, label);\n      this.nodeMap[to].addEdge(rEdge);\n      this.edgeLabelMap[label].push(rEdge);\n    }\n  }\n}\n","import { GraphData } from \"../types\";\nimport { clone } from \"@antv/util\";\nimport {\n  Graph,\n  Edge,\n  VACANT_NODE_LABEL,\n  VACANT_GRAPH_ID,\n  Node,\n  VACANT_EDGE_LABEL,\n} from \"./struct\";\n\nexport interface EdgeMap {\n  [key: string]: {\n    // key 的格式为 source-target\n    idx: number; // 该边在原图 graphData.edges 的序号\n    edge: any;\n  };\n}\n\nexport interface NodeMap {\n  [key: string]: {\n    // key 格式为 node.id\n    idx: number; // 该j客店在原图 graphData.nodes 的序号\n    node: any;\n    degree: number;\n  };\n}\n\ninterface PDFS {\n  graphId: number;\n  edge: any;\n  preNode: any;\n}\n\nclass DFSedge {\n  public fromNode: number;\n  public toNode: number;\n  public nodeEdgeNodeLabel: {\n    nodeLabel1: string;\n    edgeLabel: string;\n    nodeLabel2: string;\n  };\n\n  constructor(\n    fromNode: number,\n    toNode: number,\n    fromNodeLabel: string,\n    edgeLabel: string,\n    toNodeLabel: string\n  ) {\n    this.fromNode = fromNode;\n    this.toNode = toNode;\n    this.nodeEdgeNodeLabel = {\n      nodeLabel1: fromNodeLabel || VACANT_NODE_LABEL,\n      edgeLabel: edgeLabel || VACANT_EDGE_LABEL,\n      nodeLabel2: toNodeLabel || VACANT_NODE_LABEL,\n    };\n  }\n\n  equalTo(other) {\n    return (\n      this.fromNode === other.formNode &&\n      this.toNode === other.toNode &&\n      this.nodeEdgeNodeLabel === other.nodeEdgeNodeLabel\n    );\n  }\n\n  notEqualTo(other) {\n    return !this.equalTo(other);\n  }\n}\n\n// DFScode 是 DESedge 的数组\nclass DFScode {\n  public dfsEdgeList: DFSedge[];\n  public rmpath: any;\n\n  constructor() {\n    this.rmpath = [];\n    this.dfsEdgeList = [];\n  }\n\n  equalTo(other) {\n    const aLength = this.dfsEdgeList.length;\n    const bLength = other.length;\n    if (aLength !== bLength) return false;\n    for (let i = 0; i < aLength; i++) {\n      if (this.dfsEdgeList[i] !== other[i]) return false;\n    }\n    return true;\n  }\n\n  notEqualTo(other) {\n    return !this.equalTo(other);\n  }\n\n  /** 增加一条 edge 到 DFScode */\n  pushBack(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel) {\n    this.dfsEdgeList.push(\n      new DFSedge(fromNode, toNode, fromNodeLabel, edgeLabel, toNodeLabel)\n    );\n    return this.dfsEdgeList;\n  }\n\n  /** 根据 dfs 构建图 */\n  toGraph(graphId: number = VACANT_GRAPH_ID, directed = false) {\n    const graph = new Graph(graphId, true, directed);\n    this.dfsEdgeList.forEach((dfsEdge) => {\n      const fromNodeId = dfsEdge.fromNode;\n      const toNodeId = dfsEdge.toNode;\n      const { nodeLabel1, edgeLabel, nodeLabel2 } = dfsEdge.nodeEdgeNodeLabel;\n\n      if (nodeLabel1 !== VACANT_NODE_LABEL)\n        graph.addNode(fromNodeId, nodeLabel1);\n      if (nodeLabel2 !== VACANT_NODE_LABEL) graph.addNode(toNodeId, nodeLabel2);\n\n      graph.addEdge(undefined, fromNodeId, toNodeId, edgeLabel);\n    });\n    return graph;\n  }\n\n  // 建立 rightmost path\n  buildRmpath() {\n    this.rmpath = [];\n    let oldFrom = undefined;\n    const selfLength = this.dfsEdgeList.length;\n    for (let i = selfLength - 1; i >= 0; i--) {\n      const dfsEdge = this.dfsEdgeList[i];\n      const fromNodeIdx = dfsEdge.fromNode;\n      const toNodeIdx = dfsEdge.toNode;\n      if (\n        fromNodeIdx < toNodeIdx &&\n        (oldFrom === undefined || toNodeIdx === oldFrom)\n      ) {\n        this.rmpath.push(i);\n        oldFrom = fromNodeIdx;\n      }\n    }\n    return this.rmpath;\n  }\n\n  getNodeNum() {\n    const nodeMap = {};\n    this.dfsEdgeList.forEach((dfsEdge) => {\n      if (!nodeMap[dfsEdge.fromNode]) nodeMap[dfsEdge.fromNode] = true;\n      if (!nodeMap[dfsEdge.toNode]) nodeMap[dfsEdge.toNode] = true;\n    });\n    return Object.keys(nodeMap).length;\n  }\n}\n\nclass History {\n  public his: object;\n  public edges: Edge[];\n  public nodesUsed: object;\n  public edgesUsed: object;\n\n  constructor(pdfs: PDFS) {\n    this.his = {};\n    this.nodesUsed = {};\n    this.edgesUsed = {};\n    this.edges = [];\n    if (!pdfs) return;\n    while (pdfs) {\n      const e = pdfs.edge;\n      this.edges.push(e);\n      this.nodesUsed[e.from] = 1;\n      this.nodesUsed[e.to] = 1;\n      this.edgesUsed[e.id] = 1;\n      pdfs = pdfs.preNode;\n    }\n    // 倒序\n    this.edges = this.edges.reverse();\n  }\n\n  hasNode(node: Node) {\n    return this.nodesUsed[node.id] === 1;\n  }\n\n  hasEdge(edge: Edge) {\n    return this.edgesUsed[edge.id] === 1;\n  }\n}\n\ninterface Root {\n  [key: string]: {\n    projected: PDFS[];\n    nodeLabel1?: string;\n    edgeLabel?: string;\n    nodeLabel2?: string;\n    fromNodeId?: number;\n    toNodeId?: number;\n  };\n}\n\ninterface GraphDataMap {\n  [key: string]: GraphData;\n}\ninterface GraphMap {\n  [key: number]: Graph;\n}\n\ninterface AlgorithmProps {\n  graphs: GraphMap; // 图数据\n  minSupport: number; // 算法参数，最小支持数量，根据 graphs 内图的数量指定\n  directed?: boolean; // 是否有向图，默认为 false\n  minNodeNum?: number; // 每个子图中边的最少个数，默认为 1\n  maxNodeNum?: number; // 每个子图中边的最多个数，默认为 4\n  top?: number; // 返回前 top 个频繁子图，默认为 10\n  verbose?: boolean;\n}\n\nclass GSpan {\n  public graphs: GraphMap;\n  public dfsCode: DFScode;\n  public support: number;\n  public frequentSize1Subgraphs: GraphData[];\n  public frequentSubgraphs: Graph[];\n  public reportDF: [];\n  public maxNodeNum: number;\n  public minNodeNum: number;\n  public minSupport: number;\n  public top: number;\n  public directed: boolean;\n  private counter: number; // 用于生成图的 id，自增\n  public verbose: boolean;\n\n  constructor({\n    graphs,\n    minSupport = 2,\n    minNodeNum = 1,\n    maxNodeNum = 4,\n    top = 10,\n    directed = false,\n    verbose = false,\n  }: AlgorithmProps) {\n    // -------- 第零步，初始化-------\n    this.graphs = graphs;\n    this.dfsCode = new DFScode();\n    this.support = 0;\n    this.frequentSize1Subgraphs = [];\n    this.frequentSubgraphs = [];\n    this.minSupport = minSupport;\n    this.top = top;\n    this.directed = directed;\n    this.counter = 0;\n    // TODO? timestamp = {}\n    this.maxNodeNum = maxNodeNum;\n    this.minNodeNum = minNodeNum;\n    this.verbose = verbose;\n    if (this.maxNodeNum < this.minNodeNum) this.maxNodeNum = this.minNodeNum;\n    this.reportDF = []; // matrix\n  }\n\n  // Line 352\n  findForwardRootEdges(graph: Graph, fromNode: Node): Edge[] {\n    const result = [];\n    const nodeMap = graph.nodeMap;\n    fromNode.edges.forEach((edge) => {\n      if (this.directed || fromNode.label <= nodeMap[edge.to].label)\n        result.push(edge);\n    });\n\n    return result;\n  }\n\n  findBackwardEdge(\n    graph: Graph,\n    edge1: Edge,\n    edge2: Edge,\n    history: History\n  ): Edge {\n    if (!this.directed && edge1 === edge2) return null;\n    const nodeMap = graph.nodeMap;\n    const edge2To = nodeMap[edge2.to];\n    const edge2ToEdges = edge2To.edges;\n    const edgeLength = edge2ToEdges.length;\n    for (let i = 0; i < edgeLength; i++) {\n      const edge = edge2ToEdges[i];\n      if (history.hasEdge(edge) || edge.to !== edge1.from) continue;\n      if (!this.directed) {\n        if (\n          edge1.label < edge.label ||\n          (edge1.label === edge.label &&\n            nodeMap[edge1.to].label <= nodeMap[edge2.to].label)\n        ) {\n          return edge;\n        }\n      } else {\n        if (\n          nodeMap[edge1.from].label < nodeMap[edge2.to].label ||\n          (nodeMap[edge1.from].label === nodeMap[edge2.to].label &&\n            edge1.label <= edge.label)\n        ) {\n          return edge;\n        }\n      }\n    }\n    return null;\n  }\n\n  findForwardPureEdges(\n    graph,\n    rightmostEdge,\n    minNodeLabel,\n    history: History\n  ): Edge[] {\n    const result = [];\n    const rightmostEdgeToId = rightmostEdge.to;\n    const edges = graph.nodeMap[rightmostEdgeToId].edges;\n    const edgeLength = edges.length;\n    for (let i = 0; i < edgeLength; i++) {\n      const edge = edges[i];\n      const toNode = graph.nodeMap[edge.to];\n      if (minNodeLabel <= toNode.label && !history.hasNode(toNode)) {\n        result.push(edge);\n      }\n    }\n    return result;\n  }\n\n  findForwardRmpathEdges(\n    graph: Graph,\n    rightmostEdge: Edge,\n    minNodeLabel: string,\n    history: History\n  ): Edge[] {\n    const result = [];\n    const nodeMap = graph.nodeMap;\n    const toNodeLabel = nodeMap[rightmostEdge.to].label;\n    const fromNode = nodeMap[rightmostEdge.from];\n    const edges = fromNode.edges;\n    const edgeLength = edges.length;\n    for (let i = 0; i < edgeLength; i++) {\n      const edge = edges[i];\n      const newToNodeLabel = nodeMap[edge.to].label;\n      if (\n        rightmostEdge.to === edge.to ||\n        minNodeLabel > newToNodeLabel ||\n        history.hasNode(nodeMap[edge.to])\n      ) {\n        continue;\n      }\n      if (\n        rightmostEdge.label < edge.label ||\n        (rightmostEdge.label === edge.label && toNodeLabel <= newToNodeLabel)\n      ) {\n        result.push(edge);\n      }\n    }\n    return result;\n  }\n\n  getSupport(projected: PDFS[]): number {\n    const graphMap = {};\n    projected.forEach((pro) => {\n      if (!graphMap[pro.graphId]) graphMap[pro.graphId] = true;\n    });\n    return Object.keys(graphMap).length;\n  }\n\n  findMinLabel(\n    obj: Root\n  ): {\n    nodeLabel1?: string;\n    edgeLabel: string;\n    nodeLabel2?: string;\n  } {\n    let minLabel = undefined;\n    Object.keys(obj).forEach((nodeEdgeNodeLabel) => {\n      const { nodeLabel1, edgeLabel, nodeLabel2 } = obj[nodeEdgeNodeLabel];\n      if (!minLabel) {\n        minLabel = {\n          nodeLabel1,\n          edgeLabel,\n          nodeLabel2,\n        };\n        return;\n      }\n      if (\n        nodeLabel1 < minLabel.nodeLabel1 ||\n        (nodeLabel1 === minLabel.nodeLabel1 &&\n          edgeLabel < minLabel.edgeLabel) ||\n        (nodeLabel1 === minLabel.nodeLabel1 &&\n          edgeLabel === minLabel.edgeLabel &&\n          nodeLabel2 < minLabel.nodeLabel2)\n      ) {\n        minLabel = {\n          nodeLabel1,\n          edgeLabel,\n          nodeLabel2,\n        };\n      }\n    });\n    return minLabel;\n  }\n\n  isMin() {\n    const dfsCode = this.dfsCode;\n    if (this.verbose) console.log(\"isMin checking\", dfsCode);\n    if (dfsCode.dfsEdgeList.length === 1) return true;\n    const directed = this.directed;\n    const graph = dfsCode.toGraph(VACANT_GRAPH_ID, directed);\n    const nodeMap = graph.nodeMap;\n    const dfsCodeMin = new DFScode();\n    const root: Root = {};\n    graph.nodes.forEach((node) => {\n      const forwardEdges = this.findForwardRootEdges(graph, node);\n      forwardEdges.forEach((edge) => {\n        let otherNode = nodeMap[edge.to];\n        const nodeEdgeNodeLabel = `${node.label}-${edge.label}-${otherNode.label}`;\n        if (!root[nodeEdgeNodeLabel])\n          root[nodeEdgeNodeLabel] = {\n            projected: [],\n            nodeLabel1: node.label,\n            edgeLabel: edge.label,\n            nodeLabel2: otherNode.label,\n          };\n        const pdfs: PDFS = {\n          graphId: graph.id,\n          edge,\n          preNode: null,\n        };\n        root[nodeEdgeNodeLabel].projected.push(pdfs);\n      });\n    });\n\n    // 比较 root 中每一项的 nodeEdgeNodeLabel 大小，按照 nodeLabel1、edgeLabe、nodeLabel2 的顺序比较\n    let minLabel = this.findMinLabel(root); // line 419\n    dfsCodeMin.dfsEdgeList.push(\n      new DFSedge(\n        0,\n        1,\n        minLabel.nodeLabel1,\n        minLabel.edgeLabel,\n        minLabel.nodeLabel2\n      )\n    );\n\n    // line 423\n    const projectIsMin = (projected: PDFS[]) => {\n      // right most path\n      const rmpath = dfsCodeMin.buildRmpath();\n      const minNodeLabel =\n        dfsCodeMin.dfsEdgeList[0].nodeEdgeNodeLabel.nodeLabel1;\n      const maxToC = dfsCodeMin.dfsEdgeList[rmpath[0]].toNode; // node id\n\n      const backwardRoot: Root = {};\n      let flag = false,\n        newTo = 0;\n      let end = directed ? -1 : 0; // 遍历到 1 还是到 0\n      for (let i = rmpath.length - 1; i > end; i--) {\n        if (flag) break;\n        // line 435\n        projected.forEach((p) => {\n          const history = new History(p);\n          const backwardEdge = this.findBackwardEdge(\n            graph,\n            history.edges[rmpath[i]],\n            history.edges[rmpath[0]],\n            history\n          );\n          if (backwardEdge) {\n            // Line 441\n            if (!backwardRoot[backwardEdge.label]) {\n              backwardRoot[backwardEdge.label] = {\n                projected: [],\n                edgeLabel: backwardEdge.label,\n              };\n            }\n            backwardRoot[backwardEdge.label].projected.push({\n              graphId: graph.id,\n              edge: backwardRoot,\n              preNode: p,\n            });\n            newTo = dfsCodeMin.dfsEdgeList[rmpath[i]].fromNode;\n            flag = true;\n          }\n        });\n      }\n\n      if (flag) {\n        const minBackwardEdgeLabel = this.findMinLabel(backwardRoot);\n        dfsCodeMin.dfsEdgeList.push(\n          new DFSedge(\n            maxToC,\n            newTo,\n            VACANT_NODE_LABEL,\n            minBackwardEdgeLabel.edgeLabel,\n            VACANT_NODE_LABEL\n          )\n        );\n        const idx = dfsCodeMin.dfsEdgeList.length - 1;\n        if (this.dfsCode.dfsEdgeList[idx] !== dfsCodeMin.dfsEdgeList[idx])\n          return false;\n        return projectIsMin(\n          backwardRoot[minBackwardEdgeLabel.edgeLabel].projected\n        );\n      }\n      const forwardRoot: Root = {};\n      flag = false;\n      let newFrom = 0;\n      projected.forEach((p) => {\n        const history = new History(p);\n        const forwardPureEdges = this.findForwardPureEdges(\n          graph,\n          history.edges[rmpath[0]],\n          minNodeLabel,\n          history\n        );\n        if (forwardPureEdges.length > 0) {\n          flag = true;\n          newFrom = maxToC;\n          forwardPureEdges.forEach((edge) => {\n            const key = `${edge.label}-${nodeMap[edge.to].label}`;\n            if (!forwardRoot[key])\n              forwardRoot[key] = {\n                projected: [],\n                edgeLabel: edge.label,\n                nodeLabel2: nodeMap[edge.to].label,\n              };\n            forwardRoot[key].projected.push({\n              graphId: graph.id,\n              edge,\n              preNode: p,\n            });\n          });\n        }\n      });\n\n      const pathLength = rmpath.length;\n      for (let i = 0; i < pathLength; i++) {\n        if (flag) break;\n        const value = rmpath[i];\n        projected.forEach((p) => {\n          const history = new History(p);\n          const forwardRmpathEdges = this.findForwardRmpathEdges(\n            graph,\n            history.edges[value],\n            minNodeLabel,\n            history\n          );\n          if (forwardRmpathEdges.length > 0) {\n            flag = true;\n            newFrom = dfsCodeMin.dfsEdgeList[value].fromNode;\n            forwardRmpathEdges.forEach((edge) => {\n              const key = `${edge.label}-${nodeMap[edge.to].label}`;\n              if (!forwardRoot[key])\n                forwardRoot[key] = {\n                  projected: [],\n                  edgeLabel: edge.label,\n                  nodeLabel2: nodeMap[edge.to].label,\n                };\n              forwardRoot[key].projected.push({\n                graphId: graph.id,\n                edge,\n                preNode: p,\n              });\n            });\n          }\n        });\n      }\n\n      if (!flag) return true;\n\n      const forwardMinEdgeNodeLabel = this.findMinLabel(forwardRoot);\n      dfsCodeMin.dfsEdgeList.push(\n        new DFSedge(\n          newFrom,\n          maxToC + 1,\n          VACANT_NODE_LABEL,\n          forwardMinEdgeNodeLabel.edgeLabel,\n          forwardMinEdgeNodeLabel.nodeLabel2\n        )\n      );\n      const idx = dfsCodeMin.dfsEdgeList.length - 1;\n      if (dfsCode.dfsEdgeList[idx] !== dfsCodeMin.dfsEdgeList[idx])\n        return false;\n      return projectIsMin(\n        forwardRoot[\n          `${forwardMinEdgeNodeLabel.edgeLabel}-${forwardMinEdgeNodeLabel.nodeLabel2}`\n        ].projected\n      );\n    };\n    const key = `${minLabel.nodeLabel1}-${minLabel.edgeLabel}-${minLabel.nodeLabel2}`;\n    return projectIsMin(root[key].projected);\n  }\n\n  report() {\n    if (this.dfsCode.getNodeNum() < this.minNodeNum) return;\n    this.counter++;\n    const graph = this.dfsCode.toGraph(this.counter, this.directed);\n    this.frequentSubgraphs.push(clone(graph));\n  }\n\n  subGraphMining(projected) {\n    const support = this.getSupport(projected);\n    if (support < this.minSupport) return;\n    if (!this.isMin()) return;\n    this.report();\n\n    const nodeNum = this.dfsCode.getNodeNum();\n    const rmpath = this.dfsCode.buildRmpath();\n    const maxToC = this.dfsCode.dfsEdgeList[rmpath[0]].toNode;\n    const minNodeLabel = this.dfsCode.dfsEdgeList[0].nodeEdgeNodeLabel\n      .nodeLabel1;\n\n    const forwardRoot: Root = {};\n    const backwardRoot: Root = {};\n\n    projected.forEach((p) => {\n      const graph = this.graphs[p.graphId];\n      const nodeMap = graph.nodeMap;\n      const history = new History(p);\n      // backward Line 526\n      for (let i = rmpath.length - 1; i >= 0; i--) {\n        const backwardEdge = this.findBackwardEdge(\n          graph,\n          history.edges[rmpath[i]],\n          history.edges[rmpath[0]],\n          history\n        );\n        if (backwardEdge) {\n          const key = `${this.dfsCode.dfsEdgeList[rmpath[i]].fromNode}-${\n            backwardEdge.label\n          }`;\n          if (!backwardRoot[key])\n            backwardRoot[key] = {\n              projected: [],\n              toNodeId: this.dfsCode.dfsEdgeList[rmpath[i]].fromNode,\n              edgeLabel: backwardEdge.label,\n            };\n          backwardRoot[key].projected.push({\n            graphId: p.graphId,\n            edge: backwardEdge,\n            preNode: p,\n          });\n        }\n      }\n\n      // pure forward\n      if (nodeNum >= this.maxNodeNum) return;\n      const forwardPureEdges = this.findForwardPureEdges(\n        graph,\n        history.edges[rmpath[0]],\n        minNodeLabel,\n        history\n      );\n      forwardPureEdges.forEach((edge) => {\n        const key = `${maxToC}-${edge.label}-${nodeMap[edge.to].label}`;\n        if (!forwardRoot[key])\n          forwardRoot[key] = {\n            projected: [],\n            fromNodeId: maxToC,\n            edgeLabel: edge.label,\n            nodeLabel2: nodeMap[edge.to].label,\n          };\n        forwardRoot[key].projected.push({\n          graphId: p.graphId,\n          edge,\n          preNode: p,\n        });\n      });\n\n      // rmpath forward\n      for (let i = 0; i < rmpath.length; i++) {\n        const forwardRmpathEdges = this.findForwardRmpathEdges(\n          graph,\n          history.edges[rmpath[i]],\n          minNodeLabel,\n          history\n        );\n        forwardRmpathEdges.forEach((edge) => {\n          const key = `${this.dfsCode.dfsEdgeList[rmpath[i]].fromNode}-${\n            edge.label\n          }-${nodeMap[edge.to].label}`;\n          if (!forwardRoot[key])\n            forwardRoot[key] = {\n              projected: [],\n              fromNodeId: this.dfsCode.dfsEdgeList[rmpath[i]].fromNode,\n              edgeLabel: edge.label,\n              nodeLabel2: nodeMap[edge.to].label,\n            };\n          forwardRoot[key].projected.push({\n            graphId: p.graphId,\n            edge,\n            preNode: p,\n          });\n        });\n      }\n    });\n\n    // backward\n    Object.keys(backwardRoot).forEach((key) => {\n      const { toNodeId, edgeLabel } = backwardRoot[key];\n      this.dfsCode.dfsEdgeList.push(\n        new DFSedge(maxToC, toNodeId, \"-1\", edgeLabel, \"-1\")\n      );\n      this.subGraphMining(backwardRoot[key].projected);\n      this.dfsCode.dfsEdgeList.pop();\n    });\n\n    // forward\n    Object.keys(forwardRoot).forEach((key) => {\n      const { fromNodeId, edgeLabel, nodeLabel2 } = forwardRoot[key];\n      this.dfsCode.dfsEdgeList.push(\n        new DFSedge(\n          fromNodeId,\n          maxToC + 1,\n          VACANT_NODE_LABEL,\n          edgeLabel,\n          nodeLabel2\n        )\n      );\n      this.subGraphMining(forwardRoot[key].projected);\n      this.dfsCode.dfsEdgeList.pop();\n    });\n  }\n\n  generate1EdgeFrequentSubGraphs() {\n    const graphs = this.graphs;\n    const directed = this.directed;\n    const minSupport = this.minSupport;\n    const frequentSize1Subgraphs = this.frequentSize1Subgraphs;\n    let nodeLabelCounter = {},\n      nodeEdgeNodeCounter = {};\n    // 保存各个图和各自节点的关系 map，key 格式为 graphKey-node类型\n    const nodeLableCounted = {};\n    // 保存各个图和各自边的关系 map，key 格式为 graphKey-fromNode类型-edge类型-toNode类型\n    const nodeEdgeNodeLabelCounted = {};\n    Object.keys(graphs).forEach((key) => {\n      // Line 271\n      const graph = graphs[key];\n      const nodeMap = graph.nodeMap;\n      // 遍历节点，记录对应图 与 每个节点的 label 到 nodeLableCounted\n      graph.nodes.forEach((node, i) => {\n        // Line 272\n        const nodeLabel = node.label;\n        const graphNodeKey = `${key}-${nodeLabel}`;\n        if (!nodeLableCounted[graphNodeKey]) {\n          let counter = nodeLabelCounter[nodeLabel] || 0;\n          counter++;\n          nodeLabelCounter[nodeLabel] = counter;\n        }\n        nodeLableCounted[graphNodeKey] = {\n          graphKey: key,\n          label: nodeLabel,\n        };\n        // 遍历该节点的所有边，记录各个图和各自边的关系到 nodeEdgeNodeLabelCounted. Line 276\n        node.edges.forEach((edge) => {\n          let nodeLabel1 = nodeLabel;\n          let nodeLabel2 = nodeMap[edge.to].label;\n          if (!directed && nodeLabel1 > nodeLabel2) {\n            const tmp = nodeLabel2;\n            nodeLabel2 = nodeLabel1;\n            nodeLabel1 = tmp;\n          }\n          const edgeLabel = edge.label;\n\n          const graphNodeEdgeNodeKey = `${key}-${nodeLabel1}-${edgeLabel}-${nodeLabel2}`;\n          const nodeEdgeNodeKey = `${nodeLabel1}-${edgeLabel}-${nodeLabel2}`;\n\n          if (!nodeEdgeNodeCounter[nodeEdgeNodeKey]) {\n            let counter = nodeEdgeNodeCounter[nodeEdgeNodeKey] || 0;\n            counter++;\n            nodeEdgeNodeCounter[nodeEdgeNodeKey] = counter; // Line281\n          }\n          nodeEdgeNodeLabelCounted[graphNodeEdgeNodeKey] = {\n            graphId: key,\n            nodeLabel1,\n            edgeLabel,\n            nodeLabel2,\n          };\n        });\n      });\n    });\n\n    // 计算频繁的节点\n    Object.keys(nodeLabelCounter).forEach((label) => {\n      const count = nodeLabelCounter[label];\n      if (count < minSupport) return;\n      const g = { nodes: [], edges: [] };\n      g.nodes.push({\n        id: \"0\",\n        label,\n      });\n      frequentSize1Subgraphs.push(g);\n      // if (minNodeNum <= 1) reportSize1 TODO\n    });\n\n    return frequentSize1Subgraphs;\n  }\n\n  run() {\n    // -------- 第一步, _generate_1edge_frequent_subgraphs：频繁的单个节点-------\n    this.frequentSize1Subgraphs = this.generate1EdgeFrequentSubGraphs();\n\n    if (this.maxNodeNum < 2) return;\n\n    const graphs = this.graphs;\n    const directed = this.directed;\n\n    // PDFS 数组的 map Line 304\n    const root: Root = {};\n    Object.keys(graphs).forEach((graphId: any) => {\n      const graph = graphs[graphId];\n      const nodeMap = graph.nodeMap;\n      // Line 306\n      graph.nodes.forEach((node) => {\n        const forwardRootEdges = this.findForwardRootEdges(graph, node);\n        // Line 308\n        forwardRootEdges.forEach((edge) => {\n          let toNode = nodeMap[edge.to];\n          const nodeEdgeNodeLabel = `${node.label}-${edge.label}-${toNode.label}`;\n          if (!root[nodeEdgeNodeLabel])\n            root[nodeEdgeNodeLabel] = {\n              projected: [],\n              nodeLabel1: node.label as string,\n              edgeLabel: edge.label as string,\n              nodeLabel2: toNode.label as string,\n            };\n          const pdfs: PDFS = {\n            graphId,\n            edge,\n            preNode: null,\n          };\n          root[nodeEdgeNodeLabel].projected.push(pdfs);\n        });\n      });\n    });\n\n    // Line 313\n    Object.keys(root).forEach((nodeEdgeNodeLabel) => {\n      const { projected, nodeLabel1, edgeLabel, nodeLabel2 } = root[\n        nodeEdgeNodeLabel\n      ];\n\n      this.dfsCode.dfsEdgeList.push(\n        new DFSedge(0, 1, nodeLabel1, edgeLabel, nodeLabel2)\n      );\n      this.subGraphMining(projected);\n      this.dfsCode.dfsEdgeList.pop();\n    });\n  }\n}\n\nconst formatGraphs = (\n  graphs: GraphDataMap,\n  directed: boolean,\n  nodeLabelProp: string,\n  edgeLabelProp: string\n): GraphMap => {\n  const result: { [key: number]: Graph } = {};\n  Object.keys(graphs).forEach((key, i) => {\n    const graph = graphs[key];\n    const fGraph = new Graph(i, true, directed);\n    const nodeIdxMap = {};\n    graph.nodes.forEach((node, j) => {\n      fGraph.addNode(j, node[nodeLabelProp]);\n      nodeIdxMap[node.id] = j;\n    });\n    graph.edges.forEach((edge, k) => {\n      const sourceIdx = nodeIdxMap[edge.source];\n      const targetIdx = nodeIdxMap[edge.target];\n      fGraph.addEdge(-1, sourceIdx, targetIdx, edge[edgeLabelProp]);\n    });\n    if (fGraph && fGraph.getNodeNum()) result[fGraph.id] = fGraph;\n  });\n  return result;\n};\n\nconst toGraphDatas = (\n  graphs: Graph[],\n  nodeLabelProp: string,\n  edgeLabelProp: string\n) => {\n  const result = [];\n  graphs.forEach((graph) => {\n    const graphData = { nodes: [], edges: [] };\n    graph.nodes.forEach((node) => {\n      graphData.nodes.push({\n        id: `${node.id}`,\n        [nodeLabelProp]: node.label,\n      });\n    });\n    graph.edges.forEach((edge) => {\n      graphData.edges.push({\n        source: `${edge.from}`,\n        target: `${edge.to}`,\n        [edgeLabelProp]: edge.label,\n      });\n    });\n    result.push(graphData);\n  });\n  return result;\n};\n\ninterface Props {\n  graphs: GraphDataMap; // 图数据\n  minSupport: number; // 算法参数，最小支持数量，根据 graphs 内图的数量指定\n  directed?: boolean; // 是否有向图，默认为 false\n  nodeLabelProp?: string; // 节点类型的属性名\n  edgeLabelProp?: string; // 边类型的属性名\n  minNodeNum?: number; // 每个子图中节点的最少个数，默认为 1\n  maxNodeNum?: number; // 每个子图中节点的最多个数，默认为 4\n  top?: number; // 返回前 top 个频繁子图，默认为 10\n  verbose?: boolean;\n}\n\nconst DEFAULT_LABEL_NAME = \"cluster\";\n\n/**\n * gSpan 频繁子图计算算法（frequent graph mining）\n * @param params 参数\n */\nconst gSpan = (params: Props): GraphData[] => {\n  // ------- 将图数据 GraphData 的 map 转换为格式 -------\n  const {\n    graphs,\n    directed = false,\n    nodeLabelProp = DEFAULT_LABEL_NAME,\n    edgeLabelProp = DEFAULT_LABEL_NAME,\n  } = params;\n  const formattedGraphs = formatGraphs(\n    graphs,\n    directed,\n    nodeLabelProp,\n    edgeLabelProp\n  );\n  const { minSupport, maxNodeNum, minNodeNum, verbose, top } = params;\n\n  // ------- 初始化与执行算法 -------\n  const algoParams = {\n    graphs: formattedGraphs,\n    minSupport,\n    maxNodeNum,\n    minNodeNum,\n    top,\n    verbose,\n    directed,\n  };\n  const calculator = new GSpan(algoParams);\n  calculator.run();\n\n  const result = toGraphDatas(\n    calculator.frequentSubgraphs,\n    nodeLabelProp,\n    edgeLabelProp\n  );\n  return result;\n};\n\nexport default gSpan;\n","import floydWarshall from './floydWarshall';\nimport { GraphData, Matrix } from './types';\nimport gSpan, { EdgeMap, NodeMap } from './gSpan/gSpan';\nimport dijkstra from './dijkstra';\nimport { uniqueId } from './util';\n\n/** 节点对 map */\ninterface NodePairMap {\n  [key: string]: {\n    // key 的格式为 startNodeIdx-endNodeIdx\n    start: number; // 第一个节点的 idx\n    end: number; // 第二个节点的 idx\n    distance: number; // 两节点最短路径长度\n  };\n}\n\ninterface LabelMap {\n  [label: string]: any;\n}\n\n/** 邻居单元类型 */\ninterface NeighborUnit {\n  nodeId: string;\n  nodeIdx: number;\n  nodeIdxs: number[]; // the first one is nodeIdx\n  neighbors: any[]; //\n  neighborNum: number;\n  nodeLabelCountMap: {\n    [label: string]: {\n      count: number;\n      dists: number[]; // 按照从小到大排序的距离数组\n    };\n  };\n}\n\n/** 节点对的邻居交集的诱导子图 map */\ninterface InterGraphMap {\n  [key: string]: GraphData; // key 格式由节点对的 idx 组成：beginIdx-endIdx，和 nodePairMap 对应\n}\n\n/**\n * 为 graphData 中每个节点生成邻居单元数组\n * @param graphData\n * @param spm\n * @param nodeLabelProp\n * @param k k-近邻\n */\nconst findKNeighborUnits = (\n  graphData: GraphData,\n  spm: Matrix[],\n  nodeLabelProp: string = 'cluster',\n  k: number = 2,\n): NeighborUnit[] => {\n  const units: NeighborUnit[] = [];\n  const nodes = graphData.nodes;\n  spm.forEach((row: number[], i) => {\n    units.push(findKNeighborUnit(nodes, row, i, nodeLabelProp, k));\n  });\n  return units;\n};\n\nconst findKNeighborUnit = (nodes, row, i, nodeLabelProp, k) => {\n  const unitNodeIdxs = [i];\n  const neighbors = [];\n  const labelCountMap = {};\n  row.forEach((v, j) => {\n    if (v <= k && i !== j) {\n      unitNodeIdxs.push(j);\n      neighbors.push(nodes[j]);\n      const label = nodes[j][nodeLabelProp];\n      if (!labelCountMap[label]) labelCountMap[label] = { count: 1, dists: [v] };\n      else {\n        labelCountMap[label].count++;\n        labelCountMap[label].dists.push(v);\n      }\n    }\n  });\n  // 将 labelCountMap 中的 dists 按照从小到大排序，方便后面使用\n  Object.keys(labelCountMap).forEach(label => {\n    labelCountMap[label].dists = labelCountMap[label].dists.sort((a, b) => a - b);\n  });\n  return {\n    nodeIdx: i,\n    nodeId: nodes[i].id,\n    nodeIdxs: unitNodeIdxs,\n    neighbors,\n    neighborNum: unitNodeIdxs.length - 1,\n    nodeLabelCountMap: labelCountMap,\n  };\n};\n\n/**\n * 随机寻找点对，满足距离小于 k\n * @param k 参数 k，表示 k-近邻\n * @param nodeNum 参数 length\n * @param maxNodePairNum 寻找点对的数量不超过 maxNodePairNum\n * @param spm 最短路径矩阵\n */\nconst findNodePairsRandomly = (\n  k: number,\n  nodeNum: number,\n  maxNodePairNum: number,\n  kNeighborUnits: NeighborUnit[],\n  spm: Matrix[],\n): NodePairMap => {\n  // 每个节点需要随机找出的点对数\n  let nodePairNumEachNode = Math.ceil(maxNodePairNum / nodeNum);\n  const nodePairMap = {};\n  let foundNodePairCount = 0;\n\n  // 遍历节点，为每个节点随机找出 nodePairNumEachNode 个点对，满足距离小于 k。找到的点对数量超过 maxNodePairNum 或所有节点遍历结束时终止\n  kNeighborUnits.forEach((unit, i) => {\n    // 若未达到 nodePairNumEachNode，或循环次数小于最大循环次数(2 * nodeNum)，继续循环\n    let nodePairForICount = 0;\n    let outerLoopCount = 0;\n    const neighbors = unit.nodeIdxs; // the first one is the center node\n    const neighborNum = unit.neighborNum - 1;\n    while (nodePairForICount < nodePairNumEachNode) {\n      // 另一端节点在节点数组中的的 index\n      let oidx = neighbors[1 + Math.floor(Math.random() * neighborNum)];\n      let innerLoopCount = 0;\n      // 若随机得到的另一端 idx 不符合条件，则继续 random。条件是不是同一个节点、这个点对没有被记录过、距离小于 k\n      while (nodePairMap[`${i}-${oidx}`] || nodePairMap[`${oidx}-${i}`]) {\n        oidx = Math.floor(Math.random() * nodeNum);\n        innerLoopCount++;\n        if (innerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\n      }\n      if (innerLoopCount < 2 * nodeNum) {\n        // 未达到最大循环次数，说明找到了合适的另一端\n        nodePairMap[`${i}-${oidx}`] = {\n          start: i,\n          end: oidx,\n          distance: spm[i][oidx],\n        };\n        nodePairForICount++;\n        foundNodePairCount++;\n        // 如果当前找到的点对数量达到了上限，返回结果\n        if (foundNodePairCount >= maxNodePairNum) return nodePairMap;\n      }\n      outerLoopCount++;\n      if (outerLoopCount > 2 * nodeNum) break; // 循环次数大于最大循环次数(2 * nodeNum)跳出循环，避免死循环\n    }\n    // 这个节点没有找到足够 nodePairNumEachNode 的点对。更新 nodePairNumEachNode，让后续节点找更多的点对\n    if (nodePairForICount < nodePairNumEachNode) {\n      const gap = nodePairNumEachNode - nodePairForICount;\n      nodePairNumEachNode = (nodePairNumEachNode + gap) / (nodeNum - i - 1);\n    }\n  });\n  return nodePairMap;\n};\n\n/**\n * 计算所有 nodePairMap 中节点对的相交邻居诱导子图\n * @param nodePairMap 节点对 map，key 为 node1.id-node2.id，value 为 { startNodeIdx, endNodeIdx, distance }\n * @param neighborUnits 每个节点的邻居元数组\n * @param graphData 原图数据\n * @param edgeMap 边的 map，方便检索\n * @param cachedInducedGraphMap 缓存的结果，下次进入该函数将继续更新该缓存，若 key 在缓存中存在则不需要重复计算\n */\nconst getIntersectNeighborInducedGraph = (\n  nodePairMap: NodePairMap,\n  neighborUnits: NeighborUnit[],\n  graphData: GraphData,\n  cachedInducedGraphMap?: InterGraphMap,\n): InterGraphMap => {\n  const nodes = graphData.nodes;\n  if (!cachedInducedGraphMap) cachedInducedGraphMap = {};\n  Object.keys(nodePairMap).forEach(key => {\n    if (cachedInducedGraphMap && cachedInducedGraphMap[key]) return;\n    cachedInducedGraphMap[key] = { nodes: [], edges: [] };\n    const pair = nodePairMap[key];\n    const startUnitNodeIds = neighborUnits[pair.start]?.nodeIdxs;\n    const endUnitNodeIds = neighborUnits[pair.end]?.nodeIdxs;\n    if (!startUnitNodeIds || !endUnitNodeIds) return; // 不存在邻元，返回空图\n    const endSet = new Set(endUnitNodeIds);\n    const intersect = startUnitNodeIds.filter(x => endSet.has(x)); // 可能会爆栈（在 1580 + 6 nodes full-connected 时出现）\n    if (!intersect || !intersect.length) return; // 没有交集，返回空图\n    const intersectIdMap = {};\n    const intersectLength = intersect.length;\n    for (let i = 0; i < intersectLength; i++) {\n      const node = nodes[intersect[i]];\n      cachedInducedGraphMap[key].nodes.push(node); // 将交集中的点加入诱导子图\n      intersectIdMap[node.id] = true;\n    }\n    // 遍历所有边数据，如果边的两端都在交集中，将该边加入诱导子图\n    graphData.edges.forEach(edge => {\n      if (intersectIdMap[edge.source] && intersectIdMap[edge.target])\n        cachedInducedGraphMap[key].edges.push(edge);\n    });\n  });\n  return cachedInducedGraphMap;\n};\n\n/**\n * 计算 strcutre 在 graph 上的匹配数量\n * @param graph 图数据\n * @param structure 目前支持只有两个节点一条边的最简单结构\n * @param nodeLabelProp 节点类型字段名\n * @param edgeLabelProp 边类型字段名\n */\nconst getMatchedCount = (graph, structure, nodeLabelProp, edgeLabelProp) => {\n  const nodeMap = {};\n  graph.nodes.forEach(node => {\n    nodeMap[node.id] = node;\n  });\n  let count = 0;\n  graph.edges.forEach(e => {\n    const sourceLabel = nodeMap[e.source][nodeLabelProp];\n    const targetLabel = nodeMap[e.target][nodeLabelProp];\n    const strNodeLabel1 = structure.nodes[0][nodeLabelProp];\n    const strNodeLabel2 = structure.nodes[1][nodeLabelProp];\n    const strEdgeLabel = structure.edges[0][edgeLabelProp];\n\n    if (e[edgeLabelProp] !== strEdgeLabel) return;\n    if (\n      (sourceLabel === strNodeLabel1 && targetLabel === strNodeLabel2) ||\n      (sourceLabel === strNodeLabel2 && targetLabel === strNodeLabel1)\n    ) {\n      count++;\n    }\n  });\n  return count;\n};\n\n/**\n * structures 中寻找最具有代表性的一个。这个结构是使得 matchedCountMap 的分组方式类内间距最小，类间间距最大\n * @param matchedCountMap 每个 structure 分类后的各图匹配数量，格式 { [strcture.idx]: { [interInducedGraphKey]: count } }\n * @param structureNum strcuture 个数，与 matchedCountMap.length 对应\n * @param structures\n */\nconst findRepresentStructure = (matchedCountMap, structureNum, structures) => {\n  let maxOffset = Infinity,\n    representClusterType = 0;\n  for (let i = 0; i < structureNum; i++) {\n    // 一种分组的 map，key 是 intGraph 的 key，value 是 structures[i] 的匹配个数\n    const countMapI = matchedCountMap[i];\n    // 按照 value 为该组排序，生成 keys 的数组：\n    const sortedGraphKeys = Object.keys(countMapI).sort((a, b) => {\n      return countMapI[a] - countMapI[b];\n    });\n\n    // 共 100 个 graphKeys，将 graphKeys 按顺序分为 groupNum 组\n    const groupNum = 10;\n    const clusters = []; // 总共有 groupNum 个项\n    sortedGraphKeys.forEach((key, j) => {\n      if (!clusters[j % groupNum])\n        clusters[j % groupNum] = { graphs: [], totalCount: 0, aveCount: 0 };\n      clusters[j % groupNum].graphs.push(key);\n      clusters[j % groupNum].totalCount += countMapI[key];\n    });\n\n    // 计算 cluster 与 cluster 之间的距离 innerDist，每个 cluster 内部的距离 intraDist\n    let aveIntraDist = 0; // 该类的类内平均值\n    const aveCounts = []; // 类内平均匹配数量，将用于计算类间距离\n    clusters.forEach(graphsInCluster => {\n      // 类内均值\n      const aveCount = graphsInCluster.totalCount / graphsInCluster.graphs.length;\n      graphsInCluster.aveCount = aveCount;\n      aveCounts.push(aveCount);\n\n      // 对于每类，计算类内间距平均值\n      let aveIntraPerCluster = 0;\n      const graphsNum = graphsInCluster.length;\n      graphsInCluster.graphs.forEach((graphKey1, j) => {\n        const graph1Count = countMapI[graphKey1];\n        graphsInCluster.graphs.forEach((graphKey2, k) => {\n          if (j === k) return;\n          aveIntraPerCluster += Math.abs(graph1Count - countMapI[graphKey2]);\n        });\n      });\n      aveIntraPerCluster /= (graphsNum * (graphsNum - 1)) / 2;\n      aveIntraDist += aveIntraPerCluster;\n    });\n\n    aveIntraDist /= clusters.length;\n\n    // 用类内均值计算类间距\n    let aveInterDist = 0; // 类间间距平均值\n    aveCounts.forEach((aveCount1, j) => {\n      aveCounts.forEach((aveCount2, k) => {\n        if (j === k) return;\n        aveInterDist += Math.abs(aveCount1 - aveCount2);\n      });\n      aveInterDist /= (aveCounts.length * (aveCounts.length - 1)) / 2;\n    });\n\n    // 寻找 (类间间距均值-类内间距均值) 最大的一种分组方式（对应的 structure 就是最终要找的唯一 DS(G)）\n    const offset = aveInterDist - aveIntraDist;\n    if (maxOffset < offset) {\n      maxOffset = offset;\n      representClusterType = i;\n    }\n  }\n  return {\n    structure: structures[representClusterType],\n    structureCountMap: matchedCountMap[representClusterType],\n  };\n};\n\nconst getNodeMaps = (nodes, nodeLabelProp): { nodeMap: NodeMap; nodeLabelMap: LabelMap } => {\n  const nodeMap: NodeMap = {},\n    nodeLabelMap: LabelMap = {};\n  nodes.forEach((node, i) => {\n    nodeMap[node.id] = { idx: i, node, degree: 0 };\n    const label = node[nodeLabelProp];\n    if (!nodeLabelMap[label]) nodeLabelMap[label] = [];\n    nodeLabelMap[label].push(node);\n  });\n  return { nodeMap, nodeLabelMap };\n};\n\nconst getEdgeMaps = (\n  edges,\n  edgeLabelProp,\n  nodeMap: NodeMap,\n): { edgeMap: EdgeMap; edgeLabelMap: LabelMap } => {\n  const edgeMap = {},\n    edgeLabelMap = {};\n  edges.forEach((edge, i) => {\n    edgeMap[`${uniqueId}`] = { idx: i, edge };\n    const label = edge[edgeLabelProp];\n    if (!edgeLabelMap[label]) edgeLabelMap[label] = [];\n    edgeLabelMap[label].push(edge);\n\n    const sourceNode = nodeMap[edge.source];\n    if (sourceNode) sourceNode.degree++;\n    const targetNode = nodeMap[edge.target];\n    if (targetNode) targetNode.degree++;\n  });\n  return { edgeMap, edgeLabelMap };\n};\n\n/**\n * 输出最短路径的 map，key 为 sourceNode.id-targetNode.id，value 为这两个节点的最短路径长度\n * @param nodes\n * @param spm\n * @param directed\n */\nconst getSpmMap = (nodes, spm, directed): { [key: string]: number } => {\n  const length = spm.length;\n  const map = {};\n  spm.forEach((row, i) => {\n    const start = directed ? 0 : i + 1;\n    const iId = nodes[i].id;\n    for (let j = start; j < length; j++) {\n      if (i === j) continue;\n      const jId = nodes[j].id;\n      const dist = row[j];\n      map[`${iId}-${jId}`] = dist;\n      if (!directed) map[`${jId}-${iId}`] = dist;\n    }\n  });\n  return map;\n};\n\n/**\n * 计算一对节点（node1，node2）的 NDS 距离\n * @param graph 原图数据\n * @param node1\n * @param node2\n */\nconst getNDSDist = (\n  graph,\n  node1,\n  node2,\n  nodeMap,\n  spDist,\n  kNeighborUnits,\n  structure,\n  nodeLabelProp,\n  edgeLabelProp,\n  cachedNDSMap,\n  cachedInterInducedGraph,\n) => {\n  const key = `${node1.id}-${node2.id}`;\n  if (cachedNDSMap && cachedNDSMap[key]) return cachedNDSMap[key];\n  let interInducedGraph = cachedInterInducedGraph ? cachedInterInducedGraph[key] : undefined;\n  // 若没有缓存相交邻居诱导子图，计算\n  if (!interInducedGraph) {\n    const pairMap: NodePairMap = {\n      [key]: {\n        start: nodeMap[node1.id].idx,\n        end: nodeMap[node2.id].idx,\n        distance: spDist,\n      },\n    };\n\n    cachedInterInducedGraph = getIntersectNeighborInducedGraph(\n      pairMap,\n      kNeighborUnits,\n      graph,\n      cachedInterInducedGraph,\n    );\n    interInducedGraph = cachedInterInducedGraph[key];\n  }\n\n  return getMatchedCount(interInducedGraph, structure, nodeLabelProp, edgeLabelProp);\n};\n\n/**\n * GADDI 模式匹配\n * @param graphData 原图数据\n * @param pattern 搜索图（需要在原图上搜索的模式）数据\n * @param directed 是否计算有向图，默认 false\n * @param k 参数 k，表示 k-近邻\n * @param length 参数 length\n * @param nodeLabelProp 节点数据中代表节点标签（分类信息）的属性名。默认为 cluster\n * @param edgeLabelProp 边数据中代表边标签（分类信息）的属性名。默认为 cluster\n */\nconst GADDI = (\n  graphData: GraphData,\n  pattern: GraphData,\n  directed: boolean = false,\n  k: number,\n  length: number,\n  nodeLabelProp: string = 'cluster',\n  edgeLabelProp: string = 'cluster',\n): GraphData[] => {\n  if (!graphData || !graphData.nodes) return;\n  // 分为三步：\n  // 0. 预计算：节点/边数，邻接矩阵、最短路径矩阵\n  // 1. 处理原图 graphData。再分为 1~5 小步\n  // 2. 匹配\n\n  // console.log(\"----- stage-pre: preprocessing -------\");\n\n  // -------- 第零步，预计算：节点/边数，邻接矩阵、最短路径矩阵-------\n  const nodeNum = graphData.nodes.length;\n  if (!nodeNum) return;\n  // console.log(\"----- stage-pre.1: calc shortest path matrix for graph -------\");\n  const spm = floydWarshall(graphData, directed);\n  // console.log(\n  //   \"----- stage-pre.2: calc shortest path matrix for pattern -------\"\n  // );\n  const patternSpm = floydWarshall(pattern, directed);\n  // console.log(\n  //   \"----- stage-pre.3: calc shortest path matrix map for graph -------\"\n  // );\n  const spmMap = getSpmMap(graphData.nodes, spm, directed);\n  // console.log(\n  //   \"----- stage-pre.4: calc shortest path matrix map for pattern -------\"\n  // );\n  const patternSpmMap = getSpmMap(pattern.nodes, patternSpm, directed);\n\n  // console.log(\"----- stage-pre.5: establish maps -------\");\n  // 节点的 map，以 id 为 id 映射，方便后续快速检索\n  const { nodeMap, nodeLabelMap } = getNodeMaps(graphData.nodes, nodeLabelProp);\n  const { nodeMap: patternNodeMap, nodeLabelMap: patternNodeLabelMap } = getNodeMaps(\n    pattern.nodes,\n    nodeLabelProp,\n  );\n\n  // 计算节点度数\n  getEdgeMaps(graphData.edges, edgeLabelProp, nodeMap);\n\n  const { edgeLabelMap: patternEdgeLabelMap } = getEdgeMaps(\n    pattern.edges,\n    edgeLabelProp,\n    patternNodeMap,\n  );\n\n  // 若未指定 length，自动计算 pattern 半径（最短路径最大值）\n  if (!length) length = Math.max(...patternSpm[0], 2);\n  if (!k) k = length;\n\n  // console.log(\"params\", directed, length, k);\n\n  // console.log(\"----- stage-pre.6: calc k neighbor units -------\");\n  // 计算每个节点的 k 邻元集合\n  const kNeighborUnits = findKNeighborUnits(graphData, spm, nodeLabelProp, k);\n  const patternKNeighborUnits = findKNeighborUnits(pattern, patternSpm, nodeLabelProp, k);\n\n  // console.log(\n  //   \"----- stage0: going to processing graph and find intersect neighbor induced graphs -------\"\n  // );\n\n  // console.log(\"----- stage0.1: going to select random node pairs -------\");\n  // -------- 第一步，处理原图 graphData-------\n\n  // 1.1. 随机选择最多 100 个点对，满足距离小于 Length 和 k\n  // 当 graphData 少于 20 个节点，则不能找出 100 个点对，只找出不多于 n(n-1)/2 个点对\n  const maxNodePairNum = Math.min(100, (nodeNum * (nodeNum - 1)) / 2);\n  const nodePairsMap = findNodePairsRandomly(\n    k,\n    nodeNum,\n    maxNodePairNum,\n    patternKNeighborUnits,\n    spm,\n  );\n\n  // console.log(\n  //   \"----- stage0.2: going to calculate intersect neighbor induced graphs -------\"\n  // );\n  // 1.2. 生成上面节点对的相应相交邻居诱导子图。格式为 {'beginNodeIdx-endNodeIdx': {nodes: [], edges: []}}\n  let intGMap = getIntersectNeighborInducedGraph(nodePairsMap, kNeighborUnits, graphData);\n\n  // 1.3. 使用 gSpan 算法（frequent graph mining）计算 ISIntG 的前 10 个频率最高的子结构（3-4条边）\n  const top = 10,\n    minSupport = 1,\n    minNodeNum = 1,\n    maxNodeNum = 4;\n  const params = {\n    graphs: intGMap,\n    nodeLabelProp,\n    edgeLabelProp,\n    minSupport,\n    minNodeNum,\n    maxNodeNum,\n    directed,\n  };\n\n  // console.log(\n  //   \"----- stage1: (gSpan) going to find frequent structure dsG -------\"\n  // );\n  // console.log(\"----- stage1.1: going to run gSpan -------\");\n  // 暂时假设生成的 sub structure 都只有一条边\n  const freStructures = gSpan(params).slice(0, top);\n  // structureNum 可能小于 top\n  const structureNum = freStructures.length;\n\n  // 1.4. 计算上述 10 个子结构在 intGMap 中每个诱导子图的匹配个数\n  const matchedCountMap = [];\n  freStructures.forEach((structure, i) => {\n    matchedCountMap[i] = {};\n    Object.keys(intGMap).forEach(key => {\n      const graph = intGMap[key];\n      const subStructureCount = getMatchedCount(graph, structure, nodeLabelProp, edgeLabelProp);\n      matchedCountMap[i][key] = subStructureCount;\n    });\n  });\n\n  // console.log(\n  //   \"----- stage1.1: going to find the most represent strucutre -------\"\n  // );\n\n  // 1.5. 对于每个子结构，根据匹配个数为 intGMap 中的诱导子图分组，生成 structureNum 种分组\n  // 计算每种分组的类间距和类内间距，找到类间距最大、类内间距最小的一种分组，这种分组对应的子结构被选为唯一代表性子结构 DS(G)\n  const { structure: dsG, structureCountMap: ndsDist } = findRepresentStructure(\n    matchedCountMap,\n    structureNum,\n    freStructures,\n  );\n\n  // -------- 第二步，匹配-------\n  // 2.1 从 Q 中的第一个标签的第一个节点开始，寻找 G 中的匹配\n  const beginPNode = pattern.nodes[0];\n  const label = beginPNode[nodeLabelProp];\n  // 2.1.1 找到 G 中标签与之相同的节点\n  let candidates = nodeLabelMap[label];\n\n  // console.log(\"----- stage2: going to find candidates -------\");\n\n  // 全局缓存，避免重复计算\n  const minPatternNodeLabelDegreeMap = {}; // key 是 label，value 是该 label 节点的最小度数\n  let patternIntGraphMap = {},\n    patternNDSDist = {}, // key 为 node.id-node.id\n    patternNDSDistMap = {}; // key 为 node.id-label2，value nds距离值数组（按从大到小排序，无需关心具体对应哪个 node2）\n  // 2.2.2 对于 Q 中的另一个标签的 k 个节点，计算它们到 node 的最短路径以及 NDS 距离\n  const patternSpDist = {};\n  Object.keys(patternNodeLabelMap).forEach((label2, j) => {\n    patternSpDist[label2] = [];\n    let maxDist = -Infinity;\n    const patternNodesWithLabel2 = patternNodeLabelMap[label2];\n    const patternNodePairMap = {};\n    patternNodesWithLabel2.forEach(nodeWithLabel2 => {\n      const dist = patternSpmMap[`${beginPNode.id}-${nodeWithLabel2.id}`];\n      dist && patternSpDist[label2].push(dist);\n      if (maxDist < dist) maxDist = dist;\n      patternNodePairMap[`${beginPNode.id}-${nodeWithLabel2.id}`] = {\n        start: 0,\n        end: patternNodeMap[nodeWithLabel2.id].idx,\n        distance: dist,\n      };\n    });\n\n    // spDist[label2] 按照从小到大排序\n    patternSpDist[label2] = patternSpDist[label2].sort((a, b) => a - b);\n\n    // 计算 Q 中所有 label2 节点到 beginPNode 的 NDS 距离\n    // 所有 label2 节点到 beginPNode 的邻居相交诱导子图：\n    // key: node1.id-node2.id\n    patternIntGraphMap = getIntersectNeighborInducedGraph(\n      patternNodePairMap,\n      patternKNeighborUnits,\n      pattern,\n      patternIntGraphMap,\n    );\n    // pattern 中 beginNode 到当前 label2 节点 的 NDS 距离（数组，无需关心具体对应到哪个节点）\n    let currentPatternNDSDistArray = [];\n    Object.keys(patternNodePairMap).forEach(key => {\n      if (patternNDSDist[key]) {\n        currentPatternNDSDistArray.push(patternNDSDist[key]);\n        return; // 缓存过则不需要再次计算\n      }\n      const patternIntGraph = patternIntGraphMap[key];\n      patternNDSDist[key] = getMatchedCount(patternIntGraph, dsG, nodeLabelProp, edgeLabelProp);\n      currentPatternNDSDistArray.push(patternNDSDist[key]);\n    });\n\n    // 根据值为 currentPatternNDSDist 从大到小排序\n    currentPatternNDSDistArray = currentPatternNDSDistArray.sort((a, b) => b - a);\n    patternNDSDistMap[`${beginPNode.id}-${label2}`] = currentPatternNDSDistArray;\n\n    if (label2 === label) return;\n\n    const candidatesNum = candidates.length;\n    for (let m = candidatesNum - 1; m >= 0; m--) {\n      const cNode = candidates[m];\n\n      // prune1：若 candidates 中节点 cNode 的 kNeighborUnits 中标签为 label2 的节点个数少于 pattern 中 label2 个数，删去它\n      const graphNeighborUnit = kNeighborUnits[nodeMap[cNode.id].idx];\n      const graphNeighborUnitCountMap = graphNeighborUnit.nodeLabelCountMap[label2];\n      const patternLabel2Num = patternNodeLabelMap[label2].length;\n      if (!graphNeighborUnitCountMap || graphNeighborUnitCountMap.count < patternLabel2Num) {\n        candidates.splice(m, 1);\n        continue;\n      }\n\n      // prune2：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点最短路径大于 patternSpDist[label2]，删去它\n      // (prune2 规则即：candidate 相关的最短路径的最大 spDist[label2].length 个，按照大小顺序依次和 patternSpDist[label2] 中的值比较，只要遇到一个是 G > Q 的，就删去这个 candidate)\n      let prune2Invalid = false;\n      for (let n = 0; n < patternLabel2Num; n++) {\n        if (graphNeighborUnitCountMap.dists[n] > patternSpDist[label2][n]) {\n          prune2Invalid = true;\n          break;\n        }\n      }\n      if (prune2Invalid) {\n        candidates.splice(m, 1);\n        continue;\n      }\n\n      // prune3：若 candidates 中节点 cNode 到 kNeighborUnits 中标签为 label2 的节点 NDS 距离小于 patternNDSDist[beginNode.id-label2]，删去它\n      // TODO：prune3，currentPatternNDSDistArray 与 currentNDSDist 的比较\n\n      // 计算 G 中所有 label2 节点到 cNode 的 NDS 距离\n      // 所有 label2 节点到 cNode 的邻居相交诱导子图：\n      const cNodePairMap = {};\n      graphNeighborUnit.neighbors.forEach(neighborNode => {\n        const dist = spmMap[`${cNode.id}-${neighborNode.id}`];\n        cNodePairMap[`${cNode.id}-${neighborNode.id}`] = {\n          start: nodeMap[cNode.id].idx,\n          end: nodeMap[neighborNode.id].idx,\n          distance: dist,\n        };\n      });\n      // 更新 intGMap\n      intGMap = getIntersectNeighborInducedGraph(cNodePairMap, kNeighborUnits, graphData, intGMap);\n      // candidate 到它周围 label2 节点的 NDS 距离, key 是 node.id-node.id\n      let currentNDSDistArray = [];\n      Object.keys(cNodePairMap).forEach(key => {\n        if (ndsDist[key]) {\n          currentNDSDistArray.push(ndsDist[key]);\n          return; // 缓存过则不需要再次计算\n        }\n        const intGraph = intGMap[key];\n        ndsDist[key] = getMatchedCount(intGraph, dsG, nodeLabelProp, edgeLabelProp);\n        currentNDSDistArray.push(ndsDist[key]);\n      });\n\n      // 根据值为 currentNDSDistArray 从大到小排序\n      currentNDSDistArray = currentNDSDistArray.sort((a, b) => b - a);\n\n      let prune3Invalid = false;\n      for (let n = 0; n < patternLabel2Num; n++) {\n        if (currentNDSDistArray[n] < currentPatternNDSDistArray[n]) {\n          prune3Invalid = true;\n          break;\n        }\n      }\n      if (prune3Invalid) {\n        candidates.splice(m, 1);\n        continue;\n      }\n    }\n  });\n\n  const candidateGraphs = [];\n\n  // console.log(\n  //   \"----- stage3: going to splice neighbors for each candidate graph -------\"\n  // );\n\n  // candidates 经过筛选后，以每个 candidate 为中心，生成 Length-neighbor 的邻居诱导子图\n  // 并在诱导子图中去除不可能在 Q 上找到匹配的点：在 Q 上不存在的 label，其他 label 到 candidate 的最大最短距离符合 Q、NDS 距离符合 Q\n  candidates.forEach(candidate => {\n    const nodeIdx = nodeMap[candidate.id].idx;\n    const lengthNeighborUnit = findKNeighborUnit(\n      graphData.nodes,\n      spm[nodeIdx],\n      nodeIdx,\n      nodeLabelProp,\n      length,\n    );\n\n    const neighborNodes = lengthNeighborUnit.neighbors;\n\n    // 删除不可能找到匹配的邻居点\n    const neighborNum = neighborNodes.length;\n    let unmatched = false;\n    for (let i = neighborNum - 1; i >= 0; i--) {\n      // 如果通过裁剪，符合条件的节点数量已过少，说明不能匹配这个 candidate 相关的图\n      if (neighborNodes.length + 1 < pattern.nodes.length) {\n        unmatched = true;\n        return;\n      }\n      const neighborNode = neighborNodes[i];\n      const neighborLabel = neighborNode[nodeLabelProp];\n      // prune1: 若该邻居点的 label 不存在于 pattern 中，移除这个点\n      if (!patternNodeLabelMap[neighborLabel] || !patternNodeLabelMap[neighborLabel].length) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n\n      const key = `${candidate.id}-${neighborNode.id}`;\n\n      // prune2: 若该邻居点到 candidate 的最短路径比和它有相同 label 的节点到 beginPNode 的最大最短路径长度长，移除这个点\n      // prune2.1: 如果没有这个标签到 beginPNode 的距离记录，说明 pattern 上（可能 beginPNode 是这个 label）没有其他这个 label 的节点\n      if (!patternSpDist[neighborLabel] || !patternSpDist[neighborLabel].length) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n      // prune2.2\n      const distToCandidate = spmMap[key];\n      const maxDistWithLabelInPattern =\n        patternSpDist[neighborLabel][patternSpDist[neighborLabel].length - 1]; // patternSpDist[neighborLabel] 已经按照从小到大排序\n      if (distToCandidate > maxDistWithLabelInPattern) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n\n      // prune3: 若该邻居点到 candidate 的 NDS 距离比和它有相同 label 的节点到 beginPNode 的最小 NDS 距离小，移除这个点\n      const ndsToCandidate = ndsDist[key]\n        ? ndsDist[key]\n        : getNDSDist(\n            graphData,\n            candidate,\n            neighborNode,\n            nodeMap,\n            distToCandidate,\n            kNeighborUnits,\n            dsG,\n            nodeLabelProp,\n            edgeLabelProp,\n            ndsDist,\n            intGMap,\n          );\n      const patternKey = `${beginPNode.id}-${neighborLabel}`;\n      const minNdsWithLabelInPattern =\n        patternNDSDistMap[patternKey][patternNDSDistMap[patternKey].length - 1]; // patternNDSDist[key] 一定存在\n      if (ndsToCandidate < minNdsWithLabelInPattern) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n\n      // prune4: 若该邻居点的度数小于 pattern 同 label 节点最小度数，删去该点\n      let minPatternNodeLabelDegree = minPatternNodeLabelDegreeMap[neighborLabel];\n      if (minPatternNodeLabelDegree === undefined) {\n        minPatternNodeLabelDegree = Infinity;\n        patternNodeLabelMap[neighborLabel].forEach(patternNodeWithLabel => {\n          const patternNodeDegree = patternNodeMap[patternNodeWithLabel.id].degree;\n          if (minPatternNodeLabelDegree > patternNodeDegree)\n            minPatternNodeLabelDegree = patternNodeDegree;\n        });\n        minPatternNodeLabelDegreeMap[neighborLabel] = minPatternNodeLabelDegree;\n      }\n      if (nodeMap[neighborNode.id].degree < minPatternNodeLabelDegree) {\n        neighborNodes.splice(i, 1);\n        continue;\n      }\n    }\n\n    // 节点在个数上符合匹配（不少于 pattern 的节点个数），现在筛选相关边\n    if (!unmatched) {\n      candidateGraphs.push({\n        nodes: [candidate].concat(neighborNodes),\n      });\n    }\n  });\n\n  // console.log(\n  //   \"----- stage4: going to splice edges and neighbors for each candidate graph -------\"\n  // );\n\n  const { length: undirectedLengthsToBeginPNode } = dijkstra(pattern, beginPNode.id, false);\n\n  let undirectedLengthsToBeginPNodeLabelMap = {};\n  if (directed) {\n    Object.keys(undirectedLengthsToBeginPNode).forEach(nodeId => {\n      const nodeLabel = patternNodeMap[nodeId].node[nodeLabelProp];\n      if (!undirectedLengthsToBeginPNodeLabelMap[nodeLabel])\n        undirectedLengthsToBeginPNodeLabelMap[nodeLabel] = [undirectedLengthsToBeginPNode[nodeId]];\n      else\n        undirectedLengthsToBeginPNodeLabelMap[nodeLabel].push(\n          undirectedLengthsToBeginPNode[nodeId],\n        );\n    });\n    Object.keys(undirectedLengthsToBeginPNodeLabelMap).forEach(pLabel => {\n      undirectedLengthsToBeginPNodeLabelMap[pLabel].sort((a, b) => a - b);\n    });\n  } else {\n    undirectedLengthsToBeginPNodeLabelMap = patternSpDist;\n  }\n\n  // 现在 candidateGraphs 里面只有节点，进行边的筛选\n  const candidateGraphNum = candidateGraphs.length;\n  for (let i = candidateGraphNum - 1; i >= 0; i--) {\n    const candidateGraph = candidateGraphs[i];\n    const candidate = candidateGraph.nodes[0];\n\n    const candidateNodeLabelCountMap = {};\n    const candidateNodeMap = {};\n    candidateGraph.nodes.forEach((node, q) => {\n      candidateNodeMap[node.id] = {\n        idx: q,\n        node,\n        degree: 0,\n      };\n      const cNodeLabel = node[nodeLabelProp];\n      if (!candidateNodeLabelCountMap[cNodeLabel]) candidateNodeLabelCountMap[cNodeLabel] = 1;\n      else candidateNodeLabelCountMap[cNodeLabel]++;\n    });\n\n    // 根据 candidate 和 neighborNodes 中的节点生成 G 的诱导子图\n    // 即，将 graphData 上两端都在 candidateGraph.nodes 中的边放入 candidateEdges\n    const candidateEdges = [];\n    const edgeLabelCountMap = {};\n    graphData.edges.forEach(edge => {\n      if (candidateNodeMap[edge.source] && candidateNodeMap[edge.target]) {\n        candidateEdges.push(edge);\n        if (!edgeLabelCountMap[edge[edgeLabelProp]]) edgeLabelCountMap[edge[edgeLabelProp]] = 1;\n        else edgeLabelCountMap[edge[edgeLabelProp]]++;\n        candidateNodeMap[edge.source].degree++;\n        candidateNodeMap[edge.target].degree++;\n      }\n    });\n\n    // prune：若有一个 edgeLabel 在 candidateGraph 上的个数少于 pattern，去除该图\n    const pattenrEdgeLabelNum = Object.keys(patternEdgeLabelMap).length;\n    let prunedByEdgeLabel = false;\n    for (let e = 0; e < pattenrEdgeLabelNum; e++) {\n      const label = Object.keys(patternEdgeLabelMap)[e];\n      if (\n        !edgeLabelCountMap[label] ||\n        edgeLabelCountMap[label] < patternEdgeLabelMap[label].length\n      ) {\n        prunedByEdgeLabel = true;\n        break;\n      }\n    }\n    if (prunedByEdgeLabel) {\n      candidateGraphs.splice(i, 1);\n      continue;\n    }\n\n    // 遍历 candidateEdges，进行边的筛选\n    let candidateEdgeNum = candidateEdges.length;\n\n    // prune：若边数过少，去除该图\n    if (candidateEdgeNum < pattern.edges.length) {\n      candidateGraphs.splice(i, 1);\n      break;\n    }\n    let candidateGraphInvalid = false;\n    for (let e = candidateEdgeNum - 1; e >= 0; e--) {\n      const edge = candidateEdges[e];\n      const edgeLabel = edge[edgeLabelProp];\n      const patternEdgesWithLabel = patternEdgeLabelMap[edgeLabel];\n\n      // prune 1: 若边的 label 不存在于 pattern 边 label 中，去除该边\n      if (!patternEdgesWithLabel || !patternEdgesWithLabel.length) {\n        edgeLabelCountMap[edgeLabel]--;\n        // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\n          candidateGraphInvalid = true;\n          break;\n        }\n        candidateEdges.splice(e, 1);\n        candidateNodeMap[edge.source].degree--;\n        candidateNodeMap[edge.target].degree--;\n        continue;\n      }\n\n      // prune 2: 若边的 label +两端 label 的三元组关系不能在 pattern 中找到，去除该边\n      const sourceLabel = candidateNodeMap[edge.source].node[nodeLabelProp];\n      const targetLabel = candidateNodeMap[edge.target].node[nodeLabelProp];\n\n      let edgeMatched = false;\n      patternEdgesWithLabel.forEach(patternEdge => {\n        const patternSource = patternNodeMap[patternEdge.source].node;\n        const patternTarget = patternNodeMap[patternEdge.target].node;\n        if (\n          patternSource[nodeLabelProp] === sourceLabel &&\n          patternTarget[nodeLabelProp] === targetLabel\n        )\n          edgeMatched = true;\n        if (\n          !directed &&\n          patternSource[nodeLabelProp] === targetLabel &&\n          patternTarget[nodeLabelProp] === sourceLabel\n        )\n          edgeMatched = true;\n      });\n      if (!edgeMatched) {\n        edgeLabelCountMap[edgeLabel]--;\n        // 若这个 label 的 count 减少之后，该 label 的边数不足，去除该图\n        if (patternEdgesWithLabel && edgeLabelCountMap[edgeLabel] < patternEdgesWithLabel.length) {\n          candidateGraphInvalid = true;\n          break;\n        }\n        candidateEdges.splice(e, 1);\n        candidateNodeMap[edge.source].degree--;\n        candidateNodeMap[edge.target].degree--;\n        continue;\n      }\n    }\n\n    // prune2: 删除边的过程中，发现边数过少/边 label 数过少时，去除该图\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      continue;\n    }\n\n    candidateGraph.edges = candidateEdges;\n\n    const { length: lengthsToCandidate } = dijkstra(\n      candidateGraph,\n      candidateGraph.nodes[0].id,\n      false, // 此处计算路径长度用于判断是否连通，因此使用无向图\n    );\n    Object.keys(lengthsToCandidate)\n      .reverse()\n      .forEach(targetId => {\n        if (targetId === candidateGraph.nodes[0].id || candidateGraphInvalid) return;\n        // prune4: 通过上述裁剪，可能导致该邻居子图变为不连通。裁剪掉目前在这个邻居子图中和 candidate（第一个节点）不连通的节点\n        if (lengthsToCandidate[targetId] === Infinity) {\n          const targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\n          candidateNodeLabelCountMap[targetNodeLabel]--;\n          if (\n            candidateNodeLabelCountMap[targetNodeLabel] <\n            patternNodeLabelMap[targetNodeLabel].length\n          ) {\n            candidateGraphInvalid = true;\n            return;\n          }\n          const idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\n          candidateGraph.nodes.splice(idx, 1);\n          candidateNodeMap[targetId] = undefined;\n          return;\n        }\n        // prune5: 经过边裁剪后，可能又出现了最短路径过长的节点 （比 pattern 中同 label 的节点到 beginNode 最大最短距离远），删去这些节点\n        const nLabel = nodeMap[targetId].node[nodeLabelProp];\n        if (\n          !undirectedLengthsToBeginPNodeLabelMap[nLabel] ||\n          !undirectedLengthsToBeginPNodeLabelMap[nLabel].length ||\n          lengthsToCandidate[targetId] >\n            undirectedLengthsToBeginPNodeLabelMap[nLabel][\n              undirectedLengthsToBeginPNodeLabelMap[nLabel].length - 1\n            ]\n        ) {\n          const targetNodeLabel = candidateNodeMap[targetId].node[nodeLabelProp];\n          candidateNodeLabelCountMap[targetNodeLabel]--;\n          if (\n            candidateNodeLabelCountMap[targetNodeLabel] <\n            patternNodeLabelMap[targetNodeLabel].length\n          ) {\n            candidateGraphInvalid = true;\n            return;\n          }\n          const idx = candidateGraph.nodes.indexOf(candidateNodeMap[targetId].node);\n          candidateGraph.nodes.splice(idx, 1);\n          candidateNodeMap[targetId] = undefined;\n        }\n      });\n\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      continue;\n    }\n\n    let degreeChanged = true;\n    let loopCount = 0;\n    while (degreeChanged && !candidateGraphInvalid) {\n      degreeChanged = false;\n\n      // candidate 度数不足，删去该图\n      if (candidateNodeMap[candidate.id].degree < patternNodeMap[beginPNode.id].degree) {\n        candidateGraphInvalid = true;\n        break;\n      }\n      // candidate label 个数不足，删去该图\n      if (\n        candidateNodeLabelCountMap[candidate[nodeLabelProp]] <\n        patternNodeLabelMap[candidate[nodeLabelProp]].length\n      ) {\n        candidateGraphInvalid = true;\n        break;\n      }\n\n      // prune6：去除度数过小的节点\n      const currentCandidateNodeNum = candidateGraph.nodes.length;\n      for (let o = currentCandidateNodeNum - 1; o >= 0; o--) {\n        const cgNode = candidateGraph.nodes[o];\n        const nodeDegree = candidateNodeMap[cgNode.id].degree;\n        const cNodeLabel = cgNode[nodeLabelProp];\n        if (nodeDegree < minPatternNodeLabelDegreeMap[cNodeLabel]) {\n          candidateNodeLabelCountMap[cgNode[nodeLabelProp]]--;\n          // 节点 label 个数不足\n          if (\n            candidateNodeLabelCountMap[cgNode[nodeLabelProp]] <\n            patternNodeLabelMap[cgNode[nodeLabelProp]].length\n          ) {\n            candidateGraphInvalid = true;\n            break;\n          }\n          candidateGraph.nodes.splice(o, 1);\n          candidateNodeMap[cgNode.id] = undefined;\n          degreeChanged = true;\n        }\n      }\n      if (candidateGraphInvalid || (!degreeChanged && loopCount !== 0)) break;\n      // 经过 prune5 节点裁剪，删去端点已经不在 candidateGraph 中的边\n      candidateEdgeNum = candidateEdges.length;\n      for (let y = candidateEdgeNum - 1; y >= 0; y--) {\n        const cedge = candidateEdges[y];\n        if (!candidateNodeMap[cedge.source] || !candidateNodeMap[cedge.target]) {\n          candidateEdges.splice(y, 1);\n          const edgeLabel = cedge[edgeLabelProp];\n          edgeLabelCountMap[edgeLabel]--;\n          candidateNodeMap[cedge.source] && candidateNodeMap[cedge.source].degree--;\n          candidateNodeMap[cedge.target] && candidateNodeMap[cedge.target].degree--;\n          // 边 label 数量不足\n          if (\n            patternEdgeLabelMap[edgeLabel] &&\n            edgeLabelCountMap[edgeLabel] < patternEdgeLabelMap[edgeLabel].length\n          ) {\n            candidateGraphInvalid = true;\n            break;\n          }\n          degreeChanged = true;\n        }\n      }\n      loopCount++;\n    }\n\n    if (candidateGraphInvalid) {\n      candidateGraphs.splice(i, 1);\n      continue;\n    }\n\n    // prune: 若节点/边数过少，节点/边 label 过少，去掉这个图\n    if (\n      candidateGraphInvalid ||\n      candidateGraph.nodes.length < pattern.nodes.length ||\n      candidateEdges.length < pattern.edges.length\n    ) {\n      candidateGraphs.splice(i, 1);\n      continue;\n    }\n  }\n\n  // 此时已经生成的多个 candidateGraphs，可能有重复\n\n  // console.log(\n  //   \"----- stage5: going to splice dulplicated candidate graphs -------\"\n  // );\n\n  // 删去 candidateGraphs 中一模一样的子图，通过边的 node-node-edgeLabel 作为 key，这类边个数作为 value，进行匹配\n  let currentLength = candidateGraphs.length;\n  for (let i = 0; i <= currentLength - 1; i++) {\n    const cg1 = candidateGraphs[i];\n    const cg1EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\n    cg1.edges.forEach(edge => {\n      const key = `${edge.source}-${edge.target}-${edge.label}`;\n      if (!cg1EdgeMap[key]) cg1EdgeMap[key] = 1;\n      else cg1EdgeMap[key]++;\n    });\n\n    for (let j = currentLength - 1; j > i; j--) {\n      const cg2 = candidateGraphs[j];\n      const cg2EdgeMap = {}; // [node1.id-node2.id-edge.label]: count\n      cg2.edges.forEach(edge => {\n        const key = `${edge.source}-${edge.target}-${edge.label}`;\n        if (!cg2EdgeMap[key]) cg2EdgeMap[key] = 1;\n        else cg2EdgeMap[key]++;\n      });\n\n      let same = true;\n      if (Object.keys(cg2EdgeMap).length !== Object.keys(cg1EdgeMap).length) {\n        same = false;\n      } else {\n        Object.keys(cg1EdgeMap).forEach(key => {\n          if (cg2EdgeMap[key] !== cg1EdgeMap[key]) same = false;\n        });\n      }\n      if (same) {\n        candidateGraphs.splice(j, 1);\n      }\n    }\n    currentLength = candidateGraphs.length;\n  }\n\n  return candidateGraphs;\n};\n\nexport default GADDI;\n","import LinkedList from './linked-list';\n\nexport default class Stack {\n\n  private linkedList: LinkedList;\n\n  private maxStep: number;\n\n  constructor(maxStep: number = 10) {\n    this.linkedList = new LinkedList();\n    this.maxStep = maxStep;\n  }\n\n  get length() {\n    return this.linkedList.toArray().length;\n  }\n\n  /**\n   * 判断栈是否为空，如果链表中没有头部元素，则栈为空\n   */\n  isEmpty() {\n    return !this.linkedList.head;\n  }\n\n  /**\n   * 是否到定义的栈的最大长度，如果达到最大长度后，不再允许入栈\n   */\n  isMaxStack() {\n    return this.toArray().length >= this.maxStep;\n  }\n\n  /**\n   * 访问顶端元素\n   */\n  peek() {\n    if (this.isEmpty()) {\n      return null;\n    }\n\n    // 返回头部元素，不删除元素\n    return this.linkedList.head.value;\n  }\n\n  push(value) {\n    this.linkedList.prepend(value);\n    if (this.length > this.maxStep) {\n      this.linkedList.deleteTail();\n    }\n  }\n\n  pop() {\n    const removeHead = this.linkedList.deleteHead();\n    return removeHead ? removeHead.value : null;\n  }\n\n  toArray() {\n    return this.linkedList.toArray().map((node) => node.value);\n  }\n\n  clear() {\n    while (!this.isEmpty()) {\n      this.pop();\n    }\n  }\n}\n","export const ALGORITHM = {\n  pageRank: 'pageRank',\n  breadthFirstSearch: 'breadthFirstSearch',\n  connectedComponent: 'connectedComponent',\n  depthFirstSearch: 'depthFirstSearch',\n  detectCycle: 'detectCycle',\n  dijkstra: 'dijkstra',\n  findAllPath: 'findAllPath',\n  findShortestPath: 'findShortestPath',\n  floydWarshall: 'floydWarshall',\n  getAdjMatrix: 'getAdjMatrix',\n  getDegree: 'getDegree',\n  getInDegree: 'getInDegree',\n  getNeighbors: 'getNeighbors',\n  getOutDegree: 'getOutDegree',\n  labelPropagation: 'labelPropagation',\n  louvain: 'louvain',\n  GADDI: 'GADDI',\n  minimumSpanningTree: 'minimumSpanningTree',\n  SUCCESS: 'SUCCESS',\n  FAILURE: 'FAILURE',\n};\n\nexport const MESSAGE = {\n  SUCCESS: 'SUCCESS',\n  FAILURE: 'FAILURE',\n};\n","import { MESSAGE } from './constant';\n\ninterface Event {\n  type: string;\n  data: any;\n}\n\n/**\n * 创建一个在worker中运行的算法\n * @param type 算法类型\n */\nconst createWorker = <R>(type: string) => (...data) =>\n  new Promise<R>((resolve, reject) => {\n    import('./index.worker').then(Worker => {\n      const worker = new Worker.default();\n\n      worker.postMessage({\n        type,\n        data,\n      });\n\n      worker.onmessage = (event: Event) => {\n        const { data, type } = event.data;\n        if (MESSAGE.SUCCESS === type) {\n          resolve(data);\n        } else {\n          reject();\n        }\n\n        worker.terminate();\n      };\n    });\n  });\n\nexport default createWorker;\n","import getAdjMatrix from './adjacent-matrix';\nimport breadthFirstSearch from './bfs';\nimport connectedComponent from './connected-component';\nimport getDegree from './degree';\nimport { getInDegree, getOutDegree } from './degree';\nimport detectCycle from './detect-cycle';\nimport depthFirstSearch from './dfs';\nimport dijkstra from './dijkstra';\nimport { findAllPath, findShortestPath } from './find-path';\nimport floydWarshall from './floydWarshall';\nimport labelPropagation from './label-propagation';\nimport louvain from './louvain';\nimport minimumSpanningTree from './mts';\nimport pageRank from './pageRank';\nimport GADDI from './gaddi';\nimport Stack from './structs/stack';\nimport { getNeighbors } from './util';\n\nimport {\n  getAdjMatrixAsync,\n  connectedComponentAsync,\n  getDegreeAsync,\n  getInDegreeAsync,\n  getOutDegreeAsync,\n  detectCycleAsync,\n  dijkstraAsync,\n  findAllPathAsync,\n  findShortestPathAsync,\n  floydWarshallAsync,\n  labelPropagationAsync,\n  louvainAsync,\n  minimumSpanningTreeAsync,\n  pageRankAsync,\n  getNeighborsAsync,\n  GADDIAsync,\n} from './workers/index';\n\nexport {\n  getAdjMatrix,\n  breadthFirstSearch,\n  connectedComponent,\n  getDegree,\n  getInDegree,\n  getOutDegree,\n  detectCycle,\n  depthFirstSearch,\n  dijkstra,\n  findAllPath,\n  findShortestPath,\n  floydWarshall,\n  labelPropagation,\n  louvain,\n  minimumSpanningTree,\n  pageRank,\n  getNeighbors,\n  Stack,\n  GADDI,\n  getAdjMatrixAsync,\n  connectedComponentAsync,\n  getDegreeAsync,\n  getInDegreeAsync,\n  getOutDegreeAsync,\n  detectCycleAsync,\n  dijkstraAsync,\n  findAllPathAsync,\n  findShortestPathAsync,\n  floydWarshallAsync,\n  labelPropagationAsync,\n  louvainAsync,\n  minimumSpanningTreeAsync,\n  pageRankAsync,\n  getNeighborsAsync,\n  GADDIAsync,\n};\n\nexport default {\n  getAdjMatrix,\n  breadthFirstSearch,\n  connectedComponent,\n  getDegree,\n  getInDegree,\n  getOutDegree,\n  detectCycle,\n  depthFirstSearch,\n  dijkstra,\n  findAllPath,\n  findShortestPath,\n  floydWarshall,\n  labelPropagation,\n  louvain,\n  minimumSpanningTree,\n  pageRank,\n  getNeighbors,\n  Stack,\n  GADDI,\n  getAdjMatrixAsync,\n  connectedComponentAsync,\n  getDegreeAsync,\n  getInDegreeAsync,\n  getOutDegreeAsync,\n  detectCycleAsync,\n  dijkstraAsync,\n  findAllPathAsync,\n  findShortestPathAsync,\n  floydWarshallAsync,\n  labelPropagationAsync,\n  louvainAsync,\n  minimumSpanningTreeAsync,\n  pageRankAsync,\n  getNeighborsAsync,\n  GADDIAsync,\n};","import Queue from './structs/queue'\nimport { GraphData, IAlgorithmCallbacks } from './types';\nimport { getNeighbors } from './util';\n\n/**\n *\n * @param callbacks\n * allowTraversal: 确定 BFS 是否从顶点沿着边遍历到其邻居，默认情况下，同一个节点只能遍历一次\n * enterNode: 当 BFS 访问某个节点时调用\n * leaveNode: 当 BFS 访问访问结束某个节点时调用\n */\nfunction initCallbacks(callbacks: IAlgorithmCallbacks = {} as IAlgorithmCallbacks) {\n  const initiatedCallback = callbacks;\n\n  const stubCallback = () => {};\n\n  const allowTraversalCallback = (() => {\n    const seen = {};\n    return ({ next }) => {\n      const id = next;\n      if (!seen[id]) {\n        seen[id] = true;\n        return true;\n      }\n      return false;\n    };\n  })();\n\n  initiatedCallback.allowTraversal = callbacks.allowTraversal || allowTraversalCallback;\n  initiatedCallback.enter = callbacks.enter || stubCallback;\n  initiatedCallback.leave = callbacks.leave || stubCallback;\n\n  return initiatedCallback;\n}\n\n/**\n * 广度优先遍历图\n * @param graph Graph 图实例\n * @param startNode 开始遍历的节点\n * @param originalCallbacks 回调\n */\nconst breadthFirstSearch = (\n  graphData: GraphData,\n  startNodeId: string,\n  originalCallbacks?: IAlgorithmCallbacks,\n) => {\n  const callbacks = initCallbacks(originalCallbacks);\n  const nodeQueue = new Queue();\n\n  const { edges = [] } = graphData\n\n  // 初始化队列元素\n  nodeQueue.enqueue(startNodeId);\n\n  let previousNode = '';\n\n  // 遍历队列中的所有顶点\n  while (!nodeQueue.isEmpty()) {\n    const currentNode: string = nodeQueue.dequeue();\n    callbacks.enter({\n      current: currentNode,\n      previous: previousNode,\n    });\n\n    // 将所有邻居添加到队列中以便遍历\n    getNeighbors(currentNode, edges, 'target').forEach((nextNode) => {\n      if (\n        callbacks.allowTraversal({\n          previous: previousNode,\n          current: currentNode,\n          next: nextNode,\n        })\n      ) {\n        nodeQueue.enqueue(nextNode);\n      }\n    });\n\n    callbacks.leave({\n      current: currentNode,\n      previous: previousNode,\n    });\n\n    // 下一次循环之前存储当前顶点\n    previousNode = currentNode;\n  }\n};\n\nexport default breadthFirstSearch;\n","import { GraphData, NodeConfig } from \"./types\";\nimport { getNeighbors } from \"./util\";\n\n/**\n * Generate all connected components for an undirected graph\n * @param graph\n */\nexport const detectConnectedComponents = (graphData: GraphData): NodeConfig[][] => {\n  const { nodes = [], edges = [] } = graphData\n  const allComponents: NodeConfig[][] = [];\n  const visited = {};\n  const nodeStack: NodeConfig[] = [];\n\n  const getComponent = (node: NodeConfig) => {\n    nodeStack.push(node);\n    visited[node.id] = true;\n    const neighbors = getNeighbors(node.id, edges);\n    for (let i = 0; i < neighbors.length; ++i) {\n      const neighbor = neighbors[i];\n      if (!visited[neighbor]) {\n        const targetNode = nodes.filter(node => node.id === neighbor)\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n      }\n    }\n  };\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if (!visited[node.id]) {\n      // 对于无向图进行dfs遍历，每一次调用后都得到一个连通分量\n      getComponent(node);\n      const component = [];\n      while (nodeStack.length > 0) {\n        component.push(nodeStack.pop());\n      }\n      allComponents.push(component);\n    }\n  }\n  return allComponents;\n}\n\n/**\n * Tarjan's Algorithm 复杂度  O(|V|+|E|)\n * For directed graph only\n * a directed graph is said to be strongly connected if \"every vertex is reachable from every other vertex\".\n * refer: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n * @param graph\n * @return a list of strongly connected components\n */\nexport const detectStrongConnectComponents = (graphData: GraphData): NodeConfig[][] => {\n  const { nodes = [], edges = [] } = graphData\n  const nodeStack: NodeConfig[] = [];\n  const inStack = {}; // 辅助判断是否已经在stack中，减少查找开销\n  const indices = {};\n  const lowLink = {};\n  const allComponents: NodeConfig[][] = [];\n  let index = 0;\n\n  const getComponent = (node: NodeConfig) => {\n    // Set the depth index for v to the smallest unused index\n    indices[node.id] = index;\n    lowLink[node.id] = index;\n    index += 1;\n    nodeStack.push(node);\n    inStack[node.id] = true;\n\n    // 考虑每个邻接点\n    const neighbors = getNeighbors(node.id, edges, 'target').filter((n) => nodes.map(node => node.id).indexOf(n) > -1);\n    for (let i = 0; i < neighbors.length; i++) {\n      const targetNodeID = neighbors[i];\n      if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {\n        const targetNode = nodes.filter(node => node.id === targetNodeID)\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n        // tree edge\n        lowLink[node.id] = Math.min(lowLink[node.id], lowLink[targetNodeID]);\n      } else if (inStack[targetNodeID]) {\n        // back edge, target node is in the current SCC\n        lowLink[node.id] = Math.min(lowLink[node.id], indices[targetNodeID]);\n      }\n    }\n\n    // If node is a root node, generate an SCC\n    if (lowLink[node.id] === indices[node.id]) {\n      const component = [];\n      while (nodeStack.length > 0) {\n        const tmpNode = nodeStack.pop();\n        inStack[tmpNode.id] = false;\n        component.push(tmpNode);\n        if (tmpNode === node) break;\n      }\n      if (component.length > 0) {\n        allComponents.push(component);\n      }\n    }\n  };\n\n  for (const node of nodes) {\n    if (!indices[node.id] && indices[node.id] !== 0) {\n      getComponent(node);\n    }\n  }\n\n  return allComponents;\n}\n\nexport default function getConnectedComponents(graphData: GraphData, directed?: boolean): NodeConfig[][] {\n  if (directed) return detectStrongConnectComponents(graphData);\n  return detectConnectedComponents(graphData);\n}\n","import dfs from './dfs';\nimport getConnectedComponents, { detectStrongConnectComponents } from './connected-component';\nimport { GraphData, IAlgorithmCallbacks, NodeConfig } from './types';\nimport { getNeighbors } from './util';\n\nconst detectDirectedCycle = (graphData: GraphData) => {\n  let cycle: {\n    [key: string]: string;\n  } = null;\n\n  const { nodes = [] } = graphData\n\n  const dfsParentMap = {};\n\n  // 所有没有被访问的节点集合\n  const unvisitedSet = {};\n\n  // 正在被访问的节点集合\n  const visitingSet = {};\n\n  // 所有已经被访问过的节点集合\n  const visitedSet = {};\n\n  // 初始化 unvisitedSet\n  nodes.forEach((node) => {\n    unvisitedSet[node.id] = node;\n  });\n\n  const callbacks: IAlgorithmCallbacks = {\n    enter: ({ current: currentNode, previous: previousNode }) => {\n      if (visitingSet[currentNode]) {\n        // 如果当前节点正在访问中，则说明检测到环路了\n        cycle = {};\n\n        let currentCycleNode = currentNode;\n        let previousCycleNode = previousNode;\n\n        while (previousCycleNode !== currentNode) {\n          cycle[currentCycleNode] = previousCycleNode;\n          currentCycleNode = previousCycleNode;\n          previousCycleNode = dfsParentMap[previousCycleNode];\n        }\n\n        cycle[currentCycleNode] = previousCycleNode;\n      } else {\n        // 如果不存在正在访问集合中，则将其放入正在访问集合，并从未访问集合中删除\n        visitingSet[currentNode] = currentNode;\n        delete unvisitedSet[currentNode];\n\n        // 更新 DSF parents 列表\n        dfsParentMap[currentNode] = previousNode;\n      }\n    },\n    leave: ({ current: currentNode }) => {\n      // 如果所有的节点的子节点都已经访问过了，则从正在访问集合中删除掉，并将其移入到已访问集合中，\n      // 同时也意味着当前节点的所有邻居节点都被访问过了\n      visitedSet[currentNode] = currentNode;\n      delete visitingSet[currentNode];\n    },\n    allowTraversal: ({ next: nextNode }) => {\n      // 如果检测到环路则需要终止所有进一步的遍历，否则会导致无限循环遍历\n      if (cycle) {\n        return false;\n      }\n\n      // 仅允许遍历没有访问的节点，visitedSet 中的都已经访问过了\n      return !visitedSet[nextNode];\n    },\n  };\n\n  // 开始遍历节点\n  while (Object.keys(unvisitedSet).length) {\n    // 从第一个节点开始进行 DFS 遍历\n    const firsetUnVisitedKey = Object.keys(unvisitedSet)[0];\n\n    dfs(graphData, firsetUnVisitedKey, callbacks);\n  }\n\n  return cycle;\n};\n\n/**\n * 检测无向图中的所有Base cycles\n * refer: https://www.codeproject.com/Articles/1158232/Enumerating-All-Cycles-in-an-Undirected-Graph\n * @param graph\n * @param nodeIds 节点 ID 的数组\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: INode}] 返回一组base cycles\n */\nexport const detectAllUndirectedCycle = (graphData: GraphData, nodeIds?: string[], include = true) => {\n  const allCycles = [];\n  const components = getConnectedComponents(graphData, false);\n\n  // loop through all connected components\n  for (const component of components) {\n    if (!component.length) continue;\n    const root = component[0];\n    const rootId = root.id;\n\n    const stack = [root];\n    const parent = { [rootId]: root };\n    const used = { [rootId]: new Set() };\n\n    // walk a spanning tree to find cycles\n    while (stack.length > 0) {\n      const curNode = stack.pop();\n      const curNodeId = curNode.id;\n      const neighbors = getNeighbors(curNodeId, graphData.edges);\n      for (let i = 0; i < neighbors.length; i += 1) {\n        const neighborId = neighbors[i];\n        const neighbor = graphData.nodes.find(node => node.id === neighborId)\n        // const neighborId = neighbor.get('id');\n        if (neighborId === curNodeId) {\n          // 自环\n          allCycles.push({ [neighborId]: curNode });\n        } else if (!(neighborId in used)) {\n          // visit a new node\n          parent[neighborId] = curNode;\n          stack.push(neighbor);\n          used[neighborId] = new Set([curNode]);\n        } else if (!used[curNodeId].has(neighbor)) {\n          // a cycle found\n          let cycleValid = true;\n          const cyclePath = [neighbor, curNode];\n          let p = parent[curNodeId];\n          while (used[neighborId].size && !used[neighborId].has(p)) {\n            cyclePath.push(p);\n            if (p === parent[p.id]) break;\n            else p = parent[p.id];\n          }\n          cyclePath.push(p);\n\n          if (nodeIds && include) {\n            // 如果有指定包含的节点\n            cycleValid = false;\n            if (cyclePath.findIndex((node) => nodeIds.indexOf(node.id) > -1) > -1) {\n              cycleValid = true;\n            }\n          } else if (nodeIds && !include) {\n            // 如果有指定不包含的节点\n            if (cyclePath.findIndex((node) => nodeIds.indexOf(node.id) > -1) > -1) {\n              cycleValid = false;\n            }\n          }\n\n          // 把 node list 形式转换为 cycle 的格式\n          if (cycleValid) {\n            const cycle = {};\n            for (let index = 1; index < cyclePath.length; index += 1) {\n              cycle[cyclePath[index - 1].id] = cyclePath[index];\n            }\n            if (cyclePath.length) {\n              cycle[cyclePath[cyclePath.length - 1].id] = cyclePath[0];\n            }\n            allCycles.push(cycle);\n          }\n\n          used[neighborId].add(curNode);\n        }\n      }\n    }\n  }\n\n  return allCycles;\n};\n\n/**\n * Johnson's algorithm, 时间复杂度 O((V + E)(C + 1))$ and space bounded by O(V + E)\n * refer: https://www.cs.tufts.edu/comp/150GA/homeworks/hw1/Johnson%2075.PDF\n * refer: https://networkx.github.io/documentation/stable/_modules/networkx/algorithms/cycles.html#simple_cycles\n * @param graph\n * @param nodeIds 节点 ID 的数组\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: INode}] 返回所有的 simple cycles\n */\nexport const detectAllDirectedCycle = (graphData: GraphData, nodeIds?: string[], include = true) => {\n  const path = []; // stack of nodes in current path\n  const blocked = new Set();\n  const B = []; // remember portions of the graph that yield no elementary circuit\n  const allCycles = [];\n  const idx2Node: {\n    [key: string]: NodeConfig;\n  } = {};\n  const node2Idx = {};\n\n  // 辅助函数： unblock all blocked nodes\n  const unblock = (thisNode: NodeConfig) => {\n    const stack = [thisNode];\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (blocked.has(node)) {\n        blocked.delete(node);\n        B[node.id].forEach((n) => {\n          stack.push(n);\n        });\n        B[node.id].clear();\n      }\n    }\n  };\n\n  const circuit = (node: NodeConfig, start: NodeConfig, adjList) => {\n    let closed = false; // whether a path is closed\n    if (nodeIds && include === false && nodeIds.indexOf(node.id) > -1) return closed;\n    path.push(node);\n    blocked.add(node);\n\n    const neighbors = adjList[node.id];\n    for (let i = 0; i < neighbors.length; i += 1) {\n      const neighbor = idx2Node[neighbors[i]];\n      if (neighbor === start) {\n        const cycle = {};\n        for (let index = 1; index < path.length; index += 1) {\n          cycle[path[index - 1].id] = path[index];\n        }\n        if (path.length) {\n          cycle[path[path.length - 1].id] = path[0];\n        }\n        allCycles.push(cycle);\n        closed = true;\n      } else if (!blocked.has(neighbor)) {\n        if (circuit(neighbor, start, adjList)) {\n          closed = true;\n        }\n      }\n    }\n\n    if (closed) {\n      unblock(node);\n    } else {\n      for (let i = 0; i < neighbors.length; i += 1) {\n        const neighbor = idx2Node[neighbors[i]];\n        if (!B[neighbor.id].has(node)) {\n          B[neighbor.id].add(node);\n        }\n      }\n    }\n    path.pop();\n    return closed;\n  };\n\n  const { nodes = [] } = graphData;\n\n  // Johnson's algorithm 要求给节点赋顺序，先按节点在数组中的顺序\n  for (let i = 0; i < nodes.length; i += 1) {\n    const node = nodes[i];\n    const nodeId = node.id;\n    node2Idx[nodeId] = i;\n    idx2Node[i] = node;\n  }\n  // 如果有指定包含的节点，则把指定节点排序在前，以便提早结束搜索\n  if (nodeIds && include) {\n    for (let i = 0; i < nodeIds.length; i++) {\n      const nodeId = nodeIds[i];\n      node2Idx[nodes[i].id] = node2Idx[nodeId];\n      node2Idx[nodeId] = 0;\n      idx2Node[0] = nodes.find(node => node.id === nodeId);\n      idx2Node[node2Idx[nodes[i].id]] = nodes[i];\n    }\n  }\n\n  // 返回 节点顺序 >= nodeOrder 的强连通分量的adjList\n  const getMinComponentAdj = (components: NodeConfig[][]) => {\n    let minCompIdx;\n    let minIdx = Infinity;\n\n    // Find least component and the lowest node\n    for (let i = 0; i < components.length; i += 1) {\n      const comp = components[i];\n      for (let j = 0; j < comp.length; j++) {\n        const nodeIdx = node2Idx[comp[j].id];\n        if (nodeIdx < minIdx) {\n          minIdx = nodeIdx;\n          minCompIdx = i;\n        }\n      }\n    }\n\n    const component = components[minCompIdx];\n    const adjList = [];\n    for (let i = 0; i < component.length; i += 1) {\n      const node = component[i];\n      adjList[node.id] = [];\n      for (const neighbor of getNeighbors(node.id, graphData.edges, 'target').filter((n) => component.map(c => c.id).indexOf(n) > -1)) {\n        // 对自环情况 (点连向自身) 特殊处理：记录自环，但不加入adjList\n        if (neighbor === node.id && !(include === false && nodeIds.indexOf(node.id) > -1)) {\n          allCycles.push({ [node.id]: node });\n        } else {\n          adjList[node.id].push(node2Idx[neighbor]);\n        }\n      }\n    }\n\n    return {\n      component,\n      adjList,\n      minIdx,\n    };\n  };\n\n  let nodeIdx = 0;\n  while (nodeIdx < nodes.length) {\n    const subgraphNodes = nodes.filter((n) => node2Idx[n.id] >= nodeIdx);\n    const sccs = detectStrongConnectComponents({ nodes: subgraphNodes, edges: graphData.edges }).filter(\n      (component) => component.length > 1,\n    );\n    if (sccs.length === 0) break;\n\n    const scc = getMinComponentAdj(sccs);\n    const { minIdx, adjList, component } = scc;\n    if (component.length > 1) {\n      component.forEach((node) => {\n        B[node.id] = new Set();\n      });\n      const startNode = idx2Node[minIdx];\n      // startNode 不在指定要包含的节点中，提前结束搜索\n      if (nodeIds && include && nodeIds.indexOf(startNode.id) === -1) return allCycles;\n      circuit(startNode, startNode, adjList);\n      nodeIdx = minIdx + 1;\n    } else {\n      break;\n    }\n  }\n  return allCycles;\n};\n\n/**\n * 查找图中所有满足要求的圈\n * @param graph\n * @param directed 是否为有向图\n * @param nodeIds 节点 ID 的数组，若不指定，则返回图中所有的圈\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: Node}] 包含所有环的数组，每个环用一个Object表示，其中key为节点id，value为该节点在环中指向的下一个节点\n */\nexport const detectAllCycles = (\n  graphData: GraphData,\n  directed?: boolean,\n  nodeIds?: string[],\n  include = true,\n) => {\n  if (directed) return detectAllDirectedCycle(graphData, nodeIds, include);\n  return detectAllUndirectedCycle(graphData, nodeIds, include);\n};\n\nexport default detectDirectedCycle;\n","import dijkstra from './dijkstra';\nimport { GraphData } from './types';\nimport { getNeighbors } from './util';\n\nexport const findShortestPath = (\n  graphData: GraphData,\n  start: string,\n  end: string,\n  directed?: boolean,\n  weightPropertyName?: string\n) => {\n  const { length, path, allPaths } = dijkstra(\n    graphData,\n    start,\n    directed,\n    weightPropertyName\n  );\n  return { length: length[end], path: path[end], allPath: allPaths[end] };\n};\n\nexport const findAllPath = (\n  graphData: GraphData,\n  start: string,\n  end: string,\n  directed?: boolean\n) => {\n  if (start === end) return [[start]];\n\n  const { edges = [] } = graphData;\n\n  const visited = [start];\n  const isVisited = { [start]: true };\n  const stack: string[][] = []; // 辅助栈，用于存储访问过的节点的邻居节点\n  const allPaths = [];\n  let neighbors = directed\n    ? getNeighbors(start, edges, 'target')\n    : getNeighbors(start, edges);\n  stack.push(neighbors);\n\n  while (visited.length > 0 && stack.length > 0) {\n    const children = stack[stack.length - 1];\n    if (children.length) {\n      const child = children.shift();\n      if (child) {\n        visited.push(child);\n        isVisited[child] = true;\n        neighbors = directed\n          ? getNeighbors(child, edges, 'target')\n          : getNeighbors(child, edges);\n        stack.push(neighbors.filter(neighbor => !isVisited[neighbor]));\n      }\n    } else {\n      const node = visited.pop();\n      isVisited[node] = false;\n      stack.pop();\n      continue;\n    }\n\n    if (visited[visited.length - 1] === end) {\n      const path = visited.map(node => node);\n      allPaths.push(path);\n\n      const node = visited.pop();\n      isVisited[node] = false;\n      stack.pop();\n    }\n  }\n\n  return allPaths;\n};\n","\nimport getAdjMatrix from './adjacent-matrix'\nimport { uniqueId } from './util';\nimport { GraphData, ClusterData } from './types';\n\n/**\n * 标签传播算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param maxIteration 最大迭代次数\n */\nconst labelPropagation = (\n  graphData: GraphData,\n  directed: boolean = false,\n  weightPropertyName: string = 'weight',\n  maxIteration: number = 1000\n): ClusterData => {\n  // the origin data\n  const { nodes = [], edges = [] } = graphData;\n\n  const clusters = {};\n  const nodeMap = {};\n  // init the clusters and nodeMap\n  nodes.forEach((node, i) => {\n    const cid: string = uniqueId();\n    node.clusterId = cid;\n    clusters[cid] = {\n      id: cid,\n      nodes: [node]\n    };\n    nodeMap[node.id] = {\n      node,\n      idx: i\n    };\n  });\n\n  // the adjacent matrix of calNodes inside clusters\n  const adjMatrix = getAdjMatrix(graphData, directed);\n  // the sum of each row in adjacent matrix\n  const ks = [];\n  /**\n   * neighbor nodes (id for key and weight for value) for each node\n   * neighbors = {\n   *  id(node_id): { id(neighbor_1_id): weight(weight of the edge), id(neighbor_2_id): weight(weight of the edge), ... },\n   *  ...\n   * }\n   */\n  const neighbors = {};\n  adjMatrix.forEach((row, i) => {\n    let k = 0;\n    const iid = nodes[i].id;\n    neighbors[iid] = {};\n    row.forEach((entry, j) => {\n      if (!entry) return;\n      k += entry;\n      const jid = nodes[j].id;\n      neighbors[iid][jid] = entry;\n    });\n    ks.push(k);\n  });\n\n  let iter = 0;\n\n  while (iter < maxIteration) {\n    let changed = false;\n    nodes.forEach(node => {\n      const neighborClusters = {};\n      Object.keys(neighbors[node.id]).forEach(neighborId => {\n        const neighborWeight = neighbors[node.id][neighborId];\n        const neighborNode = nodeMap[neighborId].node;\n        const neighborClusterId = neighborNode.clusterId;\n        if (!neighborClusters[neighborClusterId]) neighborClusters[neighborClusterId] = 0;\n        neighborClusters[neighborClusterId] += neighborWeight;\n      });\n      // find the cluster with max weight\n      let maxWeight = -Infinity;\n      let bestClusterIds = [];\n      Object.keys(neighborClusters).forEach(clusterId => {\n        if (maxWeight < neighborClusters[clusterId]) {\n          maxWeight = neighborClusters[clusterId];\n          bestClusterIds = [clusterId];\n        } else if (maxWeight === neighborClusters[clusterId]) {\n          bestClusterIds.push(clusterId);\n        }\n      });\n      if (bestClusterIds.length === 1 && bestClusterIds[0] === node.clusterId) return;\n      const selfClusterIdx = bestClusterIds.indexOf(node.clusterId);\n      if (selfClusterIdx >= 0) bestClusterIds.splice(selfClusterIdx, 1);\n      if (bestClusterIds && bestClusterIds.length) {\n        changed = true;\n\n        // remove from origin cluster\n        const selfCluster = clusters[node.clusterId as string];\n        const nodeInSelfClusterIdx = selfCluster.nodes.indexOf(node);\n        selfCluster.nodes.splice(nodeInSelfClusterIdx, 1);\n\n        // move the node to the best cluster\n        const randomIdx = Math.floor(Math.random() * bestClusterIds.length);\n        const bestCluster = clusters[bestClusterIds[randomIdx]];\n        bestCluster.nodes.push(node);\n        node.clusterId = bestCluster.id;\n      }\n    });\n    if (!changed) break;\n    iter++;\n  }\n\n  // delete the empty clusters\n  Object.keys(clusters).forEach(clusterId => {\n    const cluster = clusters[clusterId];\n    if (!cluster.nodes || !cluster.nodes.length) {\n      delete clusters[clusterId];\n    }\n  });\n\n  // get the cluster edges\n  const clusterEdges = [];\n  const clusterEdgeMap = {};\n  edges.forEach(edge => {\n    const { source, target } = edge;\n    const weight = edge[weightPropertyName] || 1;\n    const sourceClusterId = nodeMap[source].node.clusterId;\n    const targetClusterId = nodeMap[target].node.clusterId;\n    const newEdgeId = `${sourceClusterId}---${targetClusterId}`;\n    if (clusterEdgeMap[newEdgeId]) {\n      clusterEdgeMap[newEdgeId].weight += weight;\n      clusterEdgeMap[newEdgeId].count++;\n    } else {\n      const newEdge = {\n        source: sourceClusterId,\n        target: targetClusterId,\n        weight,\n        count: 1\n      };\n      clusterEdgeMap[newEdgeId] = newEdge;\n      clusterEdges.push(newEdge);\n    }\n  });\n\n  const clustersArray = [];\n  Object.keys(clusters).forEach(clusterId => {\n    clustersArray.push(clusters[clusterId]);\n  });\n  return {\n    clusters: clustersArray,\n    clusterEdges\n  }\n}\n\nexport default labelPropagation;\n","import { GraphData } from \"./types\";\nimport degree from './degree'\nimport { getNeighbors } from \"./util\";\n\n/**\n * PageRank https://en.wikipedia.org/wiki/PageRank\n * refer: https://github.com/anvaka/ngraph.pagerank\n * @param graph \n * @param epsilon 判断是否收敛的精度值，默认 0.000001\n * @param linkProb 阻尼系数（dumping factor），指任意时刻，用户访问到某节点后继续访问该节点链接的下一个节点的概率，经验值 0.85\n */\nconst pageRank = (graphData: GraphData, epsilon?: number, linkProb?: number): {\n  [key: string]: number;\n} => {\n  if (typeof epsilon !== 'number') epsilon = 0.000001;\n  if (typeof linkProb !== 'number') linkProb = 0.85;\n\n  let distance = 1;\n  let leakedRank = 0;\n  let maxIterations = 1000;\n\n  const { nodes = [], edges = [] } = graphData;\n  const nodesCount = nodes.length;\n  let currentRank;\n  const curRanks = {};\n  const prevRanks = {}\n\n  // Initialize pageranks 初始化\n  for (let j = 0; j < nodesCount; ++j) {\n    const node = nodes[j];\n    const nodeId = node.id;\n    curRanks[nodeId] = (1 / nodesCount)\n    prevRanks[nodeId] = (1 / nodesCount)\n  }\n\n  const nodeDegree = degree(graphData)\n  while (maxIterations > 0 && distance > epsilon) {\n    leakedRank = 0;\n    for (let j = 0; j < nodesCount; ++j) {\n      const node = nodes[j];\n      const nodeId = node.id;\n      currentRank = 0;\n      if (nodeDegree[node.id].inDegree === 0) {\n        curRanks[nodeId] = 0;\n      } else {\n        const neighbors = getNeighbors(nodeId, edges, 'source');\n        for (let i = 0; i < neighbors.length; ++i) {\n          const neighbor = neighbors[i];\n          const outDegree: number = nodeDegree[neighbor].outDegree;\n          if (outDegree > 0) currentRank += (prevRanks[neighbor] / outDegree);\n        }\n        curRanks[nodeId] = linkProb * currentRank;\n        leakedRank += curRanks[nodeId];\n      }\n    }\n\n    leakedRank = (1 - leakedRank) / nodesCount;\n    distance = 0;\n    for (let j = 0; j < nodesCount; ++j) {\n      const node = nodes[j];\n      const nodeId = node.id;\n      currentRank = curRanks[nodeId] + leakedRank;\n      distance += Math.abs(currentRank - prevRanks[nodeId]);\n      prevRanks[nodeId] = currentRank;\n    }\n    maxIterations -= 1\n  }\n\n  return prevRanks;\n}\n\nexport default pageRank\n","import {\n  GraphData,\n  DegreeType,\n  Matrix,\n  IAlgorithmCallbacks,\n  ClusterData,\n  EdgeConfig,\n  NodeConfig,\n} from '../types';\nimport createWorker from './createWorker';\nimport { ALGORITHM } from './constant';\n\n/**\n * @param graphData 图数据\n * @param directed 是否为有向图\n */\nconst getAdjMatrixAsync = (graphData: GraphData, directed?: boolean) =>\n  createWorker<Matrix[]>(ALGORITHM.getAdjMatrix)(...[graphData, directed]);\n\n/**\n * 图的连通分量\n * @param graphData 图数据\n * @param directed 是否为有向图\n */\nconst connectedComponentAsync = (graphData: GraphData, directed?: boolean) =>\n  createWorker<NodeConfig[][]>(ALGORITHM.connectedComponent)(...[graphData, directed]);\n\n/**\n * 获取节点的度\n * @param graphData 图数据\n */\nconst getDegreeAsync = (graphData: GraphData) =>\n  createWorker<DegreeType>(ALGORITHM.getDegree)(graphData);\n\n/**\n * 获取节点的入度\n * @param graphData 图数据\n * @param nodeId 节点ID\n */\nconst getInDegreeAsync = (graphData: GraphData, nodeId: string) =>\n  createWorker<DegreeType>(ALGORITHM.getInDegree)(graphData, nodeId);\n\n/**\n * 获取节点的出度\n * @param graphData 图数据\n * @param nodeId 节点ID\n */\nconst getOutDegreeAsync = (graphData: GraphData, nodeId: string) =>\n  createWorker<DegreeType>(ALGORITHM.getOutDegree)(graphData, nodeId);\n\n/**\n * 检测图中的 Cycle\n * @param graphData 图数据\n */\nconst detectCycleAsync = (graphData: GraphData) =>\n  createWorker<{\n    [key: string]: string;\n  }>(ALGORITHM.detectCycle)(graphData);\n\n/**\n * Dijkstra's algorithm, See {@link https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm}\n * @param graphData 图数据\n */\nconst dijkstraAsync = (\n  graphData: GraphData,\n  source: string,\n  directed?: boolean,\n  weightPropertyName?: string,\n) =>\n  createWorker<{\n    length: number;\n    path: any;\n    allPaths: any;\n  }>(ALGORITHM.dijkstra)(...[graphData, source, directed, weightPropertyName]);\n\n/**\n * 查找两点之间的所有路径\n * @param graphData 图数据\n * @param start 路径起始点ID\n * @param end 路径终点ID\n * @param directed 是否为有向图\n */\nconst findAllPathAsync = (graphData: GraphData, start: string, end: string, directed?: boolean) =>\n  createWorker<string[][]>(ALGORITHM.findAllPath)(...[graphData, start, end, directed]);\n\n/**\n * 查找两点之间的所有路径\n * @param graphData 图数据\n * @param start 路径起始点ID\n * @param end 路径终点ID\n * @param directed 是否为有向图\n * @param weightPropertyName 边权重的属名称，若数据中没有权重，则默认每条边权重为 1\n */\nconst findShortestPathAsync = (\n  graphData: GraphData,\n  start: string,\n  end: string,\n  directed?: boolean,\n  weightPropertyName?: string,\n) =>\n  createWorker<{\n    length: number;\n    path: any;\n    allPaths: any;\n  }>(ALGORITHM.findShortestPath)(...[graphData, start, end, directed, weightPropertyName]);\n\n/**\n * Floyd–Warshall algorithm, See {@link https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm}\n * @param graphData 图数据\n * @param directed 是否为有向图\n */\nconst floydWarshallAsync = (graphData: GraphData, directed?: boolean) =>\n  createWorker<Matrix[]>(ALGORITHM.floydWarshall)(...[graphData, directed]);\n\n/**\n * 标签传播算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param maxIteration 最大迭代次数\n */\nconst labelPropagationAsync = (\n  graphData: GraphData,\n  directed: boolean,\n  weightPropertyName: string,\n  maxIteration: number,\n) =>\n  createWorker<ClusterData>(ALGORITHM.labelPropagation)(\n    graphData,\n    directed,\n    weightPropertyName,\n    maxIteration,\n  );\n\n/**\n * 社区发现 louvain 算法\n * @param graphData 图数据\n * @param directed 是否有向图，默认为 false\n * @param weightPropertyName 权重的属性字段\n * @param threshold\n */\nconst louvainAsync = (\n  graphData: GraphData,\n  directed: boolean,\n  weightPropertyName: string,\n  threshold: number,\n) =>\n  createWorker<ClusterData>(ALGORITHM.louvain)(graphData, directed, weightPropertyName, threshold);\n\n/**\n * 最小生成树，See {@link https://en.wikipedia.org/wiki/Kruskal%27s_algorithm}\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @param algo 'prim' | 'kruskal' 算法类型\n * @return EdgeConfig[] 返回构成MST的边的数组\n */\nconst minimumSpanningTreeAsync = (graphData: GraphData, weight?: boolean, algo?: string) =>\n  createWorker<EdgeConfig[]>(ALGORITHM.minimumSpanningTree)(...[graphData, weight, algo]);\n\n/**\n * PageRank https://en.wikipedia.org/wiki/PageRank\n * refer: https://github.com/anvaka/ngraph.pagerank\n * @param graph\n * @param epsilon 判断是否收敛的精度值，默认 0.000001\n * @param linkProb 阻尼系数（dumping factor），指任意时刻，用户访问到某节点后继续访问该节点链接的下一个节点的概率，经验值 0.85\n */\nconst pageRankAsync = (graphData: GraphData, epsilon?: number, linkProb?: number) =>\n  createWorker<{\n    [key: string]: number;\n  }>(ALGORITHM.pageRank)(...[graphData, epsilon, linkProb]);\n\n/**\n * 获取指定节点的所有邻居\n * @param nodeId 节点 ID\n * @param edges 图中的所有边数据\n * @param type 邻居类型\n */\nconst getNeighborsAsync = (\n  nodeId: string,\n  edges: EdgeConfig[],\n  type?: 'target' | 'source' | undefined,\n) => createWorker<string[]>(ALGORITHM.getNeighbors)(...[nodeId, edges, type]);\n\n/**\n * GADDI 图模式匹配\n * @param graphData 原图数据\n * @param pattern 搜索图（需要在原图上搜索的模式）数据\n * @param directed 是否计算有向图，默认 false\n * @param k 参数 k，表示 k-近邻\n * @param length 参数 length\n * @param nodeLabelProp 节点数据中代表节点标签（分类信息）的属性名。默认为 cluster\n * @param edgeLabelProp 边数据中代表边标签（分类信息）的属性名。默认为 cluster\n */\nconst GADDIAsync = (\n  graphData: GraphData,\n  pattern: GraphData,\n  directed: boolean = false,\n  k: number,\n  length: number,\n  nodeLabelProp: string = 'cluster',\n  edgeLabelProp: string = 'cluster',\n) =>\n  createWorker<GraphData[]>(ALGORITHM.GADDI)(\n    ...[graphData, pattern, directed, k, length, nodeLabelProp, edgeLabelProp],\n  );\n\nexport {\n  getAdjMatrixAsync,\n  connectedComponentAsync,\n  getDegreeAsync,\n  getInDegreeAsync,\n  getOutDegreeAsync,\n  detectCycleAsync,\n  dijkstraAsync,\n  findAllPathAsync,\n  findShortestPathAsync,\n  floydWarshallAsync,\n  labelPropagationAsync,\n  louvainAsync,\n  minimumSpanningTreeAsync,\n  pageRankAsync,\n  getNeighborsAsync,\n  GADDIAsync,\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(59);\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".min.js\";\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"./dist\";","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// Promise = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t826: 0\n};\n\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => {\n\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId] = [resolve, reject];\n\t\t\t\t\t});\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t} else installedChunks[chunkId] = 0;\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no deferred startup\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0, resolves = [];\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tresolves.push(installedChunks[chunkId][0]);\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\tfor(moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\twhile(resolves.length) {\n\t\tresolves.shift()();\n\t}\n\n}\n\nvar chunkLoadingGlobal = this[\"webpackChunkAlgorithm\"] = this[\"webpackChunkAlgorithm\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));\n\n// no deferred startup"],"sourceRoot":""},"metadata":{},"sourceType":"script"}