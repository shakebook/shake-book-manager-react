{"ast":null,"code":"import { get, isNumber } from '@antv/util';\n/**\n * 查看数据是否是全负数、或者全正数\n * @param data\n * @param field\n */\n\nexport function adjustYMetaByZero(data, field) {\n  // 过滤出数字数据\n  var numberData = data.filter(function (datum) {\n    var v = get(datum, [field]);\n    return isNumber(v) && !isNaN(v);\n  });\n  var gtZero = numberData.every(function (datum) {\n    return get(datum, [field]) >= 0;\n  });\n  var ltZero = numberData.every(function (datum) {\n    return get(datum, [field]) <= 0;\n  }); // 目前是增量更新，对 { min: 0, max: undefined } 进行 update({ max: 0 }) 会得到 { min: 0, max: 0 }\n\n  if (gtZero) {\n    return {\n      min: 0\n    };\n  }\n\n  if (ltZero) {\n    return {\n      max: 0\n    };\n  }\n\n  return {};\n}\n/**\n * 转换数据格式为带有节点与边的数据格式\n * @param data\n * @param sourceField\n * @param targetField\n * @param weightField\n */\n\nexport function transformDataToNodeLinkData(data, sourceField, targetField, weightField) {\n  if (!Array.isArray(data)) {\n    return {\n      nodes: [],\n      links: []\n    };\n  } //   const nodes = [];\n\n\n  var links = []; // 先使用对象方式存储\n\n  var nodesMap = {};\n  var nodesIndex = -1; // 数组变换成 chord layout 的数据结构\n\n  data.forEach(function (datum) {\n    var source = datum[sourceField];\n    var target = datum[targetField];\n    var weight = datum[weightField]; // source node\n\n    if (!nodesMap[source]) {\n      nodesMap[source] = {\n        id: ++nodesIndex,\n        name: source\n      };\n    }\n\n    if (!nodesMap[target]) {\n      nodesMap[target] = {\n        id: ++nodesIndex,\n        name: target\n      };\n    } // links\n\n\n    links.push({\n      source: nodesMap[source].id,\n      target: nodesMap[target].id,\n      // sourceName: source,\n      // targetName: target,\n      value: weight\n    });\n  });\n  return {\n    nodes: Object.values(nodesMap),\n    links: links\n  };\n}","map":{"version":3,"sources":["../../src/utils/data.ts"],"names":[],"mappings":"AAAA,SAAS,GAAT,EAAc,QAAd,QAA8B,YAA9B;AAIA;;;;AAIG;;AACH,OAAM,SAAU,iBAAV,CAA4B,IAA5B,EAAwC,KAAxC,EAAqD;AACzD;AACA,MAAM,UAAU,GAAG,IAAI,CAAC,MAAL,CAAY,UAAC,KAAD,EAAa;AAC1C,QAAM,CAAC,GAAG,GAAG,CAAC,KAAD,EAAQ,CAAC,KAAD,CAAR,CAAb;AACA,WAAO,QAAQ,CAAC,CAAD,CAAR,IAAe,CAAC,KAAK,CAAC,CAAD,CAA5B;AACD,GAHkB,CAAnB;AAKA,MAAM,MAAM,GAAG,UAAU,CAAC,KAAX,CAAiB,UAAC,KAAD,EAAa;AAAK,WAAA,GAAG,CAAC,KAAD,EAAQ,CAAC,KAAD,CAAR,CAAH,IAAA,CAAA;AAAwB,GAA3D,CAAf;AACA,MAAM,MAAM,GAAG,UAAU,CAAC,KAAX,CAAiB,UAAC,KAAD,EAAa;AAAK,WAAA,GAAG,CAAC,KAAD,EAAQ,CAAC,KAAD,CAAR,CAAH,IAAA,CAAA;AAAwB,GAA3D,CAAf,CARyD,CAUzD;;AACA,MAAI,MAAJ,EAAY;AACV,WAAO;AAAE,MAAA,GAAG,EAAE;AAAP,KAAP;AACD;;AACD,MAAI,MAAJ,EAAY;AACV,WAAO;AAAE,MAAA,GAAG,EAAE;AAAP,KAAP;AACD;;AACD,SAAO,EAAP;AACD;AACD;;;;;;AAMG;;AACH,OAAM,SAAU,2BAAV,CACJ,IADI,EAEJ,WAFI,EAGJ,WAHI,EAIJ,WAJI,EAIe;AAEnB,MAAI,CAAC,KAAK,CAAC,OAAN,CAAc,IAAd,CAAL,EAA0B;AACxB,WAAO;AACL,MAAA,KAAK,EAAE,EADF;AAEL,MAAA,KAAK,EAAE;AAFF,KAAP;AAID,GAPkB,CASnB;;;AACA,MAAM,KAAK,GAAG,EAAd,CAVmB,CAWnB;;AACA,MAAM,QAAQ,GAAG,EAAjB;AACA,MAAI,UAAU,GAAG,CAAC,CAAlB,CAbmB,CAcnB;;AACA,EAAA,IAAI,CAAC,OAAL,CAAa,UAAC,KAAD,EAAa;AACxB,QAAM,MAAM,GAAG,KAAK,CAAC,WAAD,CAApB;AACA,QAAM,MAAM,GAAG,KAAK,CAAC,WAAD,CAApB;AACA,QAAM,MAAM,GAAG,KAAK,CAAC,WAAD,CAApB,CAHwB,CAKxB;;AACA,QAAI,CAAC,QAAQ,CAAC,MAAD,CAAb,EAAuB;AACrB,MAAA,QAAQ,CAAC,MAAD,CAAR,GAAmB;AACjB,QAAA,EAAE,EAAE,EAAE,UADW;AAEjB,QAAA,IAAI,EAAE;AAFW,OAAnB;AAID;;AACD,QAAI,CAAC,QAAQ,CAAC,MAAD,CAAb,EAAuB;AACrB,MAAA,QAAQ,CAAC,MAAD,CAAR,GAAmB;AACjB,QAAA,EAAE,EAAE,EAAE,UADW;AAEjB,QAAA,IAAI,EAAE;AAFW,OAAnB;AAID,KAjBuB,CAkBxB;;;AACA,IAAA,KAAK,CAAC,IAAN,CAAW;AACT,MAAA,MAAM,EAAE,QAAQ,CAAC,MAAD,CAAR,CAAiB,EADhB;AAET,MAAA,MAAM,EAAE,QAAQ,CAAC,MAAD,CAAR,CAAiB,EAFhB;AAGT;AACA;AACA,MAAA,KAAK,EAAE;AALE,KAAX;AAOD,GA1BD;AA2BA,SAAO;AACL,IAAA,KAAK,EAAE,MAAM,CAAC,MAAP,CAAc,QAAd,CADF;AAEL,IAAA,KAAK,EAAA;AAFA,GAAP;AAID","sourcesContent":["import { get, isNumber } from '@antv/util';\nimport { Data, Datum, Meta } from '../types';\nimport { NodeLinkData } from '../types/relation-data';\n\n/**\n * 查看数据是否是全负数、或者全正数\n * @param data\n * @param field\n */\nexport function adjustYMetaByZero(data: Data, field: string): Meta {\n  // 过滤出数字数据\n  const numberData = data.filter((datum: Datum) => {\n    const v = get(datum, [field]);\n    return isNumber(v) && !isNaN(v);\n  });\n\n  const gtZero = numberData.every((datum: Datum) => get(datum, [field]) >= 0);\n  const ltZero = numberData.every((datum: Datum) => get(datum, [field]) <= 0);\n\n  // 目前是增量更新，对 { min: 0, max: undefined } 进行 update({ max: 0 }) 会得到 { min: 0, max: 0 }\n  if (gtZero) {\n    return { min: 0 };\n  }\n  if (ltZero) {\n    return { max: 0 };\n  }\n  return {};\n}\n/**\n * 转换数据格式为带有节点与边的数据格式\n * @param data\n * @param sourceField\n * @param targetField\n * @param weightField\n */\nexport function transformDataToNodeLinkData(\n  data: Data,\n  sourceField: string,\n  targetField: string,\n  weightField: string\n): NodeLinkData {\n  if (!Array.isArray(data)) {\n    return {\n      nodes: [],\n      links: [],\n    };\n  }\n\n  //   const nodes = [];\n  const links = [];\n  // 先使用对象方式存储\n  const nodesMap = {};\n  let nodesIndex = -1;\n  // 数组变换成 chord layout 的数据结构\n  data.forEach((datum: Datum) => {\n    const source = datum[sourceField];\n    const target = datum[targetField];\n    const weight = datum[weightField];\n\n    // source node\n    if (!nodesMap[source]) {\n      nodesMap[source] = {\n        id: ++nodesIndex,\n        name: source,\n      };\n    }\n    if (!nodesMap[target]) {\n      nodesMap[target] = {\n        id: ++nodesIndex,\n        name: target,\n      };\n    }\n    // links\n    links.push({\n      source: nodesMap[source].id,\n      target: nodesMap[target].id,\n      // sourceName: source,\n      // targetName: target,\n      value: weight,\n    });\n  });\n  return {\n    nodes: Object.values(nodesMap),\n    links,\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}