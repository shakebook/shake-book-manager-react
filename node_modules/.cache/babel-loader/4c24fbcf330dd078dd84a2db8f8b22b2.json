{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n/**\n * 通过配置不同的 costFunc, distFunc, constraints 可以得到不同效果的 router\n * generalRouter: 不限制搜索时的移动方向，避开障碍即可\n * orthogonal: 线必须沿着竖直或水平方向（4个方向）\n * octolinearRouter: 线沿着竖直、水平、对角线方向（8个方向）\n */\n\n\nimport { Util } from '@antv/g6-core';\nimport { deepMix } from '@antv/util';\nimport { getExpandedBBox, getExpandedBBoxPoint, getPolylinePoints, simplifyPolyline, isSegmentCrossingBBox } from './polyline-util';\n\nvar manhattanDist = function manhattanDist(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n\nvar eucliDist = function eucliDist(p1, p2) {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n};\n\nvar straightPath = function straightPath(start, end) {\n  // console.warn('fallbackRoute: straight path');\n  return [start, end];\n};\n\nvar simplePolyline = function simplePolyline(start, end, startNode, endNode, cfg) {\n  // console.warn('fallbackRoute: simple polyline path');\n  return simplifyPolyline(getPolylinePoints(start, end, startNode, endNode, cfg.offset));\n}; // getPolylinePoints\n\n\nvar defaultCfg = {\n  offset: 20,\n  maxAllowedDirectionChange: 90,\n  maximumLoops: 2000,\n  gridSize: 10,\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: -1\n  }],\n\n  get penalties() {\n    return {\n      0: 0,\n      45: this.gridSize / 2,\n      90: this.gridSize / 2\n    };\n  },\n\n  distFunc: manhattanDist,\n  fallbackRoute: simplePolyline\n};\nexport var octolinearCfg = {\n  maxAllowedDirectionChange: 45,\n  // 8 个方向: 上下左右 + 45度斜线方向\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: 1,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: -1\n  }, {\n    stepX: 0,\n    stepY: -1\n  }, {\n    stepX: 1,\n    stepY: -1\n  }],\n  distFunc: eucliDist,\n  fallbackRoute: straightPath\n};\n\nvar pos2GridIx = function pos2GridIx(pos, gridSize) {\n  var gridIx = Math.floor(Math.abs(pos / gridSize));\n  var sign = pos < 0 ? -1 : 1;\n  return gridIx < 0 ? 0 : sign * gridIx;\n};\n\nvar getObstacleMap = function getObstacleMap(items, gridSize, offset) {\n  var map = {};\n  items.forEach(function (item) {\n    // create-edge 时，当边类型为 polyline 时 endNode 为 null\n    if (item) {\n      var bbox = getExpandedBBox(item.getBBox(), offset);\n\n      for (var x = pos2GridIx(bbox.minX, gridSize); x <= pos2GridIx(bbox.maxX, gridSize); x += 1) {\n        for (var y = pos2GridIx(bbox.minY, gridSize); y <= pos2GridIx(bbox.maxY, gridSize); y += 1) {\n          var gridKey = x + \"|||\" + y;\n          map[gridKey] = true;\n        }\n      }\n    }\n  });\n  return map;\n};\n/**\n * 方向角：计算从 p1 到 p2 的射线与水平线形成的夹角度数（顺时针从右侧0°转到该射线的角度）\n * @param p1 PolyPoint\n * @param p2 PolyPoint\n */\n\n\nvar getDirectionAngle = function getDirectionAngle(p1, p2) {\n  var deltaX = p2.x - p1.x;\n  var deltaY = p2.y - p1.y;\n  if (!deltaX && !deltaY) return 0;\n  var angle = (360 + Math.atan2(deltaY, deltaX) * 180 / Math.PI) % 360;\n  return angle;\n};\n/**\n * 方向角的改变，取小于180度角\n * @param angle1\n * @param angle2\n */\n\n\nvar getAngleDiff = function getAngleDiff(angle1, angle2) {\n  var directionChange = Math.abs(angle1 - angle2);\n  return directionChange > 180 ? 360 - directionChange : directionChange;\n}; // Path finder //\n\n\nvar estimateCost = function estimateCost(from, endPoints, distFunc) {\n  var min = Infinity;\n\n  for (var i = 0, len = endPoints.length; i < len; i++) {\n    var cost = distFunc(from, endPoints[i]);\n\n    if (cost < min) {\n      min = cost;\n    }\n  }\n\n  return min;\n}; // 计算考虑 offset 后的 BBox 上的连接点\n\n\nvar getBoxPoints = function getBoxPoints(point, oriPoint, node, anotherPoint, cfg) {\n  var points = []; // create-edge 生成边的过程中，endNode 为 null\n\n  if (!node) {\n    return points;\n  }\n\n  var directions = cfg.directions,\n      offset = cfg.offset;\n  var bbox = node.getBBox();\n  var isInside = oriPoint.x > bbox.minX && oriPoint.x < bbox.maxX && oriPoint.y > bbox.minY && oriPoint.y < bbox.maxY;\n  var expandBBox = getExpandedBBox(bbox, offset);\n\n  for (var i in expandBBox) {\n    expandBBox[i] = pos2GridIx(expandBBox[i], cfg.gridSize);\n  }\n\n  if (isInside) {\n    // 如果 anchorPoint 在节点内部，允许第一段线穿过节点\n    for (var _i = 0, directions_1 = directions; _i < directions_1.length; _i++) {\n      var dir = directions_1[_i];\n      var bounds = [[{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }]];\n\n      for (var i = 0; i < 4; i++) {\n        var boundLine = bounds[i];\n        var insterctP = Util.getLineIntersect(point, {\n          x: point.x + dir.stepX * expandBBox.width,\n          y: point.y + dir.stepY * expandBBox.height\n        }, boundLine[0], boundLine[1]);\n\n        if (insterctP && !isSegmentCrossingBBox(point, insterctP, bbox)) {\n          insterctP.id = insterctP.x + \"|||\" + insterctP.y;\n          points.push(insterctP);\n        }\n      }\n    }\n  } else {\n    // 如果 anchorPoint 在节点上，只有一个可选方向\n    var insterctP = getExpandedBBoxPoint(expandBBox, point, anotherPoint);\n    insterctP.id = insterctP.x + \"|||\" + insterctP.y;\n    points.push(insterctP);\n  }\n\n  return points;\n};\n\nexport var pathFinder = function pathFinder(startPoint, endPoint, startNode, endNode, routerCfg) {\n  var cfg = deepMix(defaultCfg, routerCfg);\n  cfg.obstacles = cfg.obstacles || [];\n  var map = getObstacleMap(cfg.obstacles.concat([startNode, endNode]), cfg.gridSize, cfg.offset);\n  var scaleStartPoint = {\n    x: pos2GridIx(startPoint.x, cfg.gridSize),\n    y: pos2GridIx(startPoint.y, cfg.gridSize)\n  };\n  var scaleEndPoint = {\n    x: pos2GridIx(endPoint.x, cfg.gridSize),\n    y: pos2GridIx(endPoint.y, cfg.gridSize)\n  };\n  startPoint.id = scaleStartPoint.x + \"|||\" + scaleStartPoint.y;\n  endPoint.id = scaleEndPoint.x + \"|||\" + scaleEndPoint.y;\n  var startPoints = getBoxPoints(scaleStartPoint, startPoint, startNode, scaleEndPoint, cfg);\n  var endPoints = getBoxPoints(scaleEndPoint, endPoint, endNode, scaleStartPoint, cfg);\n  startPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  endPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  var openSet = {};\n  var closedSet = {};\n  var cameFrom = {}; // 从起点到当前点已产生的 cost, default: Infinity\n\n  var gScore = {}; // 起点经过当前点到达终点预估的 cost, default: Infinity\n\n  var fScore = {}; // initialize\n\n  for (var i = 0; i < startPoints.length; i++) {\n    var firstStep = startPoints[i];\n    openSet[firstStep.id] = firstStep; // cameFrom[firstStep.id] = startPoint.id;\n\n    gScore[firstStep.id] = 0;\n    fScore[firstStep.id] = estimateCost(firstStep, endPoints, cfg.distFunc);\n  }\n\n  var getDirectionChange = function getDirectionChange(current, neighbor) {\n    var directionAngle = getDirectionAngle(current, neighbor);\n    var directionChange;\n\n    if (!cameFrom[current.id]) {\n      var startAngle = getDirectionAngle(scaleStartPoint, current);\n      directionChange = getAngleDiff(startAngle, directionAngle);\n    } else {\n      var prevDirectionAngle = getDirectionAngle({\n        x: parseFloat(cameFrom[current.id].split('|||')[0]),\n        y: parseFloat(cameFrom[current.id].split('|||')[1])\n      }, current);\n      directionChange = getAngleDiff(prevDirectionAngle, directionAngle);\n    }\n\n    return directionChange;\n  };\n\n  var getControlPoints = function getControlPoints(currentId) {\n    var controlPoints = [endPoint];\n    var lastPoint = {\n      x: parseFloat(currentId.split('|||')[0]),\n      y: parseFloat(currentId.split('|||')[1]),\n      id: currentId\n    };\n\n    if (getDirectionChange(lastPoint, scaleEndPoint)) {\n      controlPoints.unshift({\n        x: lastPoint.x === scaleEndPoint.x ? endPoint.x : lastPoint.x * cfg.gridSize,\n        y: lastPoint.y === scaleEndPoint.y ? endPoint.y : lastPoint.y * cfg.gridSize\n      });\n    }\n\n    while (cameFrom[currentId] && cameFrom[currentId] !== currentId) {\n      var point = {\n        x: parseFloat(currentId.split('|||')[0]),\n        y: parseFloat(currentId.split('|||')[1]),\n        id: currentId\n      };\n      var preId = cameFrom[currentId];\n      var prePoint = {\n        x: parseFloat(preId.split('|||')[0]),\n        y: parseFloat(preId.split('|||')[1]),\n        id: preId\n      };\n      var directionChange = getDirectionChange(prePoint, point);\n\n      if (directionChange) {\n        controlPoints.unshift({\n          x: prePoint.x === point.x ? controlPoints[0].x : prePoint.x * cfg.gridSize,\n          y: prePoint.y === point.y ? controlPoints[0].y : prePoint.y * cfg.gridSize\n        });\n      }\n\n      currentId = preId;\n    } // 和startNode对齐\n\n\n    var firstPoint = {\n      x: parseFloat(currentId.split('|||')[0]),\n      y: parseFloat(currentId.split('|||')[1]),\n      id: currentId\n    };\n    controlPoints[0].x = firstPoint.x === scaleStartPoint.x ? startPoint.x : controlPoints[0].x;\n    controlPoints[0].y = firstPoint.y === scaleStartPoint.y ? startPoint.y : controlPoints[0].y;\n    controlPoints.unshift(startPoint);\n    return controlPoints;\n  };\n\n  var remainLoops = cfg.maximumLoops;\n\n  var _loop_1 = function _loop_1() {\n    var current;\n    var curCost = Infinity; // 找到 openSet 中 fScore 最小的点\n\n    for (var id in openSet) {\n      if (fScore[id] <= curCost) {\n        curCost = fScore[id];\n        current = openSet[id];\n      }\n    }\n\n    if (!current) return \"break\"; // 如果 fScore 最小的点就是终点\n\n    if (endPoints.findIndex(function (point) {\n      return point.x === current.x && point.y === current.y;\n    }) > -1) {\n      var controlPoints = getControlPoints(current.id);\n      return {\n        value: controlPoints\n      };\n    }\n\n    delete openSet[current.id];\n    closedSet[current.id] = true; // 获取符合条件的下一步的候选连接点\n    // 沿候选方向走一步\n\n    for (var i = 0; i < cfg.directions.length; i++) {\n      var direction = cfg.directions[i];\n      var neighbor = {\n        x: current.x + direction.stepX,\n        y: current.y + direction.stepY,\n        id: current.x + direction.stepX + \"|||\" + (current.y + direction.stepY)\n      };\n      if (closedSet[neighbor.id]) continue;\n      var directionChange = getDirectionChange(current, neighbor);\n      if (directionChange > cfg.maxAllowedDirectionChange) continue;\n      if (map[neighbor.id]) continue; // 如果交叉则跳过\n      // 将候选点加入 openSet, 并计算每个候选点的 cost\n\n      if (!openSet[neighbor.id]) {\n        openSet[neighbor.id] = neighbor;\n      }\n\n      var neighborCost = cfg.distFunc(current, neighbor) + (isNaN(cfg.penalties[directionChange]) ? cfg.gridSize : cfg.penalties[directionChange]);\n      var costFromStart = gScore[current.id] + neighborCost;\n\n      if (gScore[neighbor.id] && costFromStart >= gScore[neighbor.id]) {\n        continue;\n      }\n\n      cameFrom[neighbor.id] = current.id;\n      gScore[neighbor.id] = costFromStart;\n      fScore[neighbor.id] = costFromStart + estimateCost(neighbor, endPoints, cfg.distFunc);\n    }\n\n    remainLoops -= 1;\n  };\n\n  while (Object.keys(openSet).length > 0 && remainLoops > 0) {\n    var state_1 = _loop_1();\n\n    if (_typeof(state_1) === \"object\") return state_1.value;\n    if (state_1 === \"break\") break;\n  }\n\n  return cfg.fallbackRoute(startPoint, endPoint, startNode, endNode, cfg);\n};","map":{"version":3,"sources":["/Users/yangjiafeng/web-src/shake-book-manager/node_modules/@antv/g6-element/es/edges/router.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","Util","deepMix","getExpandedBBox","getExpandedBBoxPoint","getPolylinePoints","simplifyPolyline","isSegmentCrossingBBox","manhattanDist","p1","p2","Math","abs","x","y","eucliDist","sqrt","pow","straightPath","start","end","simplePolyline","startNode","endNode","cfg","offset","defaultCfg","maxAllowedDirectionChange","maximumLoops","gridSize","directions","stepX","stepY","penalties","distFunc","fallbackRoute","octolinearCfg","pos2GridIx","pos","gridIx","floor","sign","getObstacleMap","items","map","forEach","item","bbox","getBBox","minX","maxX","minY","maxY","gridKey","getDirectionAngle","deltaX","deltaY","angle","atan2","PI","getAngleDiff","angle1","angle2","directionChange","estimateCost","from","endPoints","min","Infinity","i","len","length","cost","getBoxPoints","point","oriPoint","node","anotherPoint","points","isInside","expandBBox","_i","directions_1","dir","bounds","boundLine","insterctP","getLineIntersect","width","height","id","push","pathFinder","startPoint","endPoint","routerCfg","obstacles","concat","scaleStartPoint","scaleEndPoint","startPoints","openSet","closedSet","cameFrom","gScore","fScore","firstStep","getDirectionChange","current","neighbor","directionAngle","startAngle","prevDirectionAngle","parseFloat","split","getControlPoints","currentId","controlPoints","lastPoint","unshift","preId","prePoint","firstPoint","remainLoops","_loop_1","curCost","findIndex","value","direction","neighborCost","isNaN","costFromStart","Object","keys","state_1"],"mappings":"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","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/**\n * 通过配置不同的 costFunc, distFunc, constraints 可以得到不同效果的 router\n * generalRouter: 不限制搜索时的移动方向，避开障碍即可\n * orthogonal: 线必须沿着竖直或水平方向（4个方向）\n * octolinearRouter: 线沿着竖直、水平、对角线方向（8个方向）\n */\nimport { Util } from '@antv/g6-core';\nimport { deepMix } from '@antv/util';\nimport { getExpandedBBox, getExpandedBBoxPoint, getPolylinePoints, simplifyPolyline, isSegmentCrossingBBox } from './polyline-util';\n\nvar manhattanDist = function manhattanDist(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n\nvar eucliDist = function eucliDist(p1, p2) {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n};\n\nvar straightPath = function straightPath(start, end) {\n  // console.warn('fallbackRoute: straight path');\n  return [start, end];\n};\n\nvar simplePolyline = function simplePolyline(start, end, startNode, endNode, cfg) {\n  // console.warn('fallbackRoute: simple polyline path');\n  return simplifyPolyline(getPolylinePoints(start, end, startNode, endNode, cfg.offset));\n}; // getPolylinePoints\n\n\nvar defaultCfg = {\n  offset: 20,\n  maxAllowedDirectionChange: 90,\n  maximumLoops: 2000,\n  gridSize: 10,\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: -1\n  }],\n\n  get penalties() {\n    return {\n      0: 0,\n      45: this.gridSize / 2,\n      90: this.gridSize / 2\n    };\n  },\n\n  distFunc: manhattanDist,\n  fallbackRoute: simplePolyline\n};\nexport var octolinearCfg = {\n  maxAllowedDirectionChange: 45,\n  // 8 个方向: 上下左右 + 45度斜线方向\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: 1,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: -1\n  }, {\n    stepX: 0,\n    stepY: -1\n  }, {\n    stepX: 1,\n    stepY: -1\n  }],\n  distFunc: eucliDist,\n  fallbackRoute: straightPath\n};\n\nvar pos2GridIx = function pos2GridIx(pos, gridSize) {\n  var gridIx = Math.floor(Math.abs(pos / gridSize));\n  var sign = pos < 0 ? -1 : 1;\n  return gridIx < 0 ? 0 : sign * gridIx;\n};\n\nvar getObstacleMap = function getObstacleMap(items, gridSize, offset) {\n  var map = {};\n  items.forEach(function (item) {\n    // create-edge 时，当边类型为 polyline 时 endNode 为 null\n    if (item) {\n      var bbox = getExpandedBBox(item.getBBox(), offset);\n\n      for (var x = pos2GridIx(bbox.minX, gridSize); x <= pos2GridIx(bbox.maxX, gridSize); x += 1) {\n        for (var y = pos2GridIx(bbox.minY, gridSize); y <= pos2GridIx(bbox.maxY, gridSize); y += 1) {\n          var gridKey = x + \"|||\" + y;\n          map[gridKey] = true;\n        }\n      }\n    }\n  });\n  return map;\n};\n/**\n * 方向角：计算从 p1 到 p2 的射线与水平线形成的夹角度数（顺时针从右侧0°转到该射线的角度）\n * @param p1 PolyPoint\n * @param p2 PolyPoint\n */\n\n\nvar getDirectionAngle = function getDirectionAngle(p1, p2) {\n  var deltaX = p2.x - p1.x;\n  var deltaY = p2.y - p1.y;\n  if (!deltaX && !deltaY) return 0;\n  var angle = (360 + Math.atan2(deltaY, deltaX) * 180 / Math.PI) % 360;\n  return angle;\n};\n/**\n * 方向角的改变，取小于180度角\n * @param angle1\n * @param angle2\n */\n\n\nvar getAngleDiff = function getAngleDiff(angle1, angle2) {\n  var directionChange = Math.abs(angle1 - angle2);\n  return directionChange > 180 ? 360 - directionChange : directionChange;\n}; // Path finder //\n\n\nvar estimateCost = function estimateCost(from, endPoints, distFunc) {\n  var min = Infinity;\n\n  for (var i = 0, len = endPoints.length; i < len; i++) {\n    var cost = distFunc(from, endPoints[i]);\n\n    if (cost < min) {\n      min = cost;\n    }\n  }\n\n  return min;\n}; // 计算考虑 offset 后的 BBox 上的连接点\n\n\nvar getBoxPoints = function getBoxPoints(point, oriPoint, node, anotherPoint, cfg) {\n  var points = []; // create-edge 生成边的过程中，endNode 为 null\n\n  if (!node) {\n    return points;\n  }\n\n  var directions = cfg.directions,\n      offset = cfg.offset;\n  var bbox = node.getBBox();\n  var isInside = oriPoint.x > bbox.minX && oriPoint.x < bbox.maxX && oriPoint.y > bbox.minY && oriPoint.y < bbox.maxY;\n  var expandBBox = getExpandedBBox(bbox, offset);\n\n  for (var i in expandBBox) {\n    expandBBox[i] = pos2GridIx(expandBBox[i], cfg.gridSize);\n  }\n\n  if (isInside) {\n    // 如果 anchorPoint 在节点内部，允许第一段线穿过节点\n    for (var _i = 0, directions_1 = directions; _i < directions_1.length; _i++) {\n      var dir = directions_1[_i];\n      var bounds = [[{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }]];\n\n      for (var i = 0; i < 4; i++) {\n        var boundLine = bounds[i];\n        var insterctP = Util.getLineIntersect(point, {\n          x: point.x + dir.stepX * expandBBox.width,\n          y: point.y + dir.stepY * expandBBox.height\n        }, boundLine[0], boundLine[1]);\n\n        if (insterctP && !isSegmentCrossingBBox(point, insterctP, bbox)) {\n          insterctP.id = insterctP.x + \"|||\" + insterctP.y;\n          points.push(insterctP);\n        }\n      }\n    }\n  } else {\n    // 如果 anchorPoint 在节点上，只有一个可选方向\n    var insterctP = getExpandedBBoxPoint(expandBBox, point, anotherPoint);\n    insterctP.id = insterctP.x + \"|||\" + insterctP.y;\n    points.push(insterctP);\n  }\n\n  return points;\n};\n\nexport var pathFinder = function pathFinder(startPoint, endPoint, startNode, endNode, routerCfg) {\n  var cfg = deepMix(defaultCfg, routerCfg);\n  cfg.obstacles = cfg.obstacles || [];\n  var map = getObstacleMap(cfg.obstacles.concat([startNode, endNode]), cfg.gridSize, cfg.offset);\n  var scaleStartPoint = {\n    x: pos2GridIx(startPoint.x, cfg.gridSize),\n    y: pos2GridIx(startPoint.y, cfg.gridSize)\n  };\n  var scaleEndPoint = {\n    x: pos2GridIx(endPoint.x, cfg.gridSize),\n    y: pos2GridIx(endPoint.y, cfg.gridSize)\n  };\n  startPoint.id = scaleStartPoint.x + \"|||\" + scaleStartPoint.y;\n  endPoint.id = scaleEndPoint.x + \"|||\" + scaleEndPoint.y;\n  var startPoints = getBoxPoints(scaleStartPoint, startPoint, startNode, scaleEndPoint, cfg);\n  var endPoints = getBoxPoints(scaleEndPoint, endPoint, endNode, scaleStartPoint, cfg);\n  startPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  endPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  var openSet = {};\n  var closedSet = {};\n  var cameFrom = {}; // 从起点到当前点已产生的 cost, default: Infinity\n\n  var gScore = {}; // 起点经过当前点到达终点预估的 cost, default: Infinity\n\n  var fScore = {}; // initialize\n\n  for (var i = 0; i < startPoints.length; i++) {\n    var firstStep = startPoints[i];\n    openSet[firstStep.id] = firstStep; // cameFrom[firstStep.id] = startPoint.id;\n\n    gScore[firstStep.id] = 0;\n    fScore[firstStep.id] = estimateCost(firstStep, endPoints, cfg.distFunc);\n  }\n\n  var getDirectionChange = function getDirectionChange(current, neighbor) {\n    var directionAngle = getDirectionAngle(current, neighbor);\n    var directionChange;\n\n    if (!cameFrom[current.id]) {\n      var startAngle = getDirectionAngle(scaleStartPoint, current);\n      directionChange = getAngleDiff(startAngle, directionAngle);\n    } else {\n      var prevDirectionAngle = getDirectionAngle({\n        x: parseFloat(cameFrom[current.id].split('|||')[0]),\n        y: parseFloat(cameFrom[current.id].split('|||')[1])\n      }, current);\n      directionChange = getAngleDiff(prevDirectionAngle, directionAngle);\n    }\n\n    return directionChange;\n  };\n\n  var getControlPoints = function getControlPoints(currentId) {\n    var controlPoints = [endPoint];\n    var lastPoint = {\n      x: parseFloat(currentId.split('|||')[0]),\n      y: parseFloat(currentId.split('|||')[1]),\n      id: currentId\n    };\n\n    if (getDirectionChange(lastPoint, scaleEndPoint)) {\n      controlPoints.unshift({\n        x: lastPoint.x === scaleEndPoint.x ? endPoint.x : lastPoint.x * cfg.gridSize,\n        y: lastPoint.y === scaleEndPoint.y ? endPoint.y : lastPoint.y * cfg.gridSize\n      });\n    }\n\n    while (cameFrom[currentId] && cameFrom[currentId] !== currentId) {\n      var point = {\n        x: parseFloat(currentId.split('|||')[0]),\n        y: parseFloat(currentId.split('|||')[1]),\n        id: currentId\n      };\n      var preId = cameFrom[currentId];\n      var prePoint = {\n        x: parseFloat(preId.split('|||')[0]),\n        y: parseFloat(preId.split('|||')[1]),\n        id: preId\n      };\n      var directionChange = getDirectionChange(prePoint, point);\n\n      if (directionChange) {\n        controlPoints.unshift({\n          x: prePoint.x === point.x ? controlPoints[0].x : prePoint.x * cfg.gridSize,\n          y: prePoint.y === point.y ? controlPoints[0].y : prePoint.y * cfg.gridSize\n        });\n      }\n\n      currentId = preId;\n    } // 和startNode对齐\n\n\n    var firstPoint = {\n      x: parseFloat(currentId.split('|||')[0]),\n      y: parseFloat(currentId.split('|||')[1]),\n      id: currentId\n    };\n    controlPoints[0].x = firstPoint.x === scaleStartPoint.x ? startPoint.x : controlPoints[0].x;\n    controlPoints[0].y = firstPoint.y === scaleStartPoint.y ? startPoint.y : controlPoints[0].y;\n    controlPoints.unshift(startPoint);\n    return controlPoints;\n  };\n\n  var remainLoops = cfg.maximumLoops;\n\n  var _loop_1 = function _loop_1() {\n    var current;\n    var curCost = Infinity; // 找到 openSet 中 fScore 最小的点\n\n    for (var id in openSet) {\n      if (fScore[id] <= curCost) {\n        curCost = fScore[id];\n        current = openSet[id];\n      }\n    }\n\n    if (!current) return \"break\"; // 如果 fScore 最小的点就是终点\n\n    if (endPoints.findIndex(function (point) {\n      return point.x === current.x && point.y === current.y;\n    }) > -1) {\n      var controlPoints = getControlPoints(current.id);\n      return {\n        value: controlPoints\n      };\n    }\n\n    delete openSet[current.id];\n    closedSet[current.id] = true; // 获取符合条件的下一步的候选连接点\n    // 沿候选方向走一步\n\n    for (var i = 0; i < cfg.directions.length; i++) {\n      var direction = cfg.directions[i];\n      var neighbor = {\n        x: current.x + direction.stepX,\n        y: current.y + direction.stepY,\n        id: current.x + direction.stepX + \"|||\" + (current.y + direction.stepY)\n      };\n      if (closedSet[neighbor.id]) continue;\n      var directionChange = getDirectionChange(current, neighbor);\n      if (directionChange > cfg.maxAllowedDirectionChange) continue;\n      if (map[neighbor.id]) continue; // 如果交叉则跳过\n      // 将候选点加入 openSet, 并计算每个候选点的 cost\n\n      if (!openSet[neighbor.id]) {\n        openSet[neighbor.id] = neighbor;\n      }\n\n      var neighborCost = cfg.distFunc(current, neighbor) + (isNaN(cfg.penalties[directionChange]) ? cfg.gridSize : cfg.penalties[directionChange]);\n      var costFromStart = gScore[current.id] + neighborCost;\n\n      if (gScore[neighbor.id] && costFromStart >= gScore[neighbor.id]) {\n        continue;\n      }\n\n      cameFrom[neighbor.id] = current.id;\n      gScore[neighbor.id] = costFromStart;\n      fScore[neighbor.id] = costFromStart + estimateCost(neighbor, endPoints, cfg.distFunc);\n    }\n\n    remainLoops -= 1;\n  };\n\n  while (Object.keys(openSet).length > 0 && remainLoops > 0) {\n    var state_1 = _loop_1();\n\n    if (_typeof(state_1) === \"object\") return state_1.value;\n    if (state_1 === \"break\") break;\n  }\n\n  return cfg.fallbackRoute(startPoint, endPoint, startNode, endNode, cfg);\n};"]},"metadata":{},"sourceType":"module"}