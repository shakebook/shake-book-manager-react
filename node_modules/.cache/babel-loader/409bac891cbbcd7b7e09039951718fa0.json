{"ast":null,"code":"//菜单树\n//递归树算法 将pid-id的数据库返回的json 转为树json\nexport function toTree(data) {\n  // 删除 所有 children,以防止多次调用\n  let tree = [];\n  data.forEach(function (item) {\n    // const o: any = {\n    //   title: item.menuName as string,\n    //   value: item.id as number,\n    //   key: item.id as number,\n    //   menuIcon: item.menuIcon as string,\n    //   menuName: item.menuName as string,\n    //   menuRouter: item.menuRouter as string,\n    //   parentId: item.parentId as number,\n    // }\n    delete item.children;\n    tree.push(item);\n  }); // 将数据存储为 以id为KEY的map索引数据列 \n\n  var map = new Map();\n  tree.forEach(function (item) {\n    const id = item.key;\n    map.set(id, item);\n  });\n  let val = [];\n  tree.forEach(function (item) {\n    // 以当前遍历项，的pid,去map对象中找到索引的id\n    if ('parentId' in item) {\n      var parent = map.get(item.parentId);\n    } // 好绕啊，如果找到索引，那么说明此项不在顶级当中,那么需要把此项添加到，他对应的父级中\n\n\n    if (parent) {\n      (parent.children || (parent.children = [])).push(item); //这里更改的是map对象的数据(索引数据)\n      // console.log(map);\n    } else {\n      //如果没有在map中找到对应的索引ID,那么直接把 当前的item添加到 val结果集中，作为顶级\n      val.push(item);\n    }\n  });\n  return val;\n}","map":{"version":3,"sources":["/Users/yangjiafeng/web-src/shake-book-manager/src/common/toTree.ts"],"names":["toTree","data","tree","forEach","item","children","push","map","Map","id","key","set","val","parent","get","parentId"],"mappings":"AACA;AACA;AACA,OAAO,SAASA,MAAT,CAAgBC,IAAhB,EAAoC;AACzC;AACA,MAAIC,IAAW,GAAG,EAAlB;AACAD,EAAAA,IAAI,CAACE,OAAL,CAAa,UAAUC,IAAV,EAAgB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAOA,IAAI,CAACC,QAAZ;AACAH,IAAAA,IAAI,CAACI,IAAL,CAAUF,IAAV;AACD,GAZD,EAHyC,CAgBzC;;AACA,MAAIG,GAAG,GAAG,IAAIC,GAAJ,EAAV;AACAN,EAAAA,IAAI,CAACC,OAAL,CAAa,UAAUC,IAAV,EAAqB;AAChC,UAAMK,EAAU,GAAGL,IAAI,CAACM,GAAxB;AACAH,IAAAA,GAAG,CAACI,GAAJ,CAAQF,EAAR,EAAYL,IAAZ;AACD,GAHD;AAKA,MAAIQ,GAAU,GAAG,EAAjB;AACAV,EAAAA,IAAI,CAACC,OAAL,CAAa,UAAUC,IAAV,EAAgB;AAC3B;AACA,QAAI,cAAcA,IAAlB,EAAwB;AACtB,UAAIS,MAAM,GAAGN,GAAG,CAACO,GAAJ,CAAQV,IAAI,CAACW,QAAb,CAAb;AACD,KAJ0B,CAM3B;;;AACA,QAAIF,MAAJ,EAAY;AACV,OAACA,MAAM,CAACR,QAAP,KAAoBQ,MAAM,CAACR,QAAP,GAAkB,EAAtC,CAAD,EAA4CC,IAA5C,CAAiDF,IAAjD,EADU,CAC8C;AACxD;AACD,KAHD,MAGO;AACL;AACAQ,MAAAA,GAAG,CAACN,IAAJ,CAASF,IAAT;AACD;AACF,GAdD;AAgBA,SAAOQ,GAAP;AACD","sourcesContent":["\n//菜单树\n//递归树算法 将pid-id的数据库返回的json 转为树json\nexport function toTree(data: any[]): any[] {\n  // 删除 所有 children,以防止多次调用\n  let tree: any[] = []\n  data.forEach(function (item) {\n    // const o: any = {\n    //   title: item.menuName as string,\n    //   value: item.id as number,\n    //   key: item.id as number,\n    //   menuIcon: item.menuIcon as string,\n    //   menuName: item.menuName as string,\n    //   menuRouter: item.menuRouter as string,\n    //   parentId: item.parentId as number,\n    // }\n    delete item.children\n    tree.push(item)\n  });\n  // 将数据存储为 以id为KEY的map索引数据列 \n  var map = new Map<any, any>();\n  tree.forEach(function (item: any) {\n    const id: number = item.key\n    map.set(id, item)\n  });\n\n  let val: any[] = [];\n  tree.forEach(function (item) {\n    // 以当前遍历项，的pid,去map对象中找到索引的id\n    if ('parentId' in item) {\n      var parent = map.get(item.parentId);\n    }\n\n    // 好绕啊，如果找到索引，那么说明此项不在顶级当中,那么需要把此项添加到，他对应的父级中\n    if (parent) {\n      (parent.children || (parent.children = [])).push(item); //这里更改的是map对象的数据(索引数据)\n      // console.log(map);\n    } else {\n      //如果没有在map中找到对应的索引ID,那么直接把 当前的item添加到 val结果集中，作为顶级\n      val.push(item);\n    }\n  });\n\n  return val\n}"]},"metadata":{},"sourceType":"module"}