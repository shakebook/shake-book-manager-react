{"ast":null,"code":"//菜单树\n//递归树算法 将pid-id的数据库返回的json 转为树json\nexport function toTree(data) {\n  // 删除 所有 children,以防止多次调用\n  let tree = [];\n  data.forEach(function (item) {\n    const o = {\n      title: item.menuName,\n      value: item.id,\n      key: item.id,\n      menuIcon: item.menuIcon,\n      menuName: item.menuName,\n      menuRouter: item.menuRouter,\n      parentId: item.parentId\n    };\n    delete o.children;\n    tree.push(o);\n  }); // 将数据存储为 以id为KEY的map索引数据列 \n\n  var map = new Map();\n  tree.forEach(function (item) {\n    const id = item.key;\n    map.set(id, item);\n  });\n  let val = [];\n  tree.forEach(function (item) {\n    // 以当前遍历项，的pid,去map对象中找到索引的id\n    var parent = map.get(item.parentId); // 好绕啊，如果找到索引，那么说明此项不在顶级当中,那么需要把此项添加到，他对应的父级中\n\n    if (parent) {\n      (parent.children || (parent.children = [])).push(item); //这里更改的是map对象的数据(索引数据)\n      // console.log(map);\n    } else {\n      //如果没有在map中找到对应的索引ID,那么直接把 当前的item添加到 val结果集中，作为顶级\n      val.push(item);\n    }\n  });\n  return val;\n}","map":{"version":3,"sources":["/Users/yangjiafeng/web-src/shake-book-manager/src/common/toTree.ts"],"names":["toTree","data","tree","forEach","item","o","title","menuName","value","id","key","menuIcon","menuRouter","parentId","children","push","map","Map","set","val","parent","get"],"mappings":"AACA;AACA;AACA,OAAO,SAASA,MAAT,CAAgBC,IAAhB,EAAoC;AACzC;AACA,MAAIC,IAAW,GAAG,EAAlB;AACAD,EAAAA,IAAI,CAACE,OAAL,CAAa,UAAUC,IAAV,EAAgB;AAC3B,UAAMC,CAAM,GAAG;AACbC,MAAAA,KAAK,EAAEF,IAAI,CAACG,QADC;AAEbC,MAAAA,KAAK,EAAEJ,IAAI,CAACK,EAFC;AAGbC,MAAAA,GAAG,EAAEN,IAAI,CAACK,EAHG;AAIbE,MAAAA,QAAQ,EAAEP,IAAI,CAACO,QAJF;AAKbJ,MAAAA,QAAQ,EAAEH,IAAI,CAACG,QALF;AAMbK,MAAAA,UAAU,EAAER,IAAI,CAACQ,UANJ;AAObC,MAAAA,QAAQ,EAAET,IAAI,CAACS;AAPF,KAAf;AASA,WAAOR,CAAC,CAACS,QAAT;AACAZ,IAAAA,IAAI,CAACa,IAAL,CAAUV,CAAV;AACD,GAZD,EAHyC,CAgBzC;;AACA,MAAIW,GAAG,GAAG,IAAIC,GAAJ,EAAV;AACAf,EAAAA,IAAI,CAACC,OAAL,CAAa,UAAUC,IAAV,EAAqB;AAChC,UAAMK,EAAU,GAAGL,IAAI,CAACM,GAAxB;AACAM,IAAAA,GAAG,CAACE,GAAJ,CAAQT,EAAR,EAAYL,IAAZ;AACD,GAHD;AAKA,MAAIe,GAAU,GAAG,EAAjB;AACAjB,EAAAA,IAAI,CAACC,OAAL,CAAa,UAAUC,IAAV,EAAgB;AAC3B;AACA,QAAIgB,MAAM,GAAGJ,GAAG,CAACK,GAAJ,CAAQjB,IAAI,CAACS,QAAb,CAAb,CAF2B,CAG3B;;AACA,QAAIO,MAAJ,EAAY;AACV,OAACA,MAAM,CAACN,QAAP,KAAoBM,MAAM,CAACN,QAAP,GAAkB,EAAtC,CAAD,EAA4CC,IAA5C,CAAiDX,IAAjD,EADU,CAC8C;AACxD;AACD,KAHD,MAGO;AACL;AACAe,MAAAA,GAAG,CAACJ,IAAJ,CAASX,IAAT;AACD;AACF,GAXD;AAaA,SAAOe,GAAP;AACD","sourcesContent":["\n//菜单树\n//递归树算法 将pid-id的数据库返回的json 转为树json\nexport function toTree(data: any[]): any[] {\n  // 删除 所有 children,以防止多次调用\n  let tree: any[] = []\n  data.forEach(function (item) {\n    const o: any = {\n      title: item.menuName as string,\n      value: item.id as number,\n      key: item.id as number,\n      menuIcon: item.menuIcon as string,\n      menuName: item.menuName as string,\n      menuRouter: item.menuRouter as string,\n      parentId: item.parentId as number,\n    }\n    delete o.children\n    tree.push(o)\n  });\n  // 将数据存储为 以id为KEY的map索引数据列 \n  var map = new Map<any, any>();\n  tree.forEach(function (item: any) {\n    const id: number = item.key\n    map.set(id, item)\n  });\n\n  let val: any[] = [];\n  tree.forEach(function (item) {\n    // 以当前遍历项，的pid,去map对象中找到索引的id\n    var parent = map.get(item.parentId);\n    // 好绕啊，如果找到索引，那么说明此项不在顶级当中,那么需要把此项添加到，他对应的父级中\n    if (parent) {\n      (parent.children || (parent.children = [])).push(item); //这里更改的是map对象的数据(索引数据)\n      // console.log(map);\n    } else {\n      //如果没有在map中找到对应的索引ID,那么直接把 当前的item添加到 val结果集中，作为顶级\n      val.push(item);\n    }\n  });\n\n  return val\n}"]},"metadata":{},"sourceType":"module"}